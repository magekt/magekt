<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Game: Infinite Map</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game, overriding some Tailwind defaults for specific elements */
        body {
            margin: 0;
            height: 100vh; /* Full viewport height */
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            font-family: "Inter", sans-serif; /* Preferred font */
            display: flex;
            flex-direction: column; /* Stack children vertically */
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
            overflow: hidden; /* Prevent scrolling on the body */
            padding: 0.5rem; /* Small padding around the entire game container */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .game-container {
            display: flex;
            flex-direction: column; /* Stack children vertically */
            align-items: center; /* Center content horizontally */
            flex-grow: 1; /* Allow container to take up available vertical space */
            justify-content: space-between; /* Distribute space between title, canvas, controls */
            width: 100%; /* Take full width */
            height: 100%; /* Take full height of parent (body) */
            max-width: 100%;
            max-height: 100%; /* Ensure container doesn't exceed viewport height */
            box-sizing: border-box;
            padding: 0.5rem; /* Padding inside the container */
        }
        .game-title {
            font-size: 2.5rem; /* Larger title */
            font-weight: bold;
            color: #63b3ed; /* Lighter blue for title */
            margin-bottom: 0.5rem; /* Reduced margin */
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-align: center;
            line-height: 1.1; /* Adjust line height for smaller screens */
            flex-shrink: 0; /* Prevent title from shrinking */
        }
        .game-instructions {
            font-size: 0.9rem; /* Slightly smaller font for instructions */
            color: #a0aec0;
            text-align: center;
            margin-bottom: 0.8rem; /* Reduced margin */
            max-width: 90%; /* Prevent text from being too wide on small screens */
            flex-shrink: 0; /* Prevent instructions from shrinking */
        }
        canvas {
            display: block;
            border: 2px solid #4a5568; /* Subtle border */
            background-color: #2d3748; /* Slightly lighter background for canvas */
            border-radius: 0.5rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Soft shadow */
            /* Fixed internal game grid size, but allow the canvas element to shrink/grow */
            width: 600px; /* Original fixed width for internal drawing */
            height: 600px; /* Original fixed height for internal drawing */
            max-width: 100%; /* Allow canvas to shrink to fit container width */
            max-height: 100%; /* Allow canvas to shrink to fit container height */
            flex-grow: 1; /* Allow canvas to take up available space */
            flex-shrink: 1; /* Allow canvas to shrink */
            min-width: 0; /* Important for flex items to shrink below their content size */
            min-height: 0; /* Important for flex items to shrink below their content size */
            object-fit: contain; /* Shrink to fit while maintaining aspect ratio */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
        }

        /* Adjust font sizes for very small screens if necessary */
        @media (max-width: 650px) {
            .game-title {
                font-size: 2rem; /* Smaller title on very narrow screens */
            }
            .game-instructions {
                font-size: 0.8rem;
            }
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.4rem; /* Reduced space between buttons */
            margin-top: 0.8rem; /* Reduced margin */
            width: 100%; /* Ensure controls take full width to wrap effectively */
            box-sizing: border-box;
            padding: 0 0.5rem; /* Small horizontal padding */
            flex-shrink: 0; /* Prevent controls from shrinking */
        }
        .controls button {
            padding: 0.6rem 1rem; /* Slightly smaller padding for buttons */
            background-color: #4299e1; /* Blue button */
            color: white;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.9rem; /* Slightly smaller font for buttons */
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 70px; /* Ensure buttons have a minimum width, slightly smaller */
            flex-grow: 1; /* Allow buttons to grow to fill space in their row */
            max-width: 120px; /* Limit max width for individual buttons */
        }
        .controls button:hover {
            background-color: #3182ce; /* Darker blue on hover */
            transform: translateY(-1px); /* Slight lift effect */
        }
        .controls button:active {
            transform: translateY(1px); /* Press effect */
        }

        /* Styles for the upgrade menu buttons */
        #upgrade-menu-buttons {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100; /* Ensure it's on top */
            border: 2px solid #63b3ed;
            box-shadow: 0 0 15px rgba(99, 179, 237, 0.5);
            max-width: 90vw; /* Ensure upgrade menu fits screen width */
            max-height: 90vh; /* Ensure upgrade menu fits screen height */
            overflow-y: auto; /* Allow scrolling within the upgrade menu if content is too long */
            box-sizing: border-box;
        }
        #upgrade-menu-buttons button {
            background-color: #4c51bf; /* Indigo */
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border: none;
            white-space: nowrap; /* Prevent button text from wrapping */
        }
        #upgrade-menu-buttons button:hover {
            background-color: #5a67d8; /* Lighter indigo */
        }
        #upgrade-menu-buttons button:active {
            transform: translateY(1px);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="game-title">Infinite Map Adventure</h1>
        <p class="game-instructions">Navigate the fixed game area, collect coins, defeat enemies, and upgrade your hero!</p>

        <canvas id="gameCanvas"></canvas>

        <div id="controls" class="controls">
            <button id="up" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">↑</button>
            <button id="left" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">←</button>
            <button id="down" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">↓</button>
            <button id="right" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">→</button>
            <button id="pause" class="bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">Pause</button>
            <button id="soundToggle" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">Sound: Off</button>
        </div>
    </div>

    <!-- Upgrade Menu Buttons Container (initially hidden) -->
    <div id="upgrade-menu-buttons" style="display: none;">
        <h2 class="text-white text-center text-xl mb-4">Choose an Upgrade:</h2>
        <!-- Buttons will be dynamically updated with current values -->
        <button data-upgrade="1" id="upgrade-1">1: +Move Speed</button>
        <button data-upgrade="2" id="upgrade-2">2: -Shoot CD</button>
        <button data-upgrade="3" id="upgrade-3">3: +Dash Dist</button>
        <button data-upgrade="4" id="upgrade-4">4: -Special CD</button>
        <button data-upgrade="5" id="upgrade-5">5: +Extra Life</button>
        <button data-upgrade="6" id="upgrade-6">6: +Bullet DMG</button>
        <button data-upgrade="7" id="upgrade-7">7: +Combo Bonus</button>
        <button data-upgrade="8" id="upgrade-8">8: +Shield Dur</button>
        <button data-upgrade="9" id="upgrade-9">9: +Freeze Dur</button>
    </div>

    <script>
        // -------------------- GLOBAL VARIABLES & NEW FEATURE FLAGS --------------------
        let soundEnabled = false; // Sound off by default
        let doubleScoreActive = false;
        let doubleScoreTimer = 0;
        let timeOfDay = 0; // For day/night cycle
        let bossSpecialTimer = 300; // Timer for boss special homing attack

        // -------------------- CONSTANTS & SETTINGS --------------------
        const CANVAS_WIDTH = 600; // Original canvas size
        const CANVAS_HEIGHT = 600;

        // Game Viewport Constants: All game logic and drawing happens within this area
        const GAME_VIEWPORT_WIDTH = 340;
        const GAME_VIEWPORT_HEIGHT = 150;
        // Offset to center the game viewport on the larger 600x600 canvas
        const GAME_VIEWPORT_X_OFFSET = (CANVAS_WIDTH - GAME_VIEWPORT_WIDTH) / 2;
        const GAME_VIEWPORT_Y_OFFSET = (CANVAS_HEIGHT - GAME_VIEWPORT_HEIGHT) / 2;

        const PLAYER_SIZE = 10;
        const COIN_SIZE = 8;
        const OBSTACLE_SIZE = 10;
        const BULLET_SIZE = 4;
        const BULLET_SPEED = 7;
        const INITIAL_MOVE_SPEED = 5;
        const INITIAL_DASH_DISTANCE = 20;
        const INITIAL_SHOOT_COOLDOWN = 20;
        const INITIAL_SPECIAL_COOLDOWN = 60;
        const DASH_COOLDOWN = 120;
        const INVINCIBILITY_DURATION = 300;
        const SPEED_BOOST_DURATION = 300;
        const COMBO_RESET_TIME = 120;
        const SPECIAL_ATTACK_RANGE = 50;
        const PARTICLE_COUNT = 10;
        const PARTICLE_MAX_LIFE = 50; // Max life for particles
        const PLAYER_HIT_FLASH_DURATION = 10; // Frames player flashes red after being hit
        const ENEMY_HIT_FLASH_DURATION = 5; // Frames enemy flashes white after being hit

        const BOSS_SHOOT_INTERVAL = 150; // frames
        const BOSS_BULLET_SPEED = 4;

        const ENERGY_REGEN_RATE = 0.05;
        const MAX_ENERGY = 100;
        const ULTIMATE_BONUS = 20;

        let currentShieldDuration = 300;
        let currentFreezeDuration = 180;

        // Enemy types – all use a singular speed.
        const enemyTypes = {
            normal: { color: "#f00",    health: 1, size: 10, hitColor: "#fff" },
            fast:   { color: "#ffa500", health: 1, size: 8, hitColor: "#fff" },
            tough:  { color: "#800000", health: 2, size: 12, hitColor: "#fff" },
            rusher: { color: "#a0a0ff", health: 1, size: 10, hitColor: "#fff" }
        };

        const INITIAL_BASE_SPEED = 0.01;

        // Spawn distances adjusted for the smaller game viewport
        const SPAWN_NEAR_MIN = 20;
        const SPAWN_NEAR_MAX = 60;
        const SPAWN_ENEMY_MIN = 30;
        const SPAWN_ENEMY_MAX = 80;
        const SPAWN_OBSTACLE_MIN = 20;
        const SPAWN_OBSTACLE_MAX = 70;
        const SPAWN_BOSS_MIN = 40;
        const SPAWN_BOSS_MAX = 90;

        const SAFEZONE_RADIUS = 50;
        const SAFEZONE_DURATION = 600;
        const SAFEZONE_CHANCE = 0.0005;

        // -------------------- TOWN LOCATION (relative to game viewport) --------------------
        let town = { x: GAME_VIEWPORT_WIDTH - 60, y: 20, width: 40, height: 40 };

        // -------------------- FALLING DEBRIS --------------------
        const DEBRIS_SPAWN_CHANCE = 0.001;
        const DEBRIS_SPEED = 2;
        let debris = [];

        /**
         * Spawns falling debris from above the game viewport.
         */
        function spawnDebris() {
            let x = Math.random() * GAME_VIEWPORT_WIDTH;
            let y = -10; // Start slightly above the game viewport
            debris.push({ x: x, y: y, speed: DEBRIS_SPEED });
        }

        // -------------------- SCROLLING BACKGROUND --------------------
        const STAR_COUNT = 100;
        const STAR_SPEED_FACTOR = 0.05;
        let stars = [];
        // Initialize stars
        for (let i = 0; i < STAR_COUNT; i++) {
            stars.push({
                x: Math.random() * CANVAS_WIDTH, // Stars span the whole canvas
                y: Math.random() * CANVAS_HEIGHT,
                size: Math.random() * 2 + 0.5,
                opacity: Math.random() * 0.5 + 0.5
            });
        }

        // -------------------- CANVAS & AUDIO SETUP --------------------
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(frequency, duration) {
            if (!soundEnabled) return;
            let osc = audioCtx.createOscillator();
            let gain = audioCtx.createGain();
            osc.frequency.value = frequency;
            osc.type = "square";
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
            osc.stop(audioCtx.currentTime + duration);
        }
        function soundShoot() { playSound(600, 0.05); }
        function soundEnemyDeath() { playSound(400, 0.08); }
        function soundLevelUp() { playSound(700, 0.15); }
        function soundDash() { playSound(300, 0.07); }
        function soundPlayerHit() { playSound(200, 0.1); }
        function soundBossShoot() { playSound(500, 0.08); }
        function soundUltimate() { playSound(800, 0.2); }
        function soundCoinCollect() { playSound(900, 0.05); }
        function soundPowerupCollect() { playSound(1200, 0.08); }
        function soundBombExplode() { playSound(250, 0.3); }

        // -------------------- SCREEN SHAKE --------------------
        let shakeTimer = 0;
        function applyShake() {
            if(shakeTimer > 0) {
                shakeTimer--;
                let dx = (Math.random()-0.5)*6;
                let dy = (Math.random()-0.5)*6;
                ctx.translate(dx, dy);
            }
        }

        // -------------------- BOSS BULLETS --------------------
        let bossBullets = [];
        let bossShootTimer = BOSS_SHOOT_INTERVAL;

        /**
         * Updates the position and behavior of boss bullets, checking for player collisions.
         */
        function updateBossBullets() {
            for(let i = bossBullets.length - 1; i >= 0; i--){
                let b = bossBullets[i];
                // For boss special homing bullets, adjust velocity to track player.
                if(b.isBossSpecial) {
                    let dx = player.x - b.x, dy = player.y - b.y;
                    let mag = Math.sqrt(dx*dx + dy*dy) || 1;
                    let desiredVx = (dx/mag) * BOSS_BULLET_SPEED;
                    let desiredVy = (dy/mag) * BOSS_BULLET_SPEED;
                    let homingFactor = 0.05; // Controls how quickly bullets adjust course
                    b.vx += (desiredVx - b.vx) * homingFactor;
                    b.vy += (desiredVy - b.vy) * homingFactor;
                }
                b.x += b.vx;
                b.y += b.vy;

                // Remove bullets that go off-screen (relative to game viewport)
                if(b.x < -10 || b.x > GAME_VIEWPORT_WIDTH + 10 || b.y < -10 || b.y > GAME_VIEWPORT_HEIGHT + 10) {
                    bossBullets.splice(i,1);
                    continue;
                }

                // Check for collision with player
                if(collides(b, player, 8) && !playerSafe) {
                    if(shieldActive) {
                        shieldActive = false;
                        shieldTimer = 0;
                    } else {
                        player.h--; // Player takes damage
                        player.hitTimer = PLAYER_HIT_FLASH_DURATION; // Player flashes on hit
                    }
                    bossBullets.splice(i,1);
                    shakeTimer = 10; // Apply screen shake
                    soundPlayerHit();
                }
            }
        }

        // -------------------- ULTIMATE ENERGY & MOVE --------------------
        let energy = 0;

        /**
         * Regenerates player energy over time.
         */
        function updateEnergy() {
            energy = Math.min(MAX_ENERGY, energy + ENERGY_REGEN_RATE);
        }

        /**
         * Executes the ultimate move, clearing enemies and granting bonus score.
         */
        function ultimateMove() {
            if(energy >= MAX_ENERGY) {
                enemies.forEach(en => { spawnExplosion(en.x, en.y); });
                if(boss) { spawnExplosion(boss.x, boss.y); }
                let count = enemies.length + (boss ? 1 : 0);
                score += ULTIMATE_BONUS + count * 2;
                spawnScorePopup(player.x, player.y, `+${ULTIMATE_BONUS + count * 2}`, "#00ffff"); // Score popup for ultimate
                enemies = []; // Clear all enemies
                boss = null; // Clear boss
                energy = 0; // Reset energy
                soundUltimate();
            }
        }

        // -------------------- GAME STATE VARIABLES --------------------
        let gameState = "start";
        let player, coin, score, lives, level;
        let specialTimer, shootTimer, dashTimer;
        let baseSpeed, enemies, boss, obstacles, powerups, bullets;
        let invincible, invTimer, shieldActive, shieldTimer, freezeTimer;
        let playerSpeedBoost = 1, speedBoostTimer = 0;
        let lastDir = "up"; // Last direction player moved, for bullet orientation
        let comboCount, comboTimer;
        let upgradeMenuActive = false, upgradeMenuTimer = 0;
        let levelTransitionTimer = 0;
        let highScore = localStorage.getItem("highScore") || 0;
        let currentBulletDamage = 1;
        let particles = [];
        let scorePopups = []; // Array to hold floating score texts
        let dashParticles = []; // For dash visual effect

        // Player health
        const PLAYER_MAX_HEALTH = 10;
        let currentMoveSpeed = INITIAL_MOVE_SPEED;
        let currentDashDistance = INITIAL_DASH_DISTANCE;
        let currentShootCooldown = INITIAL_SHOOT_COOLDOWN;
        let currentSpecialCooldown = INITIAL_SPECIAL_COOLDOWN;

        // Player movement state
        let keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

        // Safe zone variables
        let safeZone = null;
        let playerSafe = false;

        // Touch input variables
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoveX = 0;
        let touchMoveY = 0;
        let isTouching = false;
        const SWIPE_THRESHOLD = 20; // Minimum pixel distance for a swipe to register

        // -------------------- COLLISION FUNCTION (Squared Distance) --------------------
        /**
         * Checks for collision between two circular entities.
         * @param {object} a - First entity with x, y coordinates.
         * @param {object} b - Second entity with x, y coordinates.
         * @param {number} threshold - The squared distance threshold for collision.
         * @returns {boolean} True if entities are colliding, false otherwise.
         */
        function collides(a, b, threshold = 10) {
            let dx = a.x - b.x;
            let dy = a.y - b.y;
            return dx * dx + dy * dy < threshold * threshold;
        }

        // -------------------- SPATIAL PARTITIONING --------------------
        /**
         * Builds a grid for spatial partitioning of enemies to optimize collision checks.
         * @param {Array<object>} enemies - Array of enemy objects.
         * @param {number} cellSize - Size of each grid cell.
         * @returns {object} A grid object where keys are "x,y" cell coordinates and values are arrays of enemies in that cell.
         */
        function buildEnemyGrid(enemies, cellSize) {
            const grid = {};
            enemies.forEach(enemy => {
                let cellX = Math.floor(enemy.x / cellSize);
                let cellY = Math.floor(enemy.y / cellSize);
                let key = cellX + "," + cellY;
                if(!grid[key]) grid[key] = [];
                grid[key].push(enemy);
            });
            return grid;
        }

        // -------------------- SPAWN FUNCTIONS --------------------
        /**
         * Spawns an entity within the game viewport, relative to its center.
         * @param {number} minDistFromCenter - Minimum distance from the viewport center.
         * @param {number} maxDistFromCenter - Maximum distance from the viewport center.
         * @returns {object} New coordinates for the spawned entity, relative to viewport top-left.
         */
        function spawnInGameArea(minDistFromCenter, maxDistFromCenter) {
            let centerX = GAME_VIEWPORT_WIDTH / 2;
            let centerY = GAME_VIEWPORT_HEIGHT / 2;
            let angle = Math.random() * Math.PI * 2;
            let dist = minDistFromCenter + Math.random() * (maxDistFromCenter - minDistFromCenter);
            let x = centerX + Math.cos(angle) * dist;
            let y = centerY + Math.sin(angle) * dist;

            // Clamp to ensure within game viewport bounds with a small buffer
            x = Math.max(5, Math.min(GAME_VIEWPORT_WIDTH - 5, x));
            y = Math.max(5, Math.min(GAME_VIEWPORT_HEIGHT - 5, y));
            return { x: x, y: y };
        }

        /**
         * Spawns enemies based on the current level.
         */
        function spawnEnemies() {
            enemies = [];
            for (let i = 0; i < level; i++) {
                let r = Math.random();
                let type;
                if(r < 0.1)      { type = "rusher"; }
                else if(r < 0.5) { type = "normal"; }
                else if(r < 0.8) { type = "fast"; }
                else             { type = "tough"; }
                let speed = INITIAL_BASE_SPEED + (level * 0.001); // Scale enemy speed with level
                let extraHealth = (type !== "normal") ? Math.floor(level / 3) : 0;
                let health = enemyTypes[type].health + extraHealth;
                let pos = spawnInGameArea(SPAWN_ENEMY_MIN, SPAWN_ENEMY_MAX);
                enemies.push({ x: pos.x, y: pos.y, s: speed, h: health, maxH: health, type, size: enemyTypes[type].size, hitTimer: 0 });
            }
        }

        /**
         * Spawns the boss if the level is a multiple of 5.
         */
        function spawnBoss() {
            if(level % 5 === 0) {
                let pos = spawnInGameArea(SPAWN_BOSS_MIN, SPAWN_BOSS_MAX);
                let bossHealth = 5 + level * 2; // Boss health scales more
                boss = { x: pos.x, y: pos.y, s: INITIAL_BASE_SPEED * 0.5, h: bossHealth, maxH: bossHealth, minionsSpawned: false, size: 20, hitTimer: 0 };
            } else {
                boss = null;
            }
        }

        /**
         * Spawns environmental obstacles.
         */
        function spawnObstacles() {
            obstacles = [];
            for (let i = 0; i < 3 + Math.floor(level/5); i++) { // More obstacles at higher levels
                let pos = spawnInGameArea(SPAWN_OBSTACLE_MIN, SPAWN_OBSTACLE_MAX);
                obstacles.push({ x: pos.x, y: pos.y, size: OBSTACLE_SIZE + Math.random() * 5 }); // Vary obstacle size
            }
        }

        /**
         * Spawns a random power-up.
         */
        function spawnPowerup() {
            let rand = Math.random();
            let type;
            if(rand < 0.05)      type = "double";
            else if(rand < 0.25) type = "inv"; // Increased chance for invincibility
            else if(rand < 0.45) type = "speed";
            else if(rand < 0.65) type = "shield";
            else if(rand < 0.8)  type = "freeze";
            else if(rand < 0.9)  type = "health"; // New Health Pack (10% chance)
            else                type = "bomb";   // New Bomb (10% chance)
            let pos = spawnInGameArea(SPAWN_ENEMY_MIN, SPAWN_ENEMY_MAX);
            powerups.push({ x: pos.x, y: pos.y, type });
        }

        /**
         * Spawns a coin near the player.
         */
        function spawnCoin() {
            coin = spawnInGameArea(SPAWN_NEAR_MIN, SPAWN_NEAR_MAX);
        }

        // -------------------- INITIALIZE / RESET GAME --------------------
        /**
         * Initializes or resets all game variables to their starting values.
         */
        function initGame() {
            // Player starts in the center of the game viewport
            player = { x: GAME_VIEWPORT_WIDTH / 2, y: GAME_VIEWPORT_HEIGHT / 2, h: PLAYER_MAX_HEALTH, maxH: PLAYER_MAX_HEALTH, hitTimer: 0, vx: 0, vy: 0 };
            spawnCoin();
            score = 0;
            lives = 3;
            level = 1;
            specialTimer = 0;
            shootTimer = 0;
            dashTimer = 0;
            baseSpeed = INITIAL_BASE_SPEED;
            invincible = false;
            invTimer = 0;
            shieldActive = false;
            shieldTimer = 0;
            freezeTimer = 0;
            playerSpeedBoost = 1;
            speedBoostTimer = 0;
            bullets = [];
            powerups = [];
            bossBullets = [];
            bossShootTimer = BOSS_SHOOT_INTERVAL;
            lastDir = "up";
            comboCount = 0;
            comboTimer = 0;
            upgradeMenuActive = false;
            upgradeMenuTimer = 0;
            levelTransitionTimer = 0;
            currentMoveSpeed = INITIAL_MOVE_SPEED;
            currentDashDistance = INITIAL_DASH_DISTANCE;
            currentShootCooldown = INITIAL_SHOOT_COOLDOWN;
            currentSpecialCooldown = INITIAL_SPECIAL_COOLDOWN;
            currentBulletDamage = 1;
            currentShieldDuration = 300;
            currentFreezeDuration = 180;
            energy = 0;
            particles = [];
            scorePopups = [];
            dashParticles = [];
            debris = [];
            stars = []; // Re-initialize stars
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    size: Math.random() * 2 + 0.5,
                    opacity: Math.random() * 0.5 + 0.5
                });
            }
            spawnEnemies();
            spawnBoss();
            spawnObstacles();
            gameState = "start";
            shakeTimer = 0;
            safeZone = null;
            doubleScoreActive = false;
            doubleScoreTimer = 0;
            bossSpecialTimer = 300;
            timeOfDay = 0;

            // Hide upgrade menu buttons on reset
            document.getElementById('upgrade-menu-buttons').style.display = 'none';

            // Reset keys state
            keys = {
                ArrowUp: false,
                ArrowDown: false,
                ArrowLeft: false,
                ArrowRight: false
            };
        }
        initGame(); // Call initGame once to set up the initial state

        // -------------------- DRAWING UTILITIES --------------------
        /**
         * Draws a health bar for an entity.
         * @param {number} x - X coordinate of the health bar (relative to viewport).
         * @param {number} y - Y coordinate of the health bar (relative to viewport).
         * @param {number} width - Total width of the health bar.
         * @param {number} height - Height of the health bar.
         * @param {number} currentHealth - Current health value.
         * @param {number} maxHealth - Maximum health value.
         * @param {string} color - Color of the filled health bar.
         */
        function drawHealthBar(x, y, width, height, currentHealth, maxHealth, color = "#0f0") {
            ctx.fillStyle = "#333"; // Background of health bar
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = color; // Filled health bar color
            let healthWidth = (currentHealth / maxHealth) * width;
            ctx.fillRect(x, y, healthWidth, height);
            ctx.strokeStyle = "#fff"; // Border
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, width, height);
        }

        // -------------------- SCROLLING BACKGROUND --------------------
        /**
         * Draws a scrolling starfield background.
         */
        function drawScrollingBackground() {
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            stars.forEach(star => {
                // Stars are drawn relative to the full canvas, not the game viewport
                let screenX = star.x - (player.x * STAR_SPEED_FACTOR) % CANVAS_WIDTH;
                let screenY = star.y - (player.y * STAR_SPEED_FACTOR) % CANVAS_HEIGHT;

                // Wrap stars around if they go off screen
                if (screenX < 0) screenX += CANVAS_WIDTH;
                if (screenY < 0) screenY += CANVAS_HEIGHT;
                if (screenX > CANVAS_WIDTH) screenX -= CANVAS_WIDTH;
                if (screenY > CANVAS_HEIGHT) screenY -= CANVAS_HEIGHT;

                ctx.globalAlpha = star.opacity;
                ctx.beginPath();
                ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1; // Reset alpha
        }

        // -------------------- MINIMAP FUNCTION --------------------
        /**
         * Draws a minimap showing the player, coin, safe zone, and town.
         */
        function drawMinimap() {
            let mapWidth = 80, mapHeight = 80;
            let mapX = CANVAS_WIDTH - mapWidth - 10, mapY = 10;
            ctx.save();
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(mapX, mapY, mapWidth, mapHeight);
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(mapX, mapY, mapWidth, mapHeight);

            // Scaling factors for mapping game viewport coordinates to minimap coordinates
            let scaleX = mapWidth / GAME_VIEWPORT_WIDTH;
            let scaleY = mapHeight / GAME_VIEWPORT_HEIGHT;

            function drawMarker(worldObj, color, label) {
                // Map world coordinates (0 to GAME_VIEWPORT_WIDTH/HEIGHT) to minimap coordinates
                let x = mapX + worldObj.x * scaleX;
                let y = mapY + worldObj.y * scaleY;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.font = "8px sans-serif";
                ctx.fillText(label, x+4, y+4);
            }
            drawMarker(player, "#0f0", "P");
            drawMarker(coin, "#ff0", "C");
            if(safeZone) drawMarker(safeZone, "#0ff", "S");
            let townCenter = { x: town.x + town.width/2, y: town.y + town.height/2 };
            drawMarker(townCenter, "#fff", "T");
            ctx.restore();
        }

        // -------------------- DAY/NIGHT CYCLE UPDATE --------------------
        /**
         * Updates the time of day and returns a corresponding background color.
         * @returns {string} RGB color string for the background.
         */
        function updateDayNightCycle() {
            timeOfDay += 0.005; // Slower cycle for more gradual transition
            // Adjust brightness and color more significantly for day/night
            let baseBrightness = 10; // Darkest at night
            let maxBrightness = 60; // Brightest during day
            let currentBrightness = baseBrightness + (maxBrightness - baseBrightness) * (0.5 + 0.5 * Math.sin(timeOfDay));

            let red = Math.floor(currentBrightness);
            let green = Math.floor(currentBrightness * 0.9);
            let blue = Math.floor(currentBrightness * 0.8);

            // Add a slight tint for sunrise/sunset
            if (Math.sin(timeOfDay) > 0.8) { // Approaching peak day (morning)
                red = Math.floor(red * 1.1 + 20); // More red/orange
                green = Math.floor(green * 1.05 + 10);
            } else if (Math.sin(timeOfDay) < -0.8) { // Approaching peak night (evening)
                red = Math.floor(red * 0.9);
                green = Math.floor(green * 0.9);
                blue = Math.floor(blue * 1.1 + 20); // More blue/purple
            }
            return `rgb(${red},${green},${blue})`;
        }

        // -------------------- MAGIC ARROW BULLET TRACKING --------------------
        /**
         * Finds the nearest enemy to the player for targeting.
         * @returns {object|null} The nearest enemy object, or null if no enemies are present.
         */
        function findNearestEnemy() {
            let minDist = Infinity;
            let chosen = null;
            for(let i = 0; i < enemies.length; i++){
                let en = enemies[i];
                let dx = en.x - player.x;
                let dy = en.y - player.y;
                let distSq = dx*dx + dy*dy;
                if(distSq < minDist) {
                    minDist = distSq;
                    chosen = en;
                }
            }
            return chosen;
        }

        // -------------------- AUTOMATED POWERS --------------------
        /**
         * Manages automated player abilities like shooting, special attack, and dashing.
         */
        function autoPowers() {
            // Auto-shoot
            if(shootTimer <= 0) {
                let target = findNearestEnemy();
                let vx, vy;
                if(target) {
                    let dx = target.x - player.x;
                    let dy = target.y - player.y;
                    let mag = Math.sqrt(dx*dx + dy*dy) || 1;
                    vx = (dx/mag) * BULLET_SPEED;
                    vy = (dy/mag) * BULLET_SPEED;
                } else {
                    // If no target, shoot in last known direction
                    if(lastDir === "up") { vx = 0; vy = -BULLET_SPEED; }
                    else if(lastDir === "down") { vx = 0; vy = BULLET_SPEED; }
                    else if(lastDir === "left") { vx = -BULLET_SPEED; vy = 0; }
                    else if(lastDir === "right") { vx = BULLET_SPEED; vy = 0; }
                    else { vx = 0; vy = -BULLET_SPEED; } // Default to up
                }
                bullets.push({ x: player.x, y: player.y, vx: vx, vy: vy, target: target });
                shootTimer = currentShootCooldown;
                soundShoot();
            }

            // Auto-special attack (area clear)
            if(specialTimer <= 0) {
                enemies = enemies.filter(en => {
                    if(collides(player, en, SPECIAL_ATTACK_RANGE)) {
                        let coinScore = 2;
                        if(doubleScoreActive) coinScore *= 2;
                        score += coinScore;
                        spawnScorePopup(en.x, en.y, `+${coinScore}`, "#00ff00"); // Score popup for enemy kill
                        spawnExplosion(en.x, en.y);
                        soundEnemyDeath();
                        return false; // Remove enemy
                    }
                    return true;
                });
                if(boss) {
                    if(collides(player, boss, SPECIAL_ATTACK_RANGE)) {
                        boss.h -= 2;
                        boss.hitTimer = ENEMY_HIT_FLASH_DURATION; // Boss flashes on hit
                        if(boss.h <= 0) {
                            let bossScore = 5;
                            if(doubleScoreActive) bossScore *= 2;
                            score += bossScore;
                            spawnScorePopup(boss.x, boss.y, `+${bossScore}`, "#00ff00"); // Score popup for boss kill
                            spawnExplosion(boss.x, boss.y);
                            boss = null;
                            soundEnemyDeath();
                        }
                    }
                }
                specialTimer = currentSpecialCooldown;
            }

            // Auto-dash (evade close enemies)
            if(dashTimer <= 0) {
                const dangerRadius = 20;
                let closeEnemies = enemies.filter(en => collides(player, en, dangerRadius));
                if(closeEnemies.length > 0) {
                    // Calculate average position of close enemies to dash away from them
                    let avgX = 0, avgY = 0;
                    closeEnemies.forEach(en => { avgX += en.x; avgY += en.y; });
                    avgX /= closeEnemies.length;
                    avgY /= closeEnemies.length;

                    let dx = player.x - avgX;
                    let dy = player.y - avgY;
                    let mag = Math.sqrt(dx*dx + dy*dy) || 1;
                    dx /= mag;
                    dy /= mag;

                    player.x += dx * currentDashDistance;
                    player.y += dy * currentDashDistance;
                    dashTimer = DASH_COOLDOWN;
                    soundDash();
                    spawnDashParticles(player.x, player.y, dx, dy); // Spawn dash particles
                }
            }

            // Auto-ultimate move
            if(energy >= MAX_ENERGY) {
                ultimateMove();
            }
        }

        // -------------------- BULLET UPDATE & COLLISION CHECKING --------------------
        /**
         * Updates the position and behavior of player bullets, handling homing and collisions.
         */
        function updateBullets() {
            for(let i = bullets.length - 1; i >= 0; i--){
                let b = bullets[i];

                // Homing logic for magic arrows
                if(b.target) {
                    let targetExists = enemies.some(en => en === b.target);
                    if(targetExists) {
                        let dx = b.target.x - b.x;
                        let dy = b.target.y - b.y;
                        let mag = Math.sqrt(dx*dx + dy*dy) || 1;
                        let desiredVx = (dx/mag) * BULLET_SPEED;
                        let desiredVy = (dy/mag) * BULLET_SPEED;
                        let homingFactor = 0.1; // Controls how quickly bullets adjust course
                        b.vx += (desiredVx - b.vx) * homingFactor;
                        b.vy += (desiredVy - b.vy) * homingFactor;
                    } else {
                        // If target is gone, stop homing
                        b.target = null;
                    }
                }

                b.x += b.vx;
                b.y += b.vy;

                // Remove bullets that go off-screen (relative to game viewport)
                if(b.x < -10 || b.x > GAME_VIEWPORT_WIDTH + 10 || b.y < -10 || b.y > GAME_VIEWPORT_HEIGHT + 10) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Optimized collision detection using spatial partitioning
                const cellSize = 50;
                let cellX = Math.floor(b.x / cellSize);
                let cellY = Math.floor(b.y / cellSize);
                let collisionDetected = false;
                let grid = buildEnemyGrid(enemies, cellSize); // Rebuild grid each frame (could be optimized)

                // Check current cell and neighboring cells for enemies
                for(let dx = -1; dx <= 1; dx++){
                    for(let dy = -1; dy <= 1; dy++){
                        let key = (cellX + dx) + "," + (cellY + dy);
                        let cellEnemies = grid[key];
                        if(cellEnemies){
                            for(let j = 0; j < cellEnemies.length; j++){
                                let enemy = cellEnemies[j];
                                if(collides(b, enemy, 8)){ // Bullet-enemy collision
                                    enemy.h -= currentBulletDamage;
                                    enemy.hitTimer = ENEMY_HIT_FLASH_DURATION; // Enemy flashes on hit
                                    if(enemy.h <= 0) {
                                        let coinScore = (comboCount > 1 ? comboCount : 1);
                                        if(doubleScoreActive) coinScore *= 2;
                                        score += coinScore;
                                        spawnScorePopup(enemy.x, enemy.y, `+${coinScore}`, "#00ff00"); // Score popup for enemy kill
                                        comboCount++;
                                        comboTimer = COMBO_RESET_TIME;
                                        spawnExplosion(enemy.x, en.y);
                                        soundEnemyDeath();
                                        let index = enemies.indexOf(enemy);
                                        if(index > -1) enemies.splice(index, 1);
                                    }
                                    bullets.splice(i, 1); // Remove bullet
                                    collisionDetected = true;
                                    break; // Stop checking enemies in this cell
                                }
                            }
                        }
                        if(collisionDetected) break; // Stop checking neighboring cells
                    }
                    if(collisionDetected) break; // Stop checking neighboring cells
                }

                // Check for collision with boss if no enemy collision detected
                if(!collisionDetected && bullets[i] && boss && collides(b, boss, 10)){
                    boss.h -= currentBulletDamage;
                    boss.hitTimer = ENEMY_HIT_FLASH_DURATION; // Boss flashes on hit
                    bullets.splice(i, 1); // Remove bullet
                    if(boss.h <= 0) {
                        let bossScore = 5;
                        if(doubleScoreActive) bossScore *= 2;
                        score += bossScore;
                        spawnScorePopup(boss.x, boss.y, `+${bossScore}`, "#00ff00"); // Score popup for boss kill
                        spawnExplosion(boss.x, boss.y);
                        boss = null;
                        soundEnemyDeath();
                    }
                }
            }
        }

        // -------------------- ENEMY BEHAVIOR LOGIC --------------------
        /**
         * Updates the position and behavior of a single enemy based on its type.
         * @param {object} en - The enemy object to update.
         */
        function updateEnemy(en) {
            if(en.type === "normal") {
                en.x += (player.x - en.x) * en.s;
                en.y += (player.y - en.y) * en.s;
            }
            else if(en.type === "fast") {
                // Fast enemies have a slightly erratic, circling movement
                let dx = player.x - en.x;
                let dy = player.y - en.y;
                en.x += dx * en.s * 0.5 + (-dy) * en.s * 0.5;
                en.y += dy * en.s * 0.5 + (dx) * en.s * 0.5;
            }
            else if(en.type === "tough") {
                // Tough enemies try to keep a distance but can rush if too close
                let dx = player.x - en.x;
                let dy = player.y - en.y;
                let dist = Math.hypot(dx, dy);
                if(dist < 80) { // If too close, try to back off quickly
                    en.x -= dx * en.s * 1.5;
                    en.y -= dy * en.s * 1.5;
                } else if(dist > 120) { // If too far, approach
                    en.x += dx * en.s * 0.5;
                    en.y += dy * en.s * 0.5;
                } else { // In optimal range, circle the player
                    en.x += (-dy) * en.s * 0.3;
                    en.y += (dx) * en.s * 0.3;
                }
            }
            else if(en.type === "rusher") {
                // Rushers charge when close, otherwise move somewhat randomly
                let dx = player.x - en.x;
                let dy = player.y - en.y;
                let dist = Math.hypot(dx, dy);
                if(dist < 100) {
                    en.x += dx * en.s * 2; // Rushing speed
                    en.y += dy * en.s * 2;
                } else {
                    en.x += dx * en.s + (Math.random()-0.5) * en.s; // General movement
                    en.y += dy * en.s + (Math.random()-0.5) * en.s;
                }
            }

            // Repel enemies from safe zone
            if(safeZone) {
                let dx = en.x - safeZone.x;
                let dy = en.y - safeZone.y;
                let d = Math.sqrt(dx*dx + dy*dy);
                if(d < safeZone.radius) {
                    let repelSpeed = 3;
                    en.x += (dx/d) * repelSpeed;
                    en.y += (dy/d) * repelSpeed;
                }
            }
            // Repel enemies from town
            if(en.x > town.x && en.x < town.x + town.width &&
               en.y > town.y && en.y < town.y + town.height) {
                let cx = town.x + town.width/2;
                let cy = town.y + town.height/2;
                let dx = en.x - cx;
                let dy = en.y - cy;
                let d = Math.sqrt(dx*dx + dy*dy) || 1;
                let repelSpeed = 4;
                en.x += (dx/d) * repelSpeed;
                en.y += (dy/d) * repelSpeed;
            }

            if (en.hitTimer > 0) en.hitTimer--; // Decrement hit flash timer
        }

        // -------------------- BOSS BEHAVIOR --------------------
        let bossTime = 0;
        /**
         * Updates the boss's position, behavior, and special attacks.
         */
        function updateBoss() {
            bossTime++;
            // Boss moves in a pattern around the player
            let offsetX = 50 * Math.cos(bossTime * 0.05); // Adjusted for smaller viewport
            let offsetY = 50 * Math.sin(bossTime * 0.05); // Adjusted for smaller viewport
            boss.x += ((player.x + offsetX) - boss.x) * boss.s;
            boss.y += ((player.y + offsetY) - boss.y) * boss.s;

            // Repel boss from safe zone
            if(safeZone) {
                let dx = boss.x - safeZone.x;
                let dy = boss.y - safeZone.y;
                let d = Math.sqrt(dx*dx + dy*dy);
                if(d < safeZone.radius) {
                    let repelSpeed = 3;
                    boss.x += (dx/d) * repelSpeed;
                    boss.y += (dy/d) * repelSpeed;
                }
            }
            // Repel boss from town
            if(boss.x > town.x && boss.x < town.x + town.width &&
               boss.y > town.y && boss.y < town.y + town.height) {
                let cx = town.x + town.width/2;
                let cy = town.y + town.height/2;
                let dx = boss.x - cx;
                let dy = boss.y - cy;
                let d = Math.sqrt(dx*dx + dy*dy) || 1;
                let repelSpeed = 4;
                boss.x += (dx/d) * repelSpeed;
                boss.y += (dy/d) * repelSpeed;
            }

            // Spawn minions when boss health is low
            if(boss && boss.h < boss.maxH * 0.5 && !boss.minionsSpawned) {
                spawnBossMinions();
                boss.minionsSpawned = true;
            }

            // Boss special homing attack timer
            bossSpecialTimer--;
            if(bossSpecialTimer <= 0) {
                let dx = player.x - boss.x, dy = player.y - boss.y;
                let mag = Math.sqrt(dx*dx + dy*dy) || 1;
                let bulletSpeed = 3;
                let vx = (dx/mag) * bulletSpeed;
                let vy = (dy/mag) * bulletSpeed;
                bossBullets.push({ x: boss.x, y: boss.y, vx: vx, vy: vy, isBossSpecial: true });
                bossSpecialTimer = 300; // Reset timer
            }

            if (boss.hitTimer > 0) boss.hitTimer--; // Decrement hit flash timer
        }

        // -------------------- BOSS MINION SPAWN --------------------
        /**
         * Spawns two normal enemy minions near the boss.
         */
        function spawnBossMinions() {
            for(let i = 0; i < 2; i++){
                let pos = spawnInGameArea(20, 40); // Adjusted for smaller viewport
                enemies.push({ x: pos.x, y: pos.y, s: baseSpeed, h: enemyTypes.normal.health, maxH: enemyTypes.normal.health, type: "normal", size: enemyTypes.normal.size, hitTimer: 0 });
            }
        }

        // -------------------- ENVIRONMENTAL HAZARD: DEBRIS --------------------
        /**
         * Updates the position of falling debris and checks for player collision.
         */
        function updateDebris() {
            for(let i = debris.length - 1; i >= 0; i--){
                let d = debris[i];
                d.y += d.speed; // Debris falls downwards

                // Remove debris that has fallen off-screen (relative to game viewport)
                if(d.y > GAME_VIEWPORT_HEIGHT + 20) {
                    debris.splice(i, 1);
                    continue;
                }

                // Check for collision with player
                if(collides(d, player, PLAYER_SIZE)) {
                    player.h--; // Player takes damage
                    player.hitTimer = PLAYER_HIT_FLASH_DURATION; // Player flashes on hit
                    debris.splice(i, 1); // Remove debris on hit
                    shakeTimer = 10; // Apply screen shake
                    soundPlayerHit();
                }
            }
        }

        /**
         * Draws all active debris on the canvas.
         */
        function drawDebris() {
            ctx.fillStyle = "#777"; // Grey color for debris
            debris.forEach(d => { ctx.fillRect(d.x, d.y, 6, 6); });
        }

        // -------------------- UPGRADE MENU --------------------
        const upgradeMenuButtonsDiv = document.getElementById('upgrade-menu-buttons');

        /**
         * Updates the text content of the upgrade buttons to show current values.
         */
        function updateUpgradeMenuButtons() {
            document.getElementById('upgrade-1').innerText = `1: +Move Speed (Current: ${currentMoveSpeed})`;
            document.getElementById('upgrade-2').innerText = `2: -Shoot CD (Current: ${(currentShootCooldown/60).toFixed(1)}s)`;
            document.getElementById('upgrade-3').innerText = `3: +Dash Dist (Current: ${currentDashDistance})`;
            document.getElementById('upgrade-4').innerText = `4: -Special CD (Current: ${(currentSpecialCooldown/60).toFixed(1)}s)`;
            document.getElementById('upgrade-5').innerText = `5: +Extra Life (Current: ${lives})`;
            document.getElementById('upgrade-6').innerText = `6: +Bullet DMG (Current: ${currentBulletDamage})`;
            document.getElementById('upgrade-7').innerText = `7: +Combo Bonus (Current Multiplier: x${comboCount > 1 ? comboCount : 1})`;
            document.getElementById('upgrade-8').innerText = `8: +Shield Dur (Current: ${(currentShieldDuration/60).toFixed(1)}s)`;
            document.getElementById('upgrade-9').innerText = `9: +Freeze Dur (Current: ${(currentFreezeDuration/60).toFixed(1)}s)`;
        }

        /**
         * Processes the chosen upgrade from the upgrade menu.
         * @param {string} choice - The key pressed by the user (1-9).
         */
        function processUpgrade(choice) {
            if(choice === "1") { currentMoveSpeed += 1; }
            else if(choice === "2") { currentShootCooldown = Math.max(5, currentShootCooldown - 5); }
            else if(choice === "3") { currentDashDistance += 10; }
            else if(choice === "4") { currentSpecialCooldown = Math.max(10, currentSpecialCooldown - 5); }
            else if(choice === "5") { lives++; }
            else if(choice === "6") { currentBulletDamage++; }
            else if(choice === "7") { comboCount += 1; } // This seems unusual, usually combo bonus is a multiplier, not a direct count increase. Keeping as per original.
            else if(choice === "8") { currentShieldDuration += 50; }
            else if(choice === "9") { currentFreezeDuration += 30; }
            upgradeMenuActive = false;
            levelTransitionTimer = 60; // Short delay after upgrade
            soundLevelUp();
            upgradeMenuButtonsDiv.style.display = 'none'; // Hide buttons after selection
        }

        // -------------------- INPUT HANDLERS --------------------
        document.onkeydown = e => {
            if(upgradeMenuActive) {
                if(["1","2","3","4","5","6","7","8","9"].includes(e.key)) {
                    processUpgrade(e.key);
                    return;
                }
                return; // Ignore other keys while upgrade menu is active
            }

            if(gameState === "start" && e.key === "Enter") {
                gameState = "playing";
                return;
            }
            if(gameState === "gameover" && e.key === "r") {
                initGame(); // Restart game
                return;
            }

            if(gameState === "playing") {
                if(e.key === "p") { gameState = "paused"; return; }
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = true;
                    if (e.key === "ArrowUp") lastDir = "up";
                    else if (e.key === "ArrowDown") lastDir = "down";
                    else if (e.key === "ArrowLeft") lastDir = "left";
                    else if (e.key === "ArrowRight") lastDir = "right";
                }
            } else if(gameState === "paused") {
                if(e.key === "p") { gameState = "playing"; } // Resume game
            }
        };

        document.onkeyup = e => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        };

        // Button event listeners for touch/click controls
        document.getElementById("up").addEventListener("mousedown", () => { keys.ArrowUp = true; lastDir = "up"; });
        document.getElementById("up").addEventListener("mouseup", () => { keys.ArrowUp = false; });
        document.getElementById("up").addEventListener("touchstart", (e) => { e.preventDefault(); keys.ArrowUp = true; lastDir = "up"; });
        document.getElementById("up").addEventListener("touchend", () => { keys.ArrowUp = false; });

        document.getElementById("down").addEventListener("mousedown", () => { keys.ArrowDown = true; lastDir = "down"; });
        document.getElementById("down").addEventListener("mouseup", () => { keys.ArrowDown = false; });
        document.getElementById("down").addEventListener("touchstart", (e) => { e.preventDefault(); keys.ArrowDown = true; lastDir = "down"; });
        document.getElementById("down").addEventListener("touchend", () => { keys.ArrowDown = false; });

        document.getElementById("left").addEventListener("mousedown", () => { keys.ArrowLeft = true; lastDir = "left"; });
        document.getElementById("left").addEventListener("mouseup", () => { keys.ArrowLeft = false; });
        document.getElementById("left").addEventListener("touchstart", (e) => { e.preventDefault(); keys.ArrowLeft = true; lastDir = "left"; });
        document.getElementById("left").addEventListener("touchend", () => { keys.ArrowLeft = false; });

        document.getElementById("right").addEventListener("mousedown", () => { keys.ArrowRight = true; lastDir = "right"; });
        document.getElementById("right").addEventListener("mouseup", () => { keys.ArrowRight = false; });
        document.getElementById("right").addEventListener("touchstart", (e) => { e.preventDefault(); keys.ArrowRight = true; lastDir = "right"; });
        document.getElementById("right").addEventListener("touchend", () => { keys.ArrowRight = false; });

        document.getElementById("pause").addEventListener("click", () => {
            if(upgradeMenuActive) return;
            gameState = (gameState === "paused") ? "playing" : "paused";
        });

        // Add event listeners for upgrade menu buttons
        upgradeMenuButtonsDiv.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', () => {
                const upgradeChoice = button.dataset.upgrade;
                if (upgradeMenuActive) {
                    processUpgrade(upgradeChoice);
                }
            });
        });

        // -------------------- TOUCH INPUT HANDLERS (for canvas swipe) --------------------
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling/zooming
            if (gameState === "playing" && !upgradeMenuActive) {
                isTouching = true;
                // Get touch coordinates relative to the canvas
                const rect = canvas.getBoundingClientRect();
                touchStartX = e.touches[0].clientX - rect.left;
                touchStartY = e.touches[0].clientY - rect.top;
                touchMoveX = touchStartX; // Initialize current touch position
                touchMoveY = touchStartY;
            } else if (gameState === "start") {
                gameState = "playing";
            } else if (gameState === "gameover") {
                initGame();
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling/zooming
            if (isTouching && gameState === "playing" && !upgradeMenuActive) {
                const rect = canvas.getBoundingClientRect();
                touchMoveX = e.touches[0].clientX - rect.left;
                touchMoveY = e.touches[0].clientY - rect.top;
            }
        });

        canvas.addEventListener('touchend', () => {
            isTouching = false;
            // When touch ends, release all movement keys to stop player
            keys.ArrowUp = false;
            keys.ArrowDown = false;
            keys.ArrowLeft = false;
            keys.ArrowRight = false;
            touchStartX = 0;
            touchStartY = 0;
            touchMoveX = 0;
            touchMoveY = 0;
        });

        /**
         * Applies player movement based on touch input.
         * This function now sets the 'keys' state, which is then processed by the main loop's velocity system.
         */
        function applyTouchMovement() {
            // Reset keys based on touch input, only if currently touching
            keys.ArrowUp = false;
            keys.ArrowDown = false;
            keys.ArrowLeft = false;
            keys.ArrowRight = false;

            if (isTouching && gameState === "playing" && !upgradeMenuActive) {
                // Scale touch movement to the internal game viewport coordinates
                const scaledTouchStartX = (touchStartX - GAME_VIEWPORT_X_OFFSET) * (GAME_VIEWPORT_WIDTH / canvas.clientWidth);
                const scaledTouchStartY = (touchStartY - GAME_VIEWPORT_Y_OFFSET) * (GAME_VIEWPORT_HEIGHT / canvas.clientHeight);
                const scaledTouchMoveX = (touchMoveX - GAME_VIEWPORT_X_OFFSET) * (GAME_VIEWPORT_WIDTH / canvas.clientWidth);
                const scaledTouchMoveY = (touchMoveY - GAME_VIEWPORT_Y_OFFSET) * (GAME_VIEWPORT_HEIGHT / canvas.clientHeight);

                let dx = scaledTouchMoveX - scaledTouchStartX;
                let dy = scaledTouchMoveY - scaledTouchStartY;

                if (Math.abs(dx) > SWIPE_THRESHOLD || Math.abs(dy) > SWIPE_THRESHOLD) {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 0) { keys.ArrowRight = true; lastDir = "right"; }
                        else { keys.ArrowLeft = true; lastDir = "left"; }
                    } else {
                        if (dy > 0) { keys.ArrowDown = true; lastDir = "down"; }
                        else { keys.ArrowUp = true; lastDir = "up"; }
                    }
                    // For continuous touch movement, update start position to current touch position
                    // This makes the player continue moving as long as finger is moving
                    touchStartX = touchMoveX;
                    touchStartY = touchMoveY;
                }
            }
        }


        // -------------------- SOUND TOGGLE BUTTON HANDLER --------------------
        document.getElementById("soundToggle").addEventListener("click", () => {
            soundEnabled = !soundEnabled;
            document.getElementById("soundToggle").innerText = soundEnabled ? "Sound: On" : "Sound: Off";
        });

        // -------------------- PARTICLE EXPLOSIONS --------------------
        /**
         * Spawns a burst of particles at a given location.
         * @param {number} x - X coordinate for the explosion (relative to viewport).
         * @param {number} y - Y coordinate for the explosion (relative to viewport).
         */
        function spawnExplosion(x, y) {
            for(let i = 0; i < PARTICLE_COUNT; i++){
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random()-0.5)*4, // Increased particle speed
                    dy: (Math.random()-0.5)*4,
                    life: PARTICLE_MAX_LIFE + Math.random()*20,
                    color: `hsl(${Math.random() * 360}, 100%, 70%)` // Random bright colors
                });
            }
        }

        /**
         * Updates the position and lifespan of particles.
         */
        function updateParticles() {
            for(let i = particles.length - 1; i >= 0; i--){
                let p = particles[i];
                p.x += p.dx;
                p.y += p.dy;
                p.life--;
                if(p.life <= 0) particles.splice(i,1); // Remove dead particles
            }
        }

        /**
         * Draws all active particles on the canvas.
         */
        function drawParticles() {
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / PARTICLE_MAX_LIFE; // Fade out particles
                ctx.fillRect(p.x, p.y, 3, 3); // Draw relative to viewport
            });
            ctx.globalAlpha = 1; // Reset alpha
        }

        // -------------------- DASH PARTICLES --------------------
        /**
         * Spawns particles to create a dash trail effect.
         * @param {number} x - X coordinate of the player (relative to viewport).
         * @param {number} y - Y coordinate of the player (relative to viewport).
         * @param {number} dx - Player's dash direction X.
         * @param {number} dy - Player's dash direction Y.
         */
        function spawnDashParticles(x, y, dx, dy) {
            for (let i = 0; i < 5; i++) {
                dashParticles.push({
                    x: x - dx * (i * 2), // Spawn slightly behind dash direction
                    y: y - dy * (i * 2),
                    life: 20, // Short lifespan
                    size: PLAYER_SIZE * (1 - i * 0.1), // Fade out size
                    color: `rgba(0, 255, 0, ${0.5 - i * 0.1})` // Green fading trail
                });
            }
        }

        /**
         * Updates and draws dash particles.
         */
        function updateAndDrawDashParticles() {
            for (let i = dashParticles.length - 1; i >= 0; i--) {
                let p = dashParticles[i];
                p.life--;
                p.size *= 0.9; // Shrink
                if (p.life <= 0 || p.size < 0.5) {
                    dashParticles.splice(i, 1);
                } else {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2); // Draw relative to viewport
                    ctx.fill();
                }
            }
        }

        // -------------------- SCORE POP-UPS --------------------
        /**
         * Spawns a floating score text at a given location (relative to viewport).
         * @param {number} x - X coordinate for the popup.
         * @param {number} y - Y coordinate for the popup.
         * @param {string} text - The text to display (e.g., "+10").
         * @param {string} color - Color of the text.
         */
        function spawnScorePopup(x, y, text, color = "#fff") {
            scorePopups.push({
                x: x,
                y: y,
                text: text,
                color: color,
                life: 60, // frames
                vy: -0.5 // float upwards
            });
        }

        /**
         * Updates the position and lifespan of score pop-ups.
         */
        function updateScorePopups() {
            for (let i = scorePopups.length - 1; i >= 0; i--) {
                let popup = scorePopups[i];
                popup.y += popup.vy;
                popup.life--;
                if (popup.life <= 0) {
                    scorePopups.splice(i, 1);
                }
            }
        }

        /**
         * Draws all active score pop-ups (relative to viewport).
         */
        function drawScorePopups() {
            scorePopups.forEach(popup => {
                ctx.globalAlpha = popup.life / 60; // Fade out
                ctx.fillStyle = popup.color;
                ctx.font = "bold 14px Arial";
                ctx.fillText(popup.text, popup.x, popup.y); // Draw relative to viewport
                ctx.globalAlpha = 1; // Reset alpha
            });
        }

        // -------------------- INDICATOR OVERLAY FUNCTIONS --------------------
        /**
         * Checks if a target object is currently visible within the game viewport.
         * @param {object} target - The object to check (with x, y coordinates relative to viewport).
         * @returns {boolean} True if the object is on screen, false otherwise.
         */
        function isOnScreen(target) {
            // Check if target is within the game viewport boundaries
            return (target.x >= 0 && target.x <= GAME_VIEWPORT_WIDTH && target.y >= 0 && target.y <= GAME_VIEWPORT_HEIGHT);
        }

        /**
         * Draws an off-screen indicator pointing towards a target object.
         * @param {object} target - The object to point to (with x, y coordinates relative to viewport).
         * @param {string} color - Color of the indicator.
         * @param {string} label - Text label for the indicator.
         */
        function drawIndicator(target, color, label) {
            if (isOnScreen(target)) return; // Don't draw indicator if target is on screen

            // Calculate direction from center of game viewport to target
            let centerX = GAME_VIEWPORT_WIDTH / 2;
            let centerY = GAME_VIEWPORT_HEIGHT / 2;
            let dx = target.x - centerX;
            let dy = target.y - centerY;
            let angle = Math.atan2(dy, dx); // Angle from viewport center to target

            // Calculate intersection point with game viewport boundary
            let margin = 10; // Margin from viewport edge for indicators
            let halfWidth = GAME_VIEWPORT_WIDTH / 2 - margin;
            let halfHeight = GAME_VIEWPORT_HEIGHT / 2 - margin;

            let scale = Math.min(
                halfWidth / Math.abs(Math.cos(angle)),
                halfHeight / Math.abs(Math.sin(angle))
            );

            let arrowX = centerX + Math.cos(angle) * scale;
            let arrowY = centerY + Math.sin(angle) * scale;

            ctx.save(); // Save context before applying viewport offset
            // Translate to viewport position for drawing indicators
            ctx.translate(GAME_VIEWPORT_X_OFFSET, GAME_VIEWPORT_Y_OFFSET);

            ctx.fillStyle = color;
            ctx.beginPath();
            let arrowSize = 10;
            let tipX = arrowX, tipY = arrowY;
            let perpAngle = angle + Math.PI/2; // Perpendicular angle for arrow base

            // Calculate base points of the arrow triangle
            let baseX1 = arrowX - Math.cos(angle)*arrowSize + Math.cos(perpAngle)*(arrowSize/2);
            let baseY1 = arrowY - Math.sin(angle)*arrowSize + Math.sin(perpAngle)*(arrowSize/2);
            let baseX2 = arrowX - Math.cos(angle)*arrowSize - Math.cos(perpAngle)*(arrowSize/2);
            let baseY2 = arrowY - Math.sin(angle)*arrowSize - Math.sin(perpAngle)*(arrowSize/2);

            ctx.moveTo(tipX, tipY);
            ctx.lineTo(baseX1, baseY1);
            ctx.lineTo(baseX2, baseY2);
            ctx.closePath();
            ctx.fill();

            ctx.font = "10px sans-serif";
            ctx.fillText(label, arrowX - ctx.measureText(label).width/2, arrowY - arrowSize - 2); // Label above arrow
            ctx.restore(); // Restore context
        }


        // -------------------- MAIN GAME LOOP --------------------
        /**
         * The main game loop, responsible for updating game state and drawing.
         */
        function loop() {
            // Update timers regardless of game state (except upgrade menu)
            if(!upgradeMenuActive) {
                if(specialTimer > 0) specialTimer--;
                if(shootTimer > 0) shootTimer--;
                if(dashTimer > 0) dashTimer--;
                if(levelTransitionTimer > 0) levelTransitionTimer--;
                if(comboTimer > 0) comboTimer--; else { comboCount = 0; } // Reset combo if timer runs out
                if(invincible) {
                    invTimer--;
                    if(invTimer <= 0) invincible = false;
                }
                if(speedBoostTimer > 0) { speedBoostTimer--; } else { playerSpeedBoost = 1; } // Reset speed boost
                if(shieldTimer > 0) { shieldTimer--; } else { shieldActive = false; } // Deactivate shield
                if(freezeTimer > 0) freezeTimer--;
                if(player.hitTimer > 0) player.hitTimer--; // Decrement player hit flash timer
            }

            // Update day/night cycle and set background color
            let bgColor = updateDayNightCycle();
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // Fill entire canvas with background

            // Draw scrolling background stars (relative to full canvas)
            drawScrollingBackground();

            // Update energy and double score timer
            updateEnergy();
            if(doubleScoreActive) {
                doubleScoreTimer--;
                if(doubleScoreTimer <= 0) { doubleScoreActive = false; }
            }

            // -------------------- SAFE ZONE SPAWN & UPDATE --------------------
            // Spawn new safe zone if none exists and chance allows
            if(safeZone === null && Math.random() < SAFEZONE_CHANCE) {
                let pos = spawnInGameArea(SPAWN_NEAR_MIN, SPAWN_NEAR_MAX);
                safeZone = {
                    x: pos.x,
                    y: pos.y,
                    radius: SAFEZONE_RADIUS,
                    duration: SAFEZONE_DURATION
                };
            }
            // Update safe zone duration
            if(safeZone) {
                safeZone.duration--;
                if(safeZone.duration <= 0) safeZone = null; // Remove safe zone when duration ends
            }
            // Check if player is currently in a safe zone
            playerSafe = (safeZone && collides(player, safeZone, safeZone.radius));

            // -------------------- DEBRIS SPAWN & UPDATE --------------------
            if(Math.random() < DEBRIS_SPAWN_CHANCE) { spawnDebris(); }
            updateDebris();

            // Spawn powerup if less than 1 exists and chance allows
            if(Math.random() < 0.001 && powerups.length < 1) { spawnPowerup(); }

            // Update bullets, particles, score popups (only if not in upgrade menu)
            if(!upgradeMenuActive) {
                updateBullets();
                updateBossBullets();
                updateParticles();
                updateScorePopups(); // Update score popups
            }


            // -------------------- GAME LOGIC (ONLY IN PLAYING STATE) --------------------
            if(gameState === "playing" && !upgradeMenuActive) {
                autoPowers(); // Run automated player abilities
                applyTouchMovement(); // Apply touch-based movement

                // Player movement logic (velocity-based for smoother movement)
                let targetVx = 0;
                let targetVy = 0;
                let currentSpeed = currentMoveSpeed * playerSpeedBoost;

                if (keys.ArrowUp) targetVy = -currentSpeed;
                if (keys.ArrowDown) targetVy = currentSpeed;
                if (keys.ArrowLeft) targetVx = -currentSpeed;
                if (keys.ArrowRight) targetVx = currentSpeed;

                // Normalize diagonal movement speed
                if (targetVx !== 0 && targetVy !== 0) {
                    let diagonalFactor = Math.sqrt(2);
                    targetVx /= diagonalFactor;
                    targetVy /= diagonalFactor;
                }

                const acceleration = 0.2; // How quickly player reaches target speed
                const friction = 0.8; // How quickly player slows down when no input

                player.vx += (targetVx - player.vx) * acceleration;
                player.vy += (targetVy - player.vy) * acceleration;

                // Apply friction if no input in that direction
                if (targetVx === 0) player.vx *= friction;
                if (targetVy === 0) player.vy *= friction;

                player.x += player.vx;
                player.y += player.vy;

                // Clamp player position to the game viewport
                player.x = Math.max(PLAYER_SIZE / 2, Math.min(GAME_VIEWPORT_WIDTH - PLAYER_SIZE / 2, player.x));
                player.y = Math.max(PLAYER_SIZE / 2, Math.min(GAME_VIEWPORT_HEIGHT - PLAYER_SIZE / 2, player.y));


                // Update enemy and boss positions (if not frozen)
                if(freezeTimer <= 0) {
                    enemies.forEach(updateEnemy);
                    if(boss) { updateBoss(); }
                }

                // Player-enemy collision
                enemies.forEach(en => {
                    if(collides(player, en, PLAYER_SIZE/2 + en.size/2) && !invincible && !playerSafe) {
                        if(shieldActive) { shieldActive = false; shieldTimer = 0; }
                        else { player.h--; player.hitTimer = PLAYER_HIT_FLASH_DURATION; } // Player takes damage & flashes
                        // Only respawn enemies if player takes damage and is not dead
                        if (player.h > 0) {
                            spawnEnemies(); // Respawn enemies on hit
                            spawnBoss(); // Respawn boss on hit (if applicable)
                        }
                        shakeTimer = 10;
                        soundPlayerHit();
                    }
                });
                // Player-boss collision
                if(boss && collides(player, boss, PLAYER_SIZE/2 + boss.size/2) && !invincible && !playerSafe) {
                    if(shieldActive) { shieldActive = false; shieldTimer = 0; }
                    else { player.h--; player.hitTimer = PLAYER_HIT_FLASH_DURATION; } // Player takes damage & flashes
                    if (player.h > 0) {
                        spawnEnemies(); // Respawn enemies on hit
                        spawnBoss(); // Respawn boss on hit (if applicable)
                    }
                    shakeTimer = 10;
                    soundPlayerHit();
                }
                // Player-obstacle collision
                obstacles.forEach(ob => {
                    if(collides(player, ob, PLAYER_SIZE/2 + ob.size/2) && !invincible && !playerSafe) {
                        if(shieldActive) { shieldActive = false; shieldTimer = 0; }
                        else { player.h--; player.hitTimer = PLAYER_HIT_FLASH_DURATION; } // Player takes damage & flashes
                        shakeTimer = 10;
                        soundPlayerHit();
                    }
                });

                // Player-powerup collision
                powerups.forEach((pw, i) => {
                    if(collides(player, pw, 10)) {
                        if(pw.type === "inv") { invincible = true; invTimer = INVINCIBILITY_DURATION; }
                        else if(pw.type === "speed") { playerSpeedBoost = 2; speedBoostTimer = SPEED_BOOST_DURATION; }
                        else if(pw.type === "shield") { shieldActive = true; shieldTimer = currentShieldDuration; }
                        else if(pw.type === "freeze") { freezeTimer = currentFreezeDuration; }
                        else if(pw.type === "double") { doubleScoreActive = true; doubleScoreTimer = 600; }
                        else if(pw.type === "health") { player.h = Math.min(player.maxH, player.h + 3); spawnScorePopup(player.x, player.y, `+3 HP`, "#00ff00"); } // Restore 3 health
                        else if(pw.type === "bomb") {
                            enemies.forEach(en => { spawnExplosion(en.x, en.y); });
                            if(boss) { spawnExplosion(boss.x, boss.y); }
                            let bombScore = enemies.length + (boss ? 1 : 0);
                            score += bombScore * 2; // Bonus score for bomb clear
                            spawnScorePopup(player.x, player.y, `+${bombScore * 2} (Bomb!)`, "#ff00ff"); // Score popup for bomb
                            enemies = [];
                            boss = null;
                            soundBombExplode();
                        }
                        powerups.splice(i, 1); // Remove powerup after collection
                        soundPowerupCollect(); // Play powerup sound
                    }
                });

                // Player-coin collision
                if(collides(player, coin)) {
                    let coinScore = (comboCount > 1 ? comboCount : 1);
                    if(doubleScoreActive) { coinScore *= 2; }
                    score += coinScore;
                    energy = Math.min(MAX_ENERGY, energy + 10); // Gain energy from coins
                    spawnScorePopup(coin.x, coin.y, `+${coinScore}`, "#ffff00"); // Score popup for coin
                    spawnCoin(); // Spawn new coin
                    soundCoinCollect(); // Play coin sound
                    if(score % 5 === 0) { // Level up every 5 score points
                        level++;
                        baseSpeed += 0.005; // Increase enemy speed
                        spawnEnemies();
                        spawnBoss();
                        spawnObstacles();
                        upgradeMenuActive = true; // Activate upgrade menu
                        upgradeMenuTimer = 0; // Reset timer for upgrade menu display duration
                        soundLevelUp();
                        updateUpgradeMenuButtons(); // Update button text with current values
                        upgradeMenuButtonsDiv.style.display = 'flex'; // Show upgrade buttons
                    }
                    levelTransitionTimer = 60; // Brief "Level Up!" display
                }
            }

            // Check for game over
            if(player.h <= 0) { // Game over if player health drops to 0
                gameState = "gameover";
                if(score > highScore) {
                    highScore = score;
                    localStorage.setItem("highScore", highScore); // Save high score
                }
            }

            // -------------------- DRAWING --------------------
            ctx.save(); // Save the current canvas state

            // Translate to the game viewport position
            ctx.translate(GAME_VIEWPORT_X_OFFSET, GAME_VIEWPORT_Y_OFFSET);
            applyShake(); // Apply screen shake relative to the viewport

            // Draw the game area border
            ctx.strokeStyle = "#63b3ed"; // Blue border
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, GAME_VIEWPORT_WIDTH, GAME_VIEWPORT_HEIGHT);


            // Draw Safe Zone
            if(safeZone) {
                ctx.fillStyle = "rgba(0,255,0,0.2)";
                ctx.beginPath();
                ctx.arc(safeZone.x, safeZone.y, safeZone.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = "rgba(0,255,0,0.8)";
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.font = "14px sans-serif";
                ctx.fillStyle = "rgba(0,255,0,0.9)";
                ctx.fillText("Safe Zone", safeZone.x - ctx.measureText("Safe Zone").width/2, safeZone.y);
            }

            // Draw Town
            ctx.fillStyle = "#444";
            ctx.fillRect(town.x, town.y, town.width, town.height);
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.strokeRect(town.x, town.y, town.width, town.height);
            ctx.font = "14px sans-serif";
            ctx.fillStyle = "#fff";
            ctx.fillText("Town", town.x + 10, town.y + town.height/2);

            // Draw Coin
            ctx.fillStyle = "#ff0";
            ctx.beginPath();
            ctx.arc(coin.x, coin.y, COIN_SIZE/2, 0, Math.PI * 2);
            ctx.fill();

            // Draw Obstacles
            ctx.fillStyle = "#888";
            obstacles.forEach(ob => {
                ctx.beginPath();
                ctx.arc(ob.x, ob.y, ob.size/2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw Enemies
            enemies.forEach(en => {
                ctx.fillStyle = (en.hitTimer > 0 && Math.floor(en.hitTimer / 2) % 2 === 0) ? enemyTypes[en.type].hitColor : enemyTypes[en.type].color; // Flash effect
                ctx.beginPath();
                ctx.arc(en.x, en.y, en.size/2, 0, Math.PI * 2);
                ctx.fill();
                // Draw enemy health bar
                drawHealthBar(en.x - 10, en.y - en.size/2 - 5, 20, 3, en.h, en.maxH, "#f00");
            });

            // Draw Boss
            if(boss) {
                ctx.fillStyle = (boss.hitTimer > 0 && Math.floor(boss.hitTimer / 2) % 2 === 0) ? "#fff" : "#f0f"; // Boss flashes white
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, boss.size/2, 0, Math.PI * 2);
                ctx.fill();
                // Draw boss health bar
                drawHealthBar(boss.x - 20, boss.y - boss.size/2 - 10, 40, 5, boss.h, boss.maxH, "#f0f");
            }

            // Draw Powerups
            powerups.forEach(pw => {
                ctx.fillStyle = "#00f"; // Default blue
                let label = "";
                if (pw.type === "inv") { ctx.fillStyle = "#0ff"; label = "I"; } // Cyan
                else if (pw.type === "speed") { ctx.fillStyle = "#f00"; label = "S"; } // Red
                else if (pw.type === "shield") { ctx.fillStyle = "#ff0"; label = "D"; } // Yellow
                else if (pw.type === "freeze") { ctx.fillStyle = "#00ffff"; label = "F"; } // Aqua
                else if (pw.type === "double") { ctx.fillStyle = "#ff8c00"; label = "2X"; } // Dark Orange
                else if (pw.type === "health") { ctx.fillStyle = "#0f0"; label = "H"; } // Green for health pack
                else if (pw.type === "bomb") { ctx.fillStyle = "#800080"; label = "B"; } // Purple for bomb
                ctx.beginPath();
                ctx.arc(pw.x, pw.y, 8, 0, Math.PI * 2);
                ctx.fill();
                // Add a small icon/text for powerups
                ctx.fillStyle = "#fff";
                ctx.font = "bold 10px Arial";
                ctx.fillText(label, pw.x - ctx.measureText(label).width/2, pw.y + 4);
            });

            // Draw Player Bullets
            ctx.fillStyle = "#fff"; // White for player bullets
            bullets.forEach(b => { ctx.fillRect(b.x, b.y, BULLET_SIZE, BULLET_SIZE); });

            // Draw Boss Bullets
            ctx.fillStyle = "#ff8800"; // Orange for boss bullets
            bossBullets.forEach(b => { ctx.fillRect(b.x, b.y, 4, 4); });

            // Draw falling debris
            drawDebris();

            // Draw Player
            ctx.fillStyle = (player.hitTimer > 0 && Math.floor(player.hitTimer / 2) % 2 === 0) ? "#f00" : (invincible ? "#0ff" : "#0f0"); // Red if hit (flashing), Cyan if invincible, green otherwise
            ctx.beginPath();
            ctx.arc(player.x, player.y, PLAYER_SIZE/2, 0, Math.PI * 2);
            ctx.fill();
            // Draw shield effect
            if(shieldActive) {
                ctx.strokeStyle = "#ff0"; // Yellow shield outline
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x, player.y, PLAYER_SIZE/2 + 4, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw Particles (explosions)
            drawParticles();
            // Draw Dash Particles
            updateAndDrawDashParticles();

            ctx.restore(); // Restore canvas state (undoes translation/shake)

            // -------------------- DRAW HUD (Heads-Up Display) --------------------
            // HUD elements are drawn directly on the main 600x600 canvas, outside the game viewport translation
            ctx.fillStyle = "#fff"; // White text for HUD
            ctx.font = "12px sans-serif";
            ctx.fillText("Score: " + score, 5, 12);
            ctx.fillText("Lives: " + lives, 5, 24);
            ctx.fillText("Level: " + level, 5, 36);

            // Player Health Bar
            ctx.fillText("Health:", 5, 50);
            // Health bar drawn directly on canvas, not relative to game viewport
            drawHealthBar(50, 42, 100, 10, player.h, player.maxH, "#0f0");

            ctx.fillText("Shoot CD: " + (shootTimer/60).toFixed(1), 5, 68); // Display in seconds
            ctx.fillText("Special CD: " + (specialTimer/60).toFixed(1), 5, 80);
            ctx.fillText("Dash CD: " + (dashTimer/60).toFixed(1), 5, 92);
            ctx.fillText("High Score: " + highScore, 5, 104); // Display high score

            let hudYOffset = 116; // Starting Y for power-up/status indicators
            if(invincible) { ctx.fillText("Invincible: " + (invTimer/60).toFixed(1) + "s", 5, hudYOffset); hudYOffset += 12; }
            if(speedBoostTimer > 0) { ctx.fillText("Speed: x" + playerSpeedBoost + " (" + (speedBoostTimer/60).toFixed(1) + "s)", 5, hudYOffset); hudYOffset += 12; }
            if(shieldActive) { ctx.fillText("Shield: " + (shieldTimer/60).toFixed(1) + "s", 5, hudYOffset); hudYOffset += 12; }
            if(freezeTimer > 0) { ctx.fillText("Freeze: " + (freezeTimer/60).toFixed(1) + "s", 5, hudYOffset); hudYOffset += 12; }
            if(doubleScoreActive) { ctx.fillText("Double Score: " + (doubleScoreTimer/60).toFixed(1) + "s", 5, hudYOffset); hudYOffset += 12; }
            if(comboCount > 1) { ctx.fillText("Combo: x" + comboCount, 5, hudYOffset); hudYOffset += 12; }

            // Energy bar
            ctx.fillStyle = "#0f0"; // Green for energy bar
            ctx.fillRect(5, hudYOffset + 5, (energy/MAX_ENERGY)*100, 8);
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(5, hudYOffset + 5, 100, 8);
            ctx.fillText("Energy", 110, hudYOffset + 13);

            // Game state messages
            if(levelTransitionTimer > 0 && !upgradeMenuActive) { // Only show if upgrade menu is not active
                ctx.font = "20px sans-serif";
                ctx.fillText("Level Up!", CANVAS_WIDTH/2 - ctx.measureText("Level Up!").width/2, CANVAS_HEIGHT/2 - 50);
            }

            if(gameState === "paused") {
                ctx.font = "24px sans-serif";
                ctx.fillStyle = "#fff";
                ctx.fillText("PAUSED", CANVAS_WIDTH/2 - ctx.measureText("PAUSED").width/2, CANVAS_HEIGHT/2);
                ctx.font = "16px sans-serif";
                ctx.fillText("Press 'P' or Pause button to Resume", CANVAS_WIDTH/2 - ctx.measureText("Press 'P' or Pause button to Resume").width/2, CANVAS_HEIGHT/2 + 30);
            }
            // Upgrade menu text is now handled by HTML overlay
            if(upgradeMenuActive) {
                upgradeMenuButtonsDiv.style.display = 'flex'; // Ensure buttons are visible if menu is active
            } else {
                upgradeMenuButtonsDiv.style.display = 'none'; // Hide buttons if menu is not active
            }


            if(gameState === "gameover") {
                ctx.font = "30px sans-serif";
                ctx.fillStyle = "#f00";
                ctx.fillText("GAME OVER", CANVAS_WIDTH/2 - ctx.measureText("GAME OVER").width/2, CANVAS_HEIGHT/2 - 20);
                ctx.font = "18px sans-serif";
                ctx.fillStyle = "#fff";
                ctx.fillText("Score: " + score, CANVAS_WIDTH/2 - ctx.measureText("Score: " + score).width/2, CANVAS_HEIGHT/2 + 20);
                ctx.fillText("High Score: " + highScore, CANVAS_WIDTH/2 - ctx.measureText("High Score: " + highScore).width/2, CANVAS_HEIGHT/2 + 40);
                ctx.fillText("Press 'R' or Tap to Restart", CANVAS_WIDTH/2 - ctx.measureText("Press 'R' or Tap to Restart").width/2, CANVAS_HEIGHT/2 + 70);
            }
            if(gameState === "start") {
                ctx.font = "24px sans-serif";
                ctx.fillStyle = "#fff";
                ctx.fillText("Press 'Enter' or Tap to Start", CANVAS_WIDTH/2 - ctx.measureText("Press 'Enter' or Tap to Start").width/2, CANVAS_HEIGHT/2);
                ctx.font = "16px sans-serif";
                ctx.fillText("Move with Arrow keys, Buttons, or Swipe on Canvas", CANVAS_WIDTH/2 - ctx.measureText("Move with Arrow keys, Buttons, or Swipe on Canvas").width/2, CANVAS_HEIGHT/2 + 30);
                ctx.fillText("Collect coins, defeat enemies, survive!", CANVAS_WIDTH/2 - ctx.measureText("Collect coins, defeat enemies, survive!").width/2, CANVAS_HEIGHT/2 + 50);
            }

            // -------------------- DRAW MINIMAP --------------------
            drawMinimap();

            // Draw indicators for off-screen coin and boss
            drawIndicator(coin, "#ff0", "Coin");
            if (boss) {
                drawIndicator(boss, "#f0f", "Boss");
            }

            // Draw Score Popups
            drawScorePopups();


            requestAnimationFrame(loop); // Request the next frame
        }

        // Start the game loop when the window loads
        window.onload = function() {
            loop();
        };

        // Handle window resizing to make canvas responsive
        window.addEventListener('resize', () => {
            // This example keeps the canvas fixed size, but adjusts its display via CSS.
            // For a truly dynamic canvas, you would update canvas.width and canvas.height here
            // and then re-render all elements proportionally.
        });
    </script>
</body>
</html>
