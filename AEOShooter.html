<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Enhanced Game: Infinite Map</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom styles for the game, overriding some Tailwind defaults for specific elements */
        body {
            margin: 0;
            height: 100vh; /* Full viewport height */
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            font-family: "Inter", sans-serif; /* Preferred font */
            display: flex;
            flex-direction: column; /* Stack children vertically */
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
            overflow: hidden; /* Prevent scrolling on the body */
            padding: 0.5rem; /* Small padding around the entire game container */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .game-container {
            display: flex;
            flex-direction: column; /* Stack children vertically */
            align-items: center; /* Center content horizontally */
            flex-grow: 1; /* Allow container to take up available vertical space */
            justify-content: space-between; /* Distribute space between title, canvas, controls */
            width: 100%; /* Take full width */
            height: 100%; /* Take full height of parent (body) */
            max-width: 100%;
            max-height: 100%; /* Ensure container doesn't exceed viewport height */
            box-sizing: border-box;
            padding: 0.5rem; /* Padding inside the container */
        }
        .game-title {
            font-size: 2.0rem; /* Larger title */
            font-weight: bold;
            color: #63b3ed; /* Lighter blue for title */
            margin-bottom: 0.5rem; /* Reduced margin */
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-align: center;
            line-height: 1.1; /* Adjust line height for smaller screens */
            flex-shrink: 0; /* Prevent title from shrinking */
        }
        .game-instructions {
            font-size: 0.9rem; /* Slightly smaller font for instructions */
            color: #a0aec0;
            text-align: center;
            margin-bottom: 0.8rem; /* Reduced margin */
            max-width: 90%; /* Prevent text from being too wide on small screens */
            flex-shrink: 0; /* Prevent instructions from shrinking */
        }
        canvas {
            display: block;
            border: 2px solid #4a5568; /* Subtle border */
            background-color: #2d3748; /* Slightly lighter background for canvas */
            border-radius: 0.5rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Soft shadow */
            /* Fixed internal game grid size, but allow the canvas element to shrink/grow */
            width: 600px; /* Original fixed width for internal drawing */
            height: 600px; /* Original fixed height for internal drawing */
            max-width: 100%; /* Allow canvas to shrink to fit container width */
            max-height: 100%; /* Allow canvas to shrink to fit container height */
            flex-grow: 1; /* Allow canvas to take up available space */
            flex-shrink: 1; /* Allow canvas to shrink */
            min-width: 0; /* Important for flex items to shrink below their content size */
            min-height: 0; /* Important for flex items to shrink below their content size */
            object-fit: contain; /* Shrink to fit while maintaining aspect ratio */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
        }

        /* Adjust font sizes for very small screens if necessary */
        @media (max-width: 650px) {
            .game-title {
                font-size: 1.5rem; /* Smaller title on very narrow screens */
            }
            .game-instructions {
                font-size: 0.5rem;
            }
        }

        .controls { /* Renamed from .game-actions for consistency with previous versions */
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.4rem; /* Reduced space between buttons */
            margin-top: 0.8rem; /* Reduced margin */
            width: 100%; /* Ensure controls take full width to wrap effectively */
            box-sizing: border-box;
            padding: 0 0.5rem; /* Small horizontal padding */
            flex-shrink: 0; /* Prevent controls from shrinking */
        }
        .controls button {
            padding: 0.6rem 1.0rem; /* Increased padding for better touch targets */
            background-color: #4299e1; /* Blue button */
            color: white;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.9rem; /* Slightly larger font for buttons */
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 1.5px 3.4px rgba(0, 0, 0, 0.1);
            min-width: 65px; /* Increased minimum width for better touch targets */
            flex-grow: 1; /* Allow buttons to grow to fill space in their row */
            max-width: 100px; /* Increased max width for individual buttons */
        }
        .controls button:hover {
            background-color: #3182ce; /* Darker blue on hover */
            transform: translateY(-1px); /* Slight lift effect */
        }
        .controls button:active {
            transform: translateY(1px); /* Press effect */
        }

        /* Styles for the upgrade menu buttons */
        #upgrade-menu-buttons {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100; /* Ensure it's on top */
            border: 2px solid #63b3ed;
            box-shadow: 0 0 15px rgba(99, 179, 237, 0.5);
            max-width: 90vw; /* Ensure upgrade menu fits screen width */
            max-height: 90vh; /* Ensure upgrade menu fits screen height */
            overflow-y: auto; /* Allow scrolling within the upgrade menu if content is too long */
            box-sizing: border-box;
        }
        #upgrade-menu-buttons h2 { /* Targeting the h2 inside the upgrade menu */
            font-family: "Inter", sans-serif; /* Match body font */
            font-size: 1.0rem; /* Slightly larger font for instructions */
            color: #a0aec0; /* Match .game-instructions color */
            font-weight: normal; /* Adjust as needed, .game-instructions is not bold */
            text-align: center;
            margin-bottom: 0.8rem;
            line-height: 1.1;
        }
        #upgrade-menu-buttons button {
            background-color: #4c51bf; /* Indigo */
            color: white;
            padding: 12px 18px; /* Increased padding for better touch targets */
            border-radius: 5px;
            font-size: 0.8rem; /* Increased font size for upgrade options */
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border: none;
            white-space: nowrap; /* Prevent button text from wrapping */
            display: flex; /* Enable flexbox for icon and text alignment */
            align-items: center; /* Vertically center icon and text */
            justify-content: center; /* Horizontally center content */
        }
        #upgrade-menu-buttons button i {
            margin-right: 8px; /* Increased space between icon and text */
            font-size: 1.0rem; /* Slightly larger icon for visibility */
        }
        #upgrade-menu-buttons button:hover {
            background-color: #5a67d8; /* Lighter indigo */
        }
        #upgrade-menu-buttons button:active {
            transform: translateY(1px);
        }

        /* Joystick styles */
        #joystick-container {
            position: fixed; /* Sticky position */
            bottom: 20px; /* From bottom */
            left: 20px; /* From left */
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            border: 2px solid #63b3ed;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50; /* Below upgrade menu, above canvas */
            touch-action: none; /* Prevent browser touch actions */
            box-shadow: 0 0 10px rgba(99, 179, 237, 0.3);
        }
        #joystick-thumb {
            width: 40px;
            height: 40px;
            background-color: #4299e1;
            border-radius: 50%;
            position: absolute; /* Relative to its parent (#joystick-container) */
            touch-action: none;
            box-shadow: 0 0 5px rgba(66, 153, 225, 0.7);
        }
        /* Hide joystick on larger screens if desired, or adjust its size */
        @media (min-width: 768px) {
            #joystick-container {
                /* You might want to hide or reposition the joystick on desktop */
                /* display: none; */
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="game-title">Infinite Map Adventure</h1>
        <p class="game-instructions">Navigate the fixed game area, collect coins, defeat enemies, and upgrade your hero!</p>

        <canvas id="gameCanvas"></canvas>

        <div id="controls" class="controls">
            <button id="pause" class="bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">Pause</button>
            <button id="soundToggle" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">Sound: Off</button>
        </div>
    </div>

    <!-- Joystick Container -->
    <div id="joystick-container">
        <div id="joystick-thumb"></div>
    </div>

    <!-- Upgrade Menu Buttons Container (initially hidden) -->
    <div id="upgrade-menu-buttons" style="display: none;">
        <h2 class="text-white text-center text-xl mb-4">Choose an Upgrade:</h2>
        <!-- Buttons will be dynamically updated with current values -->
        <button data-upgrade="1" id="upgrade-1"><i class="fas fa-running"></i> 1: +Move Speed</button>
        <button data-upgrade="2" id="upgrade-2"><i class="fas fa-gun"></i> 2: -Shoot CD</button>
        <button data-upgrade="3" id="upgrade-3"><i class="fas fa-forward"></i> 3: +Dash Dist</button>
        <button data-upgrade="4" id="upgrade-4"><i class="fas fa-star"></i> 4: -Special CD</button>
        <button data-upgrade="5" id="upgrade-5"><i class="fas fa-heart"></i> 5: +Extra Life</button>
        <button data-upgrade="6" id="upgrade-6"><i class="fas fa-bullseye"></i> 6: +Bullet DMG</button>
        <button data-upgrade="7" id="upgrade-7"><i class="fas fa-plus-circle"></i> 7: +Combo Bonus</button>
        <button data-upgrade="8" id="upgrade-8"><i class="fas fa-shield-alt"></i> 8: +Shield Dur</button>
        <button data-upgrade="9" id="upgrade-9"><i class="fas fa-snowflake"></i> 9: +Freeze Dur</button>
    </div>

    <script>
        /**
         * Game Class: Encapsulates all game logic, state, and rendering.
         * This structure promotes modularity and makes the code more maintainable.
         */
        class Game {
            constructor() {
                // -------------------- GLOBAL VARIABLES & NEW FEATURE FLAGS --------------------
                this.soundEnabled = false;
                this.doubleScoreActive = false;
                this.doubleScoreTimer = 0;
                this.timeOfDay = 0; // For day/night cycle
                this.bossSpecialTimer = 300; // Timer for boss special homing attack
                this.bossTime = 0; // Initialize bossTime

                // Global camera variables (world offset)
                this.cameraX = 0;
                this.cameraY = 0;

                // -------------------- CONSTANTS & SETTINGS --------------------
                this.CANVAS_WIDTH = 600;
                this.CANVAS_HEIGHT = 600;

                // Game Viewport Constants: All game logic and drawing happens within this area
                this.GAME_VIEWPORT_WIDTH = 340;
                this.GAME_VIEWPORT_HEIGHT = 150;
                // Offset to center the game viewport on the larger 600x600 canvas
                this.GAME_VIEWPORT_X_OFFSET = (this.CANVAS_WIDTH - this.GAME_VIEWPORT_WIDTH) / 2;
                this.GAME_VIEWPORT_Y_OFFSET = (this.CANVAS_HEIGHT - this.GAME_VIEWPORT_HEIGHT) / 2;

                this.PLAYER_SIZE = 20; // Increased player size for visibility
                this.COIN_SIZE = 8;
                this.OBSTACLE_SIZE = 10;
                this.BULLET_SIZE = 4;
                this.BULLET_SPEED = 5; // Reduced bullet speed
                this.INITIAL_MOVE_SPEED = 3; // Reduced player speed
                this.INITIAL_DASH_DISTANCE = 20;
                this.INITIAL_SHOOT_COOLDOWN = 20;
                this.INITIAL_SPECIAL_COOLDOWN = 60;
                this.DASH_COOLDOWN = 120;
                this.INVINCIBILITY_DURATION = 300;
                this.SPEED_BOOST_DURATION = 300;
                this.COMBO_RESET_TIME = 120;
                this.SPECIAL_ATTACK_RANGE = 50;
                this.PARTICLE_COUNT = 10;
                this.PARTICLE_MAX_LIFE = 50;
                this.PLAYER_HIT_FLASH_DURATION = 10;
                this.ENEMY_HIT_FLASH_DURATION = 5;

                this.BOSS_SHOOT_INTERVAL = 150;
                this.BOSS_BULLET_SPEED = 3; // Reduced boss bullet speed

                this.ENERGY_REGEN_RATE = 0.05;
                this.MAX_ENERGY = 100;
                this.ULTIMATE_BONUS = 20;

                this.currentShieldDuration = 300;
                this.currentFreezeDuration = 180;

                this.enemyTypes = {
                    normal: { color: "#f00",    health: 1, size: 10, hitColor: "#fff" },
                    fast:   { color: "#ffa500", health: 1, size: 8, hitColor: "#fff" },
                    tough:  { color: "#800000", health: 2, size: 12, hitColor: "#fff" },
                    rusher: { color: "#a0a0ff", health: 1, size: 10, hitColor: "#fff" }
                };

                this.INITIAL_BASE_SPEED = 0.005; // Reduced enemy base speed

                this.SPAWN_NEAR_MIN = 20;
                this.SPAWN_NEAR_MAX = 60;
                this.SPAWN_ENEMY_MIN = 30;
                this.SPAWN_ENEMY_MAX = 80;
                this.SPAWN_OBSTACLE_MIN = 20;
                this.SPAWN_OBSTACLE_MAX = 70;
                this.SPAWN_BOSS_MIN = 40;
                this.SPAWN_BOSS_MAX = 90;

                this.SAFEZONE_RADIUS = 50;
                this.SAFEZONE_DURATION = 600;
                this.SAFEZONE_CHANCE = 0.0005;
                this.COIN_RESPAWN_DISTANCE = this.GAME_VIEWPORT_WIDTH * 0.75;

                this.DESPAWN_DISTANCE = Math.max(this.GAME_VIEWPORT_WIDTH, this.GAME_VIEWPORT_HEIGHT) * 2;

                this.TARGET_ENEMY_COUNT = 3; // Reduced initial enemy count
                this.TARGET_OBSTACLE_COUNT = 10;
                this.TARGET_POWERUP_COUNT = 2;
                this.INITIAL_COIN_COUNT = 3;

                this.town = { x: 200, y: 200, width: 100, height: 100 };

                this.DEBRIS_SPAWN_CHANCE = 0.001;
                this.DEBRIS_SPEED = 2;
                this.STAR_COUNT = 100;
                this.STAR_SPEED_FACTOR = 0.05;

                // -------------------- GAME STATE VARIABLES --------------------
                this.gameState = "start";
                this.player = null;
                this.score = 0;
                this.lives = 0;
                this.level = 0;
                this.specialTimer = 0;
                this.shootTimer = 0;
                this.dashTimer = 0;
                this.baseSpeed = 0;
                this.enemies = [];
                this.boss = null;
                this.obstacles = [];
                this.powerups = [];
                this.bullets = [];
                this.coins = [];
                this.invincible = false;
                this.invTimer = 0;
                this.shieldActive = false;
                this.shieldTimer = 0;
                this.freezeTimer = 0;
                this.playerSpeedBoost = 1;
                this.speedBoostTimer = 0;
                this.lastDir = "up";
                this.comboCount = 0;
                this.comboTimer = 0;
                this.upgradeMenuActive = false;
                this.upgradeMenuTimer = 0;
                this.levelTransitionTimer = 0;
                this.highScore = localStorage.getItem("highScore") || 0;
                this.currentBulletDamage = 1;
                this.particles = [];
                this.scorePopups = [];
                this.dashParticles = [];
                this.debris = [];
                this.stars = [];
                this.bossBullets = [];
                this.safeZone = null;
                this.playerSafe = false;

                // Player health
                this.PLAYER_MAX_HEALTH = 10;
                this.currentMoveSpeed = this.INITIAL_MOVE_SPEED;
                this.currentDashDistance = this.INITIAL_DASH_DISTANCE;
                this.currentShootCooldown = this.INITIAL_SHOOT_COOLDOWN;
                this.currentSpecialCooldown = this.INITIAL_SPECIAL_COOLDOWN;

                // Level up threshold
                this.levelUpScoreThreshold = 5; // Initial score needed to level up

                // Player movement state
                this.keys = {
                    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
                    KeyW: false, KeyS: false, KeyA: false, KeyD: false
                };

                // Canvas and Context
                this.canvas = document.getElementById("gameCanvas");
                this.ctx = this.canvas.getContext("2d");
                this.canvas.width = this.CANVAS_WIDTH;
                this.canvas.height = this.CANVAS_HEIGHT;

                // Audio Context
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                // DOM elements
                this.upgradeMenuButtonsDiv = document.getElementById('upgrade-menu-buttons');
                this.joystickContainer = document.getElementById('joystick-container');
                this.joystickThumb = document.getElementById('joystick-thumb');

                // Joystick variables
                this.joystickActive = false;
                this.joystickCenterX = 0;
                this.joystickCenterY = 0;
                this.joystickRadius = this.joystickContainer.clientWidth / 2;
                this.thumbRadius = this.joystickThumb.clientWidth / 2;
            }

            /**
             * Initializes the game state and sets up event listeners.
             */
            init() {
                this.player = { x: 0, y: 0, h: this.PLAYER_MAX_HEALTH, maxH: this.PLAYER_MAX_HEALTH, hitTimer: 0, vx: 0, vy: 0 };
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.specialTimer = 0;
                this.shootTimer = 0;
                this.dashTimer = 0;
                this.baseSpeed = this.INITIAL_BASE_SPEED;
                this.invincible = false;
                this.invTimer = 0;
                this.shieldActive = false;
                this.shieldTimer = 0;
                this.freezeTimer = 0;
                this.playerSpeedBoost = 1;
                this.speedBoostTimer = 0;
                this.bossBullets = [];
                this.bossShootTimer = this.BOSS_SHOOT_INTERVAL;
                this.lastDir = "up";
                this.comboCount = 0;
                this.comboTimer = 0;
                this.upgradeMenuActive = false;
                this.upgradeMenuTimer = 0;
                this.levelTransitionTimer = 0;
                this.currentBulletDamage = 1;
                this.particles = [];
                this.scorePopups = [];
                this.dashParticles = [];
                this.debris = [];
                this.safeZone = null;
                this.doubleScoreActive = false;
                this.doubleScoreTimer = 0;
                this.bossSpecialTimer = 300;
                this.timeOfDay = 0;
                this.bossTime = 0; // Reset bossTime on init
                this.levelUpScoreThreshold = 5; // Reset level up threshold

                // Re-initialize stars
                this.stars = [];
                for (let i = 0; i < this.STAR_COUNT; i++) {
                    this.stars.push({
                        x: Math.random() * 2000 - 1000,
                        y: Math.random() * 2000 - 1000,
                        size: Math.random() * 2 + 0.5,
                        opacity: Math.random() * 0.5 + 0.5
                    });
                }

                // Initial spawn of entities around world origin
                this.populateCoins(this.INITIAL_COIN_COUNT, true);
                this.spawnEnemies(true);
                this.spawnBoss(true);
                this.spawnObstacles(true);

                this.gameState = "start";
                this.shakeTimer = 0;

                // Hide upgrade menu buttons on reset
                this.upgradeMenuButtonsDiv.style.display = 'none';

                // Reset keys state
                this.keys = {
                    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
                    KeyW: false, KeyS: false, KeyA: false, KeyD: false
                };

                // Reset joystick position
                this.joystickThumb.style.transform = `translate(-50%, -50%)`;

                this.addEventListeners();
            }

            /**
             * Adds all necessary event listeners for user input.
             */
            addEventListeners() {
                document.onkeydown = this.handleKeyDown.bind(this);
                document.onkeyup = this.handleKeyUp.bind(this);

                document.getElementById("pause").addEventListener("click", () => {
                    if(this.upgradeMenuActive) return;
                    this.gameState = (this.gameState === "paused") ? "playing" : "paused";
                });

                document.getElementById("soundToggle").addEventListener("click", () => {
                    this.soundEnabled = !this.soundEnabled;
                    document.getElementById("soundToggle").innerText = this.soundEnabled ? "Sound: On" : "Sound: Off";
                });

                this.upgradeMenuButtonsDiv.querySelectorAll('button').forEach(button => {
                    button.addEventListener('click', () => {
                        const upgradeChoice = button.dataset.upgrade;
                        if (this.upgradeMenuActive) {
                            this.processUpgrade(upgradeChoice);
                        }
                    });
                });

                this.joystickContainer.addEventListener('touchstart', this.handleJoystickStart.bind(this), { passive: false });
                this.joystickContainer.addEventListener('touchmove', this.handleJoystickMove.bind(this), { passive: false });
                this.joystickContainer.addEventListener('touchend', this.handleJoystickEnd.bind(this));
                this.joystickContainer.addEventListener('touchcancel', this.handleJoystickEnd.bind(this));

                this.joystickContainer.addEventListener('mousedown', this.handleJoystickStart.bind(this), { passive: false });
                this.joystickContainer.addEventListener('mousemove', this.handleJoystickMove.bind(this), { passive: false });
                this.joystickContainer.addEventListener('mouseup', this.handleJoystickEnd.bind(this));
                this.joystickContainer.addEventListener('mouseleave', this.handleJoystickEnd.bind(this));
            }

            // -------------------- INPUT HANDLERS --------------------
            handleKeyDown(e) {
                if(this.upgradeMenuActive) {
                    if(["1","2","3","4","5","6","7","8","9"].includes(e.key)) {
                        this.processUpgrade(e.key);
                        return;
                    }
                    return;
                }

                if(this.gameState === "start" && e.key === "Enter") {
                    this.gameState = "playing";
                    return;
                }
                if(this.gameState === "gameover" && e.key === "r") {
                    this.init(); // Restart game
                    return;
                }

                if(this.gameState === "playing") {
                    if(e.key === "p") { this.gameState = "paused"; return; }
                    if (e.key === "ArrowUp") this.keys.ArrowUp = true;
                    else if (e.key === "ArrowDown") this.keys.ArrowDown = true;
                    else if (e.key === "ArrowLeft") this.keys.ArrowLeft = true;
                    else if (e.key === "ArrowRight") this.keys.ArrowRight = true;
                    else if (e.key === "w" || e.key === "W") this.keys.KeyW = true;
                    else if (e.key === "s" || e.key === "S") this.keys.KeyS = true;
                    else if (e.key === "a" || e.key === "A") this.keys.KeyA = true;
                    else if (e.key === "d" || e.key === "D") this.keys.KeyD = true;

                    if (this.keys.ArrowUp || this.keys.KeyW) this.lastDir = "up";
                    else if (this.keys.ArrowDown || this.keys.KeyS) this.lastDir = "down";
                    else if (this.keys.ArrowLeft || this.keys.KeyA) this.lastDir = "left";
                    else if (this.keys.ArrowRight || this.keys.KeyD) this.lastDir = "right";
                } else if(this.gameState === "paused") {
                    if(e.key === "p") { this.gameState = "playing"; }
                }
            }

            handleKeyUp(e) {
                if (e.key === "ArrowUp") this.keys.ArrowUp = false;
                else if (e.key === "ArrowDown") this.keys.ArrowDown = false;
                else if (e.key === "ArrowLeft") this.keys.ArrowLeft = false;
                else if (e.key === "ArrowRight") this.keys.ArrowRight = false;
                else if (e.key === "w" || e.key === "W") this.keys.KeyW = false;
                else if (e.key === "s" || e.key === "S") this.keys.KeyS = false;
                else if (e.key === "a" || e.key === "A") this.keys.KeyA = false;
                else if (e.key === "d" || e.key === "D") this.keys.KeyD = false;
            }

            handleJoystickStart(e) {
                e.preventDefault();
                if (this.gameState === "playing" && !this.upgradeMenuActive) {
                    this.joystickActive = true;
                    const rect = this.joystickContainer.getBoundingClientRect();
                    this.joystickCenterX = rect.left + this.joystickRadius;
                    this.joystickCenterY = rect.top + this.joystickRadius;

                    let clientX, clientY;
                    if (e.touches && e.touches.length > 0) {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    this.updateJoystickThumb(clientX, clientY);
                } else if (this.gameState === "start") {
                    this.gameState = "playing";
                } else if (this.gameState === "gameover") {
                    this.init();
                }
            }

            handleJoystickMove(e) {
                e.preventDefault();
                if (this.joystickActive && this.gameState === "playing" && !this.upgradeMenuActive) {
                    let clientX, clientY;
                    if (e.touches && e.touches.length > 0) {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    this.updateJoystickThumb(clientX, clientY);
                }
            }

            handleJoystickEnd() {
                this.joystickActive = false;
                this.joystickThumb.style.transform = `translate(-50%, -50%)`;
                this.keys.ArrowUp = false; this.keys.ArrowDown = false;
                this.keys.ArrowLeft = false; this.keys.ArrowRight = false;
                this.keys.KeyW = false; this.keys.KeyS = false;
                this.keys.A = false; this.keys.KeyD = false;
            }

            updateJoystickThumb(clientX, clientY) {
                let dx = clientX - this.joystickCenterX;
                let dy = clientY - this.joystickCenterY;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > this.joystickRadius - this.thumbRadius) {
                    let angle = Math.atan2(dy, dx);
                    dx = (this.joystickRadius - this.thumbRadius) * Math.cos(angle);
                    dy = (this.joystickRadius - this.thumbRadius) * Math.sin(angle);
                }

                this.joystickThumb.style.transform = `translate(${dx - this.thumbRadius}px, ${dy - this.thumbRadius}px)`;

                const deadzone = this.joystickRadius * 0.2;
                this.keys.ArrowUp = dy < -deadzone;
                this.keys.ArrowDown = dy > deadzone;
                this.keys.ArrowLeft = dx < -deadzone;
                this.keys.ArrowRight = dx > deadzone;

                if (this.keys.ArrowUp) this.lastDir = "up";
                else if (this.keys.ArrowDown) this.lastDir = "down";
                else if (this.keys.ArrowLeft) this.lastDir = "left";
                else if (this.keys.ArrowRight) this.lastDir = "right";
            }

            // -------------------- SOUND FUNCTIONS --------------------
            playSound(frequency, duration) {
                if (!this.soundEnabled) return;
                let osc = this.audioCtx.createOscillator();
                let gain = this.audioCtx.createGain();
                osc.frequency.value = frequency;
                osc.type = "square";
                osc.connect(gain);
                gain.connect(this.audioCtx.destination);
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.0001, this.audioCtx.currentTime + duration);
                osc.stop(this.audioCtx.currentTime + duration);
            }
            soundShoot() { this.playSound(600, 0.05); }
            soundEnemyDeath() { this.playSound(400, 0.08); }
            soundLevelUp() { this.playSound(700, 0.15); }
            soundDash() { this.playSound(300, 0.07); }
            soundPlayerHit() { this.playSound(200, 0.1); }
            soundBossShoot() { this.playSound(500, 0.08); }
            soundUltimate() { this.playSound(800, 0.2); }
            soundCoinCollect() { this.playSound(900, 0.05); }
            soundPowerupCollect() { this.playSound(1200, 0.08); }
            soundBombExplode() { this.playSound(250, 0.3); }

            // -------------------- SCREEN SHAKE --------------------
            applyShake() {
                if(this.shakeTimer > 0) {
                    this.shakeTimer--;
                    let dx = (Math.random()-0.5)*6;
                    let dy = (Math.random()-0.5)*6;
                    this.ctx.translate(dx, dy);
                }
            }

            // -------------------- COLLISION FUNCTION (Squared Distance) --------------------
            collides(a, b, threshold = 10) {
                let dx = a.x - b.x;
                let dy = a.y - b.y;
                return dx * dx + dy * dy < threshold * threshold;
            }

            // -------------------- SPATIAL PARTITIONING --------------------
            buildEnemyGrid(enemies, cellSize) {
                const grid = {};
                enemies.forEach(enemy => {
                    let cellX = Math.floor(enemy.x / cellSize);
                    let cellY = Math.floor(enemy.y / cellSize);
                    let key = cellX + "," + cellY;
                    if(!grid[key]) grid[key] = [];
                    grid[key].push(enemy);
                });
                return grid;
            }

            // -------------------- SPAWN FUNCTIONS --------------------
            spawnInWorldArea(centerX, centerY, minDistFromCenter, maxDistFromCenter, checkCollisionsWith = []) {
                let attempts = 0;
                const MAX_ATTEMPTS = 50;
                let newX, newY;
                let collisionDetected;

                do {
                    collisionDetected = false;
                    let angle = Math.random() * Math.PI * 2;
                    let dist = minDistFromCenter + Math.random() * (maxDistFromCenter - minDistFromCenter);
                    newX = centerX + Math.cos(angle) * dist;
                    newY = centerY + Math.sin(angle) * dist;

                    for (const objArray of checkCollisionsWith) {
                        if (Array.isArray(objArray)) {
                            for (const obj of objArray) {
                                if (this.collides({x: newX, y: newY}, obj, this.COIN_SIZE + this.OBSTACLE_SIZE + 15)) {
                                    collisionDetected = true;
                                    break;
                                }
                            }
                        }
                        if (collisionDetected) break;
                    }
                    attempts++;
                } while (collisionDetected && attempts < MAX_ATTEMPTS);

                if (collisionDetected) {
                    return { x: centerX + (Math.random()-0.5)*10, y: centerY + (Math.random()-0.5)*10 };
                }
                return { x: newX, y: newY };
            }

            spawnEnemies(initial = false) {
                if (initial) this.enemies = [];
                let spawnCenterX = initial ? 0 : this.player.x;
                let spawnCenterY = initial ? 0 : this.player.y;

                for (let i = 0; i < this.TARGET_ENEMY_COUNT + Math.floor(this.level / 2) - this.enemies.length; i++) {
                    let r = Math.random();
                    let type;
                    if(r < 0.1)      { type = "rusher"; }
                    else if(r < 0.5) { type = "normal"; }
                    else if(r < 0.8) { type = "fast"; }
                    else             { type = "tough"; }
                    let speed = this.INITIAL_BASE_SPEED + (this.level * 0.0005); // Adjusted enemy speed increase
                    let extraHealth = (type !== "normal") ? Math.floor(this.level / 3) : 0;
                    let health = this.enemyTypes[type].health + extraHealth;
                    let pos = this.spawnInWorldArea(spawnCenterX, spawnCenterY, this.SPAWN_ENEMY_MIN, this.SPAWN_ENEMY_MAX, [this.obstacles, this.enemies, this.coins]);
                    this.enemies.push({ x: pos.x, y: pos.y, s: speed, h: health, maxH: health, type, size: this.enemyTypes[type].size, hitTimer: 0 });
                }
            }

            spawnBoss(initial = false) {
                if(this.level % 5 === 0 && !this.boss) {
                    let spawnCenterX = initial ? 0 : this.player.x;
                    let spawnCenterY = initial ? 0 : this.player.y;
                    let pos = this.spawnInWorldArea(spawnCenterX, spawnCenterY, this.SPAWN_BOSS_MIN, this.SPAWN_BOSS_MAX, [this.obstacles, this.enemies, this.coins]);
                    let bossHealth = 5 + this.level * 2;
                    this.boss = { x: pos.x, y: pos.y, s: this.INITIAL_BASE_SPEED * 0.5, h: bossHealth, maxH: bossHealth, minionsSpawned: false, size: 20, hitTimer: 0 };
                } else if (this.level % 5 !== 0) {
                    this.boss = null;
                }
            }

            spawnObstacles(initial = false) {
                if (initial) this.obstacles = [];
                let spawnCenterX = initial ? 0 : this.player.x;
                let spawnCenterY = initial ? 0 : this.player.y;

                for (let i = 0; i < this.TARGET_OBSTACLE_COUNT + Math.floor(this.level/3) - this.obstacles.length; i++) {
                    let pos = this.spawnInWorldArea(spawnCenterX, spawnCenterY, this.SPAWN_OBSTACLE_MIN, this.SPAWN_OBSTACLE_MAX, [this.enemies, this.obstacles, this.coins]);
                    this.obstacles.push({ x: pos.x, y: pos.y, size: this.OBSTACLE_SIZE + Math.random() * 5 });
                }
            }

            spawnPowerup() {
                let rand = Math.random();
                let type;
                if(rand < 0.05)      type = "double";
                else if(rand < 0.25) type = "inv";
                else if(rand < 0.45) type = "speed";
                else if(rand < 0.65) type = "shield";
                else if(rand < 0.8)  type = "freeze";
                else if(rand < 0.9)  type = "health";
                else                type = "bomb";
                let pos = this.spawnInWorldArea(this.player.x, this.player.y, this.SPAWN_ENEMY_MIN, this.SPAWN_ENEMY_MAX, [this.obstacles, this.enemies, this.coins, this.powerups]);
                this.powerups.push({ x: pos.x, y: pos.y, type });
            }

            spawnNewCoin() {
                let newCoinPos = this.spawnInWorldArea(this.player.x, this.player.y, this.SPAWN_NEAR_MIN, this.SPAWN_NEAR_MAX, [this.obstacles, this.coins]);
                this.coins.push(newCoinPos);
            }

            populateCoins(num, initialSpawn = false) {
                let spawnCenterX = initialSpawn ? 0 : this.player.x;
                let spawnCenterY = initialSpawn ? 0 : this.player.y;
                for (let i = 0; i < num; i++) {
                    let newCoinPos = this.spawnInWorldArea(spawnCenterX, spawnCenterY, this.SPAWN_NEAR_MIN, this.SPAWN_NEAR_MAX, [this.obstacles, this.coins]);
                    this.coins.push(newCoinPos);
                }
            }

            spawnBossMinions() {
                for(let i = 0; i < 2; i++){
                    let pos = this.spawnInWorldArea(this.boss.x, this.boss.y, 20, 40, [this.obstacles, this.enemies, this.coins]);
                    this.enemies.push({ x: pos.x, y: pos.y, s: this.baseSpeed, h: this.enemyTypes.normal.health, maxH: this.enemyTypes.normal.health, type: "normal", size: this.enemyTypes.normal.size, hitTimer: 0 });
                }
            }

            spawnDebris() {
                let x = this.cameraX + Math.random() * this.GAME_VIEWPORT_WIDTH;
                let y = this.cameraY - 10;
                this.debris.push({ x: x, y: y, speed: this.DEBRIS_SPEED });
            }

            spawnExplosion(x, y) {
                for(let i = 0; i < this.PARTICLE_COUNT; i++){
                    this.particles.push({
                        x: x, y: y,
                        dx: (Math.random()-0.5)*4,
                        dy: (Math.random()-0.5)*4,
                        life: this.PARTICLE_MAX_LIFE + Math.random()*20,
                        color: `hsl(${Math.random() * 360}, 100%, 70%)`
                    });
                }
            }

            spawnDashParticles(x, y, dx, dy) {
                for (let i = 0; i < 5; i++) {
                    this.dashParticles.push({
                        x: x - dx * (i * 2),
                        y: y - dy * (i * 2),
                        life: 20,
                        size: this.PLAYER_SIZE * (1 - i * 0.1),
                        color: `rgba(0, 255, 0, ${0.5 - i * 0.1})`
                    });
                }
            }

            spawnScorePopup(x, y, text, color = "#fff") {
                this.scorePopups.push({
                    x: x, y: y, text: text, color: color, life: 60, vy: -0.5
                });
            }

            // -------------------- PARTICLE AND POPUP UPDATE/DRAW FUNCTIONS --------------------
            updateParticles() {
                for(let i = this.particles.length - 1; i >= 0; i--){
                    let p = this.particles[i];
                    p.x += p.dx;
                    p.y += p.dy;
                    p.life--;
                    if(p.life <= 0 || Math.hypot(p.x - this.player.x, p.y - this.player.y) > this.DESPAWN_DISTANCE) this.particles.splice(i,1);
                }
            }

            updateAndDrawDashParticles() {
                for (let i = this.dashParticles.length - 1; i >= 0; i--) {
                    let p = this.dashParticles[i];
                    p.life--;
                    p.size *= 0.9;
                    if (p.life <= 0 || p.size < 0.5 || Math.hypot(p.x - this.player.x, p.y - this.player.y) > this.DESPAWN_DISTANCE) {
                        this.dashParticles.splice(i, 1);
                    } else {
                        this.ctx.fillStyle = p.color;
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            drawParticles() {
                for(let i = this.particles.length - 1; i >= 0; i--){
                    let p = this.particles[i];
                    // Drawing particles here, no need to update their position again
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            updateScorePopups() {
                for (let i = this.scorePopups.length - 1; i >= 0; i--) {
                    let popup = this.scorePopups[i];
                    popup.y += popup.vy;
                    popup.life--;
                    if (popup.life <= 0 || Math.hypot(popup.x - this.player.x, popup.y - this.player.y) > this.DESPAWN_DISTANCE) {
                        this.scorePopups.splice(i, 1);
                    }
                }
            }

            drawScorePopups() {
                this.scorePopups.forEach(popup => {
                    this.ctx.globalAlpha = popup.life / 60;
                    this.ctx.fillStyle = popup.color;
                    this.ctx.font = "bold 14px Arial";
                    this.ctx.fillText(popup.text, popup.x, popup.y);
                    this.ctx.globalAlpha = 1;
                });
            }

            // -------------------- OTHER UPDATE FUNCTIONS --------------------
            updateTimers() {
                if(!this.upgradeMenuActive) {
                    if(this.specialTimer > 0) this.specialTimer--;
                    if(this.shootTimer > 0) this.shootTimer--;
                    if(this.dashTimer > 0) this.dashTimer--;
                    if(this.levelTransitionTimer > 0) this.levelTransitionTimer--;
                    if(this.comboTimer > 0) this.comboTimer--; else { this.comboCount = 0; }
                    if(this.invincible) {
                        this.invTimer--;
                        if(this.invTimer <= 0) this.invincible = false;
                    }
                    if(this.speedBoostTimer > 0) { this.speedBoostTimer--; } else { this.playerSpeedBoost = 1; }
                    if(this.shieldTimer > 0) { this.shieldTimer--; } else { this.shieldActive = false; }
                    if(this.freezeTimer > 0) this.freezeTimer--;
                    if(this.player.hitTimer > 0) this.player.hitTimer--;
                }
            }

            updateEnergy() {
                this.energy = Math.min(this.MAX_ENERGY, this.energy + this.ENERGY_REGEN_RATE);
            }

            updateDayNightCycle() {
                this.timeOfDay += 0.005;
                let baseBrightness = 10;
                let maxBrightness = 60;
                let currentBrightness = baseBrightness + (maxBrightness - baseBrightness) * (0.5 + 0.5 * Math.sin(this.timeOfDay));

                let red = Math.floor(currentBrightness);
                let green = Math.floor(currentBrightness * 0.9);
                let blue = Math.floor(currentBrightness * 0.8);

                if (Math.sin(this.timeOfDay) > 0.8) {
                    red = Math.floor(red * 1.1 + 20);
                    green = Math.floor(green * 1.05 + 10);
                } else if (Math.sin(this.timeOfDay) < -0.8) {
                    red = Math.floor(red * 0.9);
                    green = Math.floor(green * 0.9);
                    blue = Math.floor(blue * 1.1 + 20);
                }
                return `rgb(${red},${green},${blue})`;
            }

            updateSafeZone() {
                if(this.safeZone === null && Math.random() < this.SAFEZONE_CHANCE) {
                    let pos = this.spawnInWorldArea(this.player.x, this.player.y, this.SPAWN_NEAR_MIN, this.SPAWN_NEAR_MAX, [this.obstacles, this.enemies, this.coins]);
                    this.safeZone = {
                        x: pos.x, y: pos.y, radius: this.SAFEZONE_RADIUS, duration: this.SAFEZONE_DURATION
                    };
                }
                if(this.safeZone) {
                    this.safeZone.duration--;
                    if(this.safeZone.duration <= 0) this.safeZone = null;
                }
                this.playerSafe = (this.safeZone && this.collides(this.player, this.safeZone, this.safeZone.radius));
            }

            updateDebris() {
                for(let i = this.debris.length - 1; i >= 0; i--){
                    let d = this.debris[i];
                    d.y += d.speed;
                    if(Math.hypot(d.x - this.player.x, d.y - this.player.y) > this.DESPAWN_DISTANCE) {
                        this.debris.splice(i, 1);
                        continue;
                    }
                    if(this.collides(d, this.player, this.PLAYER_SIZE)) {
                        this.playerHit(this.player.h + 1);
                        this.debris.splice(i, 1);
                    }
                }
            }

            updateBullets() {
                for(let i = this.bullets.length - 1; i >= 0; i--){
                    let b = this.bullets[i];
                    if(b.target) {
                        let targetExists = this.enemies.some(en => en === b.target);
                        if(targetExists) {
                            let dx = b.target.x - b.x;
                            let dy = b.target.y - b.y;
                            let mag = Math.sqrt(dx*dx + dy*dy) || 1;
                            let desiredVx = (dx/mag) * this.BULLET_SPEED;
                            let desiredVy = (dy/mag) * this.BULLET_SPEED;
                            let homingFactor = 0.1;
                            b.vx += (desiredVx - b.vx) * homingFactor;
                            b.vy += (desiredVy - b.vy) * homingFactor;
                        } else {
                            b.target = null;
                        }
                    }

                    b.x += b.vx;
                    b.y += b.vy;

                    if(Math.hypot(b.x - this.player.x, b.y - this.player.y) > this.DESPAWN_DISTANCE) {
                        this.bullets.splice(i, 1);
                        continue;
                    }

                    const cellSize = 50;
                    let cellX = Math.floor(b.x / cellSize);
                    let cellY = Math.floor(b.y / cellSize);
                    let collisionDetected = false;
                    let grid = this.buildEnemyGrid(this.enemies, cellSize);

                    for(let dx = -1; dx <= 1; dx++){
                        for(let dy = -1; dy <= 1; dy++){
                            let key = (cellX + dx) + "," + (cellY + dy);
                            let cellEnemies = grid[key];
                            if(cellEnemies){
                                for(let j = 0; j < cellEnemies.length; j++){
                                    let enemy = cellEnemies[j];
                                    if(this.collides(b, enemy, 8)){
                                        enemy.h -= this.currentBulletDamage;
                                        enemy.hitTimer = this.ENEMY_HIT_FLASH_DURATION;
                                        if(enemy.h <= 0) {
                                            let coinScore = (this.comboCount > 1 ? this.comboCount : 1);
                                            if(this.doubleScoreActive) coinScore *= 2;
                                            this.score += coinScore;
                                            this.spawnScorePopup(enemy.x, enemy.y, `+${coinScore}`, "#00ff00");
                                            this.comboCount++;
                                            this.comboTimer = this.COMBO_RESET_TIME;
                                            this.spawnExplosion(enemy.x, enemy.y);
                                            this.soundEnemyDeath();
                                            let index = this.enemies.indexOf(enemy);
                                            if(index > -1) this.enemies.splice(index, 1);
                                        }
                                        this.bullets.splice(i, 1);
                                        collisionDetected = true;
                                        break;
                                    }
                                }
                            }
                            if(collisionDetected) break;
                        }
                        if(collisionDetected) break;
                    }

                    if(!collisionDetected && this.bullets[i] && this.boss && this.collides(b, this.boss, 10)){
                        this.boss.h -= this.currentBulletDamage;
                        this.boss.hitTimer = this.ENEMY_HIT_FLASH_DURATION;
                        this.bullets.splice(i, 1);
                        if(this.boss.h <= 0) {
                            let bossScore = 5;
                            if(this.doubleScoreActive) bossScore *= 2;
                            this.score += bossScore;
                            this.spawnScorePopup(this.boss.x, this.boss.y, `+${bossScore}`, "#00ff00");
                            this.spawnExplosion(this.boss.x, this.boss.y);
                            this.boss = null;
                            this.soundEnemyDeath();
                        }
                    }
                }
            }

            updateBossBullets() {
                for(let i = this.bossBullets.length - 1; i >= 0; i--){
                    let b = this.bossBullets[i];
                    if(b.isBossSpecial) {
                        let dx = this.player.x - b.x, dy = this.player.y - b.y;
                        let mag = Math.sqrt(dx*dx + dy*dy) || 1;
                        let desiredVx = (dx/mag) * this.BOSS_BULLET_SPEED;
                        let desiredVy = (dy/mag) * this.BOSS_BULLET_SPEED;
                        let homingFactor = 0.05;
                        b.vx += (desiredVx - b.vx) * homingFactor;
                        b.vy += (desiredVy - b.vy) * homingFactor;
                    }
                    b.x += b.vx;
                    b.y += b.vy;

                    if(Math.hypot(b.x - this.player.x, b.y - this.player.y) > this.DESPAWN_DISTANCE) {
                        this.bossBullets.splice(i,1);
                        continue;
                    }

                    if(this.collides(b, this.player, 8)) {
                        this.playerHit(1);
                        this.bossBullets.splice(i,1);
                    }
                }
            }

            updateEnemy(en) {
                if(this.freezeTimer > 0) return; // Enemies are frozen

                if(en.type === "normal") {
                    en.x += (this.player.x - en.x) * en.s;
                    en.y += (this.player.y - en.y) * en.s;
                }
                else if(en.type === "fast") {
                    let dx = this.player.x - en.x;
                    let dy = this.player.y - en.y;
                    en.x += dx * en.s * 0.5 + (-dy) * en.s * 0.5;
                    en.y += dy * en.s * 0.5 + (dx) * en.s * 0.5;
                }
                else if(en.type === "tough") {
                    let dx = this.player.x - en.x;
                    let dy = this.player.y - en.y;
                    let dist = Math.hypot(dx, dy);
                    if(dist < 80) {
                        en.x -= dx * en.s * 1.5;
                        en.y -= dy * en.s * 1.5;
                    } else if(dist > 120) {
                        en.x += dx * en.s * 0.5;
                        en.y += dy * en.s * 0.5;
                    } else {
                        en.x += (-dy) * en.s * 0.3;
                        en.y += (dx) * en.s * 0.3;
                    }
                }
                else if(en.type === "rusher") {
                    let dx = this.player.x - en.x;
                    let dy = this.player.y - en.y;
                    let dist = Math.hypot(dx, dy);
                    if(dist < 100) {
                        en.x += dx * en.s * 2;
                        en.y += dy * en.s * 2;
                    } else {
                        en.x += dx * en.s + (Math.random()-0.5) * en.s;
                        en.y += dy * en.s + (Math.random()-0.5) * en.s;
                    }
                }

                if(this.safeZone) {
                    let dx = en.x - this.safeZone.x;
                    let dy = en.y - this.safeZone.y;
                    let d = Math.sqrt(dx*dx + dy*dy);
                    if(d < this.safeZone.radius) {
                        let repelSpeed = 3;
                        en.x += (dx/d) * repelSpeed;
                        en.y += (dy/d) * repelSpeed;
                    }
                }
                if(en.x > this.town.x && en.x < this.town.x + this.town.width &&
                   en.y > this.town.y && en.y < this.town.y + this.town.height) {
                    let cx = this.town.x + this.town.width/2;
                    let cy = this.town.y + this.town.height/2;
                    let dx = en.x - cx;
                    let dy = en.y - cy;
                    let d = Math.sqrt(dx*dx + dy*dy) || 1;
                    let repelSpeed = 4;
                    en.x += (dx/d) * repelSpeed;
                    en.y += (dy/d) * repelSpeed;
                }
                if (en.hitTimer > 0) en.hitTimer--;
            }

            updateBoss() {
                if(this.freezeTimer > 0) return; // Boss is frozen

                this.bossTime++;
                let offsetX = 50 * Math.cos(this.bossTime * 0.05);
                let offsetY = 50 * Math.sin(this.bossTime * 0.05);
                this.boss.x += ((this.player.x + offsetX) - this.boss.x) * this.boss.s;
                this.boss.y += ((this.player.y + offsetY) - this.boss.y) * this.boss.s;

                if(this.safeZone) {
                    let dx = this.boss.x - this.safeZone.x;
                    let dy = this.boss.y - this.safeZone.y;
                    let d = Math.sqrt(dx*dx + dy*dy);
                    if(d < this.safeZone.radius) {
                        let repelSpeed = 3;
                        this.boss.x += (dx/d) * repelSpeed;
                        this.boss.y += (dy/d) * repelSpeed;
                    }
                }
                if(this.boss.x > this.town.x && this.boss.x < this.town.x + this.town.width &&
                   this.boss.y > this.town.y && this.boss.y < this.town.y + this.town.height) {
                    let cx = this.town.x + this.town.width/2;
                    let cy = this.town.y + this.town.height/2;
                    let dx = this.boss.x - cx;
                    let dy = this.boss.y - cy;
                    let d = Math.sqrt(dx*dx + dy*dy) || 1;
                    let repelSpeed = 4;
                    this.boss.x += (dx/d) * repelSpeed;
                    this.boss.y += (dy/d) * repelSpeed;
                }

                if(this.boss && this.boss.h < this.boss.maxH * 0.5 && !this.boss.minionsSpawned) {
                    this.spawnBossMinions();
                    this.boss.minionsSpawned = true;
                }

                this.bossSpecialTimer--;
                if(this.bossSpecialTimer <= 0) {
                    let dx = this.player.x - this.boss.x, dy = this.player.y - this.boss.y;
                    let mag = Math.sqrt(dx*dx + dy*dy) || 1;
                    let bulletSpeed = 3;
                    let vx = (dx/mag) * bulletSpeed;
                    let vy = (dy/mag) * bulletSpeed;
                    this.bossBullets.push({ x: this.boss.x, y: this.boss.y, vx: vx, vy: vy, isBossSpecial: true });
                    this.bossSpecialTimer = 300;
                }
                if (this.boss.hitTimer > 0) this.boss.hitTimer--;
            }

            // -------------------- GAME MECHANICS --------------------
            playerHit(damage = 1) {
                if (this.invincible || this.playerSafe) return;

                if (this.shieldActive) {
                    this.shieldActive = false;
                    this.shieldTimer = 0;
                    this.soundPlayerHit();
                    return;
                }

                this.player.h -= damage;
                this.player.hitTimer = this.PLAYER_HIT_FLASH_DURATION;
                this.shakeTimer = 10;
                this.soundPlayerHit();

                if (this.player.h <= 0) {
                    this.lives--;
                    if (this.lives > 0) {
                        this.player.h = this.PLAYER_MAX_HEALTH;
                        this.invincible = true;
                        this.invTimer = this.INVINCIBILITY_DURATION;
                        this.enemies = [];
                        this.spawnEnemies(false);
                        this.boss = null;
                        this.spawnBoss(false);
                    } else {
                        this.gameState = "gameover";
                        if (this.score > this.highScore) {
                            this.highScore = this.score;
                            localStorage.setItem("highScore", this.highScore);
                        }
                    }
                }
            }

            findNearestEnemy() {
                let minDist = Infinity;
                let chosen = null;
                for(let i = 0; i < this.enemies.length; i++){
                    let en = this.enemies[i];
                    let dx = en.x - this.player.x;
                    let dy = en.y - this.player.y;
                    let distSq = dx*dx + dy*dy;
                    if(distSq < minDist) {
                        minDist = distSq;
                        chosen = en;
                    }
                }
                return chosen;
            }

            autoPowers() {
                if(this.shootTimer <= 0) {
                    let target = this.findNearestEnemy();
                    let vx, vy;
                    if(target) {
                        let dx = target.x - this.player.x;
                        let dy = target.y - this.player.y;
                        let mag = Math.sqrt(dx*dx + dy*dy) || 1;
                        vx = (dx/mag) * this.BULLET_SPEED;
                        vy = (dy/mag) * this.BULLET_SPEED;
                    } else {
                        if(this.keys.ArrowUp || this.keys.KeyW) { vx = 0; vy = -this.BULLET_SPEED; }
                        else if(this.keys.ArrowDown || this.keys.KeyS) { vx = 0; vy = this.BULLET_SPEED; }
                        else if(this.keys.ArrowLeft || this.keys.KeyA) { vx = -this.BULLET_SPEED; vy = 0; }
                        else if(this.keys.ArrowRight || this.keys.KeyD) { vx = this.BULLET_SPEED; vy = 0; }
                        else { vx = 0; vy = -this.BULLET_SPEED; }
                    }
                    this.bullets.push({ x: this.player.x, y: this.player.y, vx: vx, vy: vy, target: target });
                    this.shootTimer = this.currentShootCooldown;
                    this.soundShoot();
                }

                if(this.specialTimer <= 0) {
                    this.enemies = this.enemies.filter(en => {
                        if(this.collides(this.player, en, this.SPECIAL_ATTACK_RANGE)) {
                            let coinScore = (this.comboCount > 1 ? this.comboCount : 1);
                            if(this.doubleScoreActive) coinScore *= 2;
                            this.score += coinScore;
                            this.spawnScorePopup(en.x, en.y, `+${coinScore}`, "#00ff00");
                            this.spawnExplosion(en.x, en.y);
                            this.soundEnemyDeath();
                            return false;
                        }
                        return true;
                    });
                    if(this.boss) {
                        if(this.collides(this.player, this.boss, this.SPECIAL_ATTACK_RANGE)) {
                            this.boss.h -= 2;
                            this.boss.hitTimer = this.ENEMY_HIT_FLASH_DURATION;
                            if(this.boss.h <= 0) {
                                let bossScore = 5;
                                if(this.doubleScoreActive) bossScore *= 2;
                                this.score += bossScore;
                                this.spawnScorePopup(this.boss.x, this.boss.y, `+${bossScore}`, "#00ff00");
                                this.spawnExplosion(this.boss.x, this.boss.y);
                                this.boss = null;
                                this.soundEnemyDeath();
                            }
                        }
                    }
                    this.specialTimer = this.currentSpecialCooldown;
                }

                if(this.dashTimer <= 0) {
                    const dangerRadius = 20;
                    let closeEnemies = this.enemies.filter(en => this.collides(this.player, en, dangerRadius));
                    if(closeEnemies.length > 0) {
                        let avgX = 0, avgY = 0;
                        closeEnemies.forEach(en => { avgX += en.x; avgY += en.y; });
                        avgX /= closeEnemies.length;
                        avgY /= closeEnemies.length;

                        let dx = this.player.x - avgX;
                        let dy = this.player.y - avgY;
                        let mag = Math.sqrt(dx*dx + dy*dy) || 1;
                        dx /= mag;
                        dy /= mag;

                        this.player.x += dx * this.currentDashDistance;
                        this.player.y += dy * this.currentDashDistance;
                        this.dashTimer = this.DASH_COOLDOWN;
                        this.soundDash();
                        this.spawnDashParticles(this.player.x, this.player.y, dx, dy);
                    }
                }

                if(this.energy >= this.MAX_ENERGY) {
                    this.ultimateMove();
                }
            }

            ultimateMove() {
                if(this.energy >= this.MAX_ENERGY) {
                    this.enemies.forEach(en => { this.spawnExplosion(en.x, en.y); });
                    if(this.boss) { this.spawnExplosion(this.boss.x, this.boss.y); }
                    let count = this.enemies.length + (this.boss ? 1 : 0);
                    this.score += this.ULTIMATE_BONUS + count * 2;
                    this.spawnScorePopup(this.player.x, this.player.y, `+${this.ULTIMATE_BONUS + count * 2}`, "#00ffff");
                    this.enemies = [];
                    this.boss = null;
                    this.energy = 0;
                    this.soundUltimate();
                }
            }

            processUpgrade(choice) {
                if(choice === "1") { this.currentMoveSpeed += 1; }
                else if(choice === "2") { this.currentShootCooldown = Math.max(5, this.currentShootCooldown - 5); }
                else if(choice === "3") { this.currentDashDistance += 10; }
                else if(choice === "4") { this.currentSpecialCooldown = Math.max(10, this.currentSpecialCooldown - 5); }
                else if(choice === "5") { this.lives++; }
                else if(choice === "6") { this.currentBulletDamage++; }
                else if(choice === "7") { this.comboCount += 1; }
                else if(choice === "8") { this.currentShieldDuration += 50; }
                else if(choice === "9") { this.currentFreezeDuration += 30; }
                this.upgradeMenuActive = false;
                this.levelTransitionTimer = 60;
                this.soundLevelUp();
                this.upgradeMenuButtonsDiv.style.display = 'none';
            }

            // -------------------- DRAWING FUNCTIONS --------------------
            drawHealthBar(x, y, width, height, currentHealth, maxHealth, color = "#0f0") {
                this.ctx.fillStyle = "#333";
                this.ctx.fillRect(x, y, width, height);
                this.ctx.fillStyle = color;
                let healthWidth = (currentHealth / maxHealth) * width;
                this.ctx.fillRect(x, y, healthWidth, height);
                this.ctx.strokeStyle = "#fff";
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(x, y, width, height);
            }

            drawScrollingBackground() {
                this.ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                this.stars.forEach(star => {
                    let parallaxX = (star.x * this.STAR_SPEED_FACTOR - this.cameraX * this.STAR_SPEED_FACTOR) % this.CANVAS_WIDTH;
                    let parallaxY = (star.y * this.STAR_SPEED_FACTOR - this.cameraY * this.STAR_SPEED_FACTOR) % this.CANVAS_HEIGHT;

                    if (parallaxX < 0) parallaxX += this.CANVAS_WIDTH;
                    if (parallaxY < 0) parallaxY += this.CANVAS_HEIGHT;

                    this.ctx.globalAlpha = star.opacity;
                    this.ctx.beginPath();
                    this.ctx.arc(parallaxX, parallaxY, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.globalAlpha = 1;
            }

            drawMinimap() {
                let mapWidth = 80, mapHeight = 80;
                let mapX = this.CANVAS_WIDTH - mapWidth - 10, mapY = 10;
                this.ctx.save();
                this.ctx.fillStyle = "rgba(0,0,0,0.5)";
                this.ctx.fillRect(mapX, mapY, mapWidth, mapHeight);
                this.ctx.strokeStyle = "#fff";
                this.ctx.strokeRect(mapX, mapY, mapWidth, mapHeight);

                const mapWorldSize = 500;
                let worldMinX = this.player.x - mapWorldSize / 2;
                let worldMinY = this.player.y - mapWorldSize / 2;

                let scaleX = mapWidth / mapWorldSize;
                let scaleY = mapHeight / mapWorldSize;

                const drawMarker = (worldObj, color, label) => {
                    let x = mapX + (worldObj.x - worldMinX) * scaleX;
                    let y = mapY + (worldObj.y - worldMinY) * scaleY;

                    if (x >= mapX && x <= mapX + mapWidth && y >= mapY && y <= mapY + mapHeight) {
                        this.ctx.fillStyle = color;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 3, 0, Math.PI*2);
                        this.ctx.fill();
                        this.ctx.font = "8px sans-serif";
                        this.ctx.fillText(label, x+4, y+4);
                    }
                };
                drawMarker(this.player, "#0f0", "P");
                this.coins.forEach(c => drawMarker(c, "#ff0", "C"));
                if(this.safeZone) drawMarker(this.safeZone, "#0ff", "S");
                drawMarker(this.town, "#fff", "T");
                this.ctx.restore();
            }

            drawDebris() {
                this.ctx.fillStyle = "#777";
                this.debris.forEach(d => { this.ctx.fillRect(d.x, d.y, 6, 6); });
            }

            drawIndicator(targetWorldX, targetWorldY, color, label) {
                let targetScreenX = targetWorldX - this.cameraX;
                let targetScreenY = targetWorldY - this.cameraY;

                if (targetScreenX >= 0 && targetScreenX <= this.GAME_VIEWPORT_WIDTH &&
                    targetScreenY >= 0 && targetScreenY <= this.GAME_VIEWPORT_HEIGHT) {
                    return;
                }

                let viewportCanvasCenterX = this.GAME_VIEWPORT_X_OFFSET + this.GAME_VIEWPORT_WIDTH / 2;
                let viewportCanvasCenterY = this.GAME_VIEWPORT_Y_OFFSET + this.GAME_VIEWPORT_HEIGHT / 2;

                let dx = targetScreenX - this.GAME_VIEWPORT_WIDTH / 2;
                let dy = targetScreenY - this.GAME_VIEWPORT_HEIGHT / 2;
                let angle = Math.atan2(dy, dx);

                let margin = 10;
                let halfWidth = this.GAME_VIEWPORT_WIDTH / 2 - margin;
                let halfHeight = this.GAME_VIEWPORT_HEIGHT / 2 - margin;

                let scale = Math.min(
                    halfWidth / Math.abs(Math.cos(angle)),
                    halfHeight / Math.abs(Math.sin(angle))
                );

                let arrowCanvasX = viewportCanvasCenterX + Math.cos(angle) * scale;
                let arrowCanvasY = viewportCanvasCenterY + Math.sin(angle) * scale;

                this.ctx.save();
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                let arrowSize = 10;
                let tipX = arrowCanvasX, tipY = arrowCanvasY;
                let perpAngle = angle + Math.PI/2;

                let baseX1 = arrowCanvasX - Math.cos(angle)*arrowSize + Math.cos(perpAngle)*(arrowSize/2);
                let baseY1 = arrowCanvasY - Math.sin(angle)*arrowSize + Math.sin(perpAngle)*(arrowSize/2);
                let baseX2 = arrowCanvasX - Math.cos(angle)*arrowSize - Math.cos(perpAngle)*(arrowSize/2);
                let baseY2 = arrowCanvasY - Math.sin(angle)*arrowSize - Math.sin(perpAngle)*(arrowSize/2);

                this.ctx.moveTo(tipX, tipY);
                this.ctx.lineTo(baseX1, baseY1);
                this.ctx.lineTo(baseX2, baseY2);
                this.ctx.closePath();
                this.ctx.fill();

                this.ctx.font = "10px sans-serif";
                this.ctx.fillText(label, arrowCanvasX - this.ctx.measureText(label).width/2, arrowCanvasY - arrowSize - 2);
                this.ctx.restore();
            }

            updateUpgradeMenuButtons() {
                document.getElementById('upgrade-1').innerHTML = `<i class="fas fa-running"></i> 1: +Move Speed (Current: ${this.currentMoveSpeed})`;
                document.getElementById('upgrade-2').innerHTML = `<i class="fas fa-gun"></i> 2: -Shoot CD (Current: ${(this.currentShootCooldown/60).toFixed(1)}s)`;
                document.getElementById('upgrade-3').innerHTML = `<i class="fas fa-forward"></i> 3: +Dash Dist (Current: ${this.currentDashDistance})`;
                document.getElementById('upgrade-4').innerHTML = `<i class="fas fa-star"></i> 4: -Special CD (Current: ${(this.currentSpecialCooldown/60).toFixed(1)}s)`;
                document.getElementById('upgrade-5').innerHTML = `<i class="fas fa-heart"></i> 5: +Extra Life (Current: ${this.lives})`;
                document.getElementById('upgrade-6').innerHTML = `<i class="fas fa-bullseye"></i> 6: +Bullet DMG (Current: ${this.currentBulletDamage})`;
                document.getElementById('upgrade-7').innerHTML = `<i class="fas fa-plus-circle"></i> 7: +Combo Bonus (Current Multiplier: x${this.comboCount > 1 ? this.comboCount : 1})`;
                document.getElementById('upgrade-8').innerHTML = `<i class="fas fa-shield-alt"></i> 8: +Shield Dur (Current: ${(this.currentShieldDuration/60).toFixed(1)}s)`;
                document.getElementById('upgrade-9').innerHTML = `<i class="fas fa-snowflake"></i> 9: +Freeze Dur (Current: ${(this.currentFreezeDuration/60).toFixed(1)}s)`;
            }

            // -------------------- MAIN GAME LOOP --------------------
            loop() {
                this.updateTimers();
                let bgColor = this.updateDayNightCycle();
                this.ctx.fillStyle = bgColor;
                this.ctx.fillRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);

                this.drawScrollingBackground();
                this.updateEnergy();
                if(this.doubleScoreActive) {
                    this.doubleScoreTimer--;
                    if(this.doubleScoreTimer <= 0) { this.doubleScoreActive = false; }
                }

                this.updateSafeZone();
                if(Math.random() < this.DEBRIS_SPAWN_CHANCE) { this.spawnDebris(); }
                this.updateDebris();

                if(this.powerups.length < this.TARGET_POWERUP_COUNT && Math.random() < 0.001) { this.spawnPowerup(); }

                if(!this.upgradeMenuActive) {
                    this.updateBullets();
                    this.updateBossBullets();
                    this.updateParticles(); // Updated particles' positions
                    this.updateScorePopups(); // Updated score popups' positions
                }

                if(this.gameState === "playing" && !this.upgradeMenuActive) {
                    this.autoPowers();

                    let targetVx = 0;
                    let targetVy = 0;
                    let currentSpeed = this.currentMoveSpeed * this.playerSpeedBoost;

                    if (this.keys.ArrowUp || this.keys.KeyW) targetVy = -currentSpeed;
                    if (this.keys.ArrowDown || this.keys.KeyS) targetVy = currentSpeed;
                    if (this.keys.ArrowLeft || this.keys.KeyA) targetVx = -currentSpeed;
                    if (this.keys.ArrowRight || this.keys.KeyD) targetVx = currentSpeed;

                    if (targetVx !== 0 && targetVy !== 0) {
                        let diagonalFactor = Math.sqrt(2);
                        targetVx /= diagonalFactor;
                        targetVy /= diagonalFactor;
                    }

                    const acceleration = 0.2;
                    const friction = 0.8;

                    this.player.vx += (targetVx - this.player.vx) * acceleration;
                    this.player.vy += (targetVy - this.player.vy) * acceleration;

                    if (targetVx === 0) this.player.vx *= friction;
                    if (targetVy === 0) this.player.vy *= friction;

                    this.player.x += this.player.vx;
                    this.player.y += this.player.vy;

                    // Only update enemy and boss if not frozen
                    this.enemies.forEach(en => this.updateEnemy(en));
                    if(this.boss) { this.updateBoss(); }


                    this.enemies.forEach(en => {
                        if(this.collides(this.player, en, this.PLAYER_SIZE/2 + en.size/2)) {
                            this.playerHit(1);
                        }
                    });
                    if(this.boss && this.collides(this.player, this.boss, this.PLAYER_SIZE/2 + this.boss.size/2)) {
                        this.playerHit(1);
                    }
                    this.obstacles.forEach(ob => {
                        if(this.collides(this.player, ob, this.PLAYER_SIZE/2 + ob.size/2)) {
                            this.playerHit(this.player.h + 1);
                        }
                    });

                    this.powerups.forEach((pw, i) => {
                        if(this.collides(this.player, pw, 10)) {
                            if(pw.type === "inv") { this.invincible = true; this.invTimer = this.INVINCIBILITY_DURATION; }
                            else if(pw.type === "speed") { this.playerSpeedBoost = 2; this.speedBoostTimer = this.SPEED_BOOST_DURATION; }
                            else if(pw.type === "shield") { this.shieldActive = true; this.shieldTimer = this.currentShieldDuration; }
                            else if(pw.type === "freeze") { this.freezeTimer = this.currentFreezeDuration; }
                            else if(pw.type === "double") { this.doubleScoreActive = true; this.doubleScoreTimer = 600; }
                            else if(pw.type === "health") { this.player.h = Math.min(this.player.maxH, this.player.h + 3); this.spawnScorePopup(this.player.x, this.player.y, `+3 HP`, "#00ff00"); }
                            else if(pw.type === "bomb") {
                                this.enemies.forEach(en => { this.spawnExplosion(en.x, en.y); });
                                if(this.boss) { this.spawnExplosion(this.boss.x, this.boss.y); }
                                let bombScore = this.enemies.length + (this.boss ? 1 : 0);
                                this.score += bombScore * 2;
                                this.spawnScorePopup(this.player.x, this.player.y, `+${bombScore * 2} (Bomb!)`, "#ff00ff");
                                this.enemies = [];
                                this.boss = null;
                                this.soundBombExplode();
                            }
                            this.powerups.splice(i, 1);
                            this.soundPowerupCollect();
                        }
                    });

                    for (let i = this.coins.length - 1; i >= 0; i--) {
                        let currentCoin = this.coins[i];
                        if (this.collides(this.player, currentCoin)) {
                            let coinScore = (this.comboCount > 1 ? this.comboCount : 1);
                            if(this.doubleScoreActive) { coinScore *= 2; }
                            this.score += coinScore;
                            this.energy = Math.min(this.MAX_ENERGY, this.energy + 10);
                            this.spawnScorePopup(currentCoin.x, currentCoin.y, `+${coinScore}`, "#ffff00");
                            this.coins.splice(i, 1);
                            this.soundCoinCollect();
                            this.spawnNewCoin();
                            break;
                        }

                        let distToCoin = Math.hypot(this.player.x - currentCoin.x, this.player.y - currentCoin.y);
                        if (distToCoin > this.COIN_RESPAWN_DISTANCE) {
                            this.coins.splice(i, 1);
                            this.spawnNewCoin();
                        }
                    }

                    // Level up logic
                    if(this.score >= this.levelUpScoreThreshold && this.levelTransitionTimer === 0) {
                        this.level++;
                        this.baseSpeed += 0.0005; // Slower increase in enemy base speed
                        this.populateCoins(Math.floor(this.level / 2) + 1);
                        this.upgradeMenuActive = true;
                        this.upgradeMenuTimer = 0;
                        this.soundLevelUp();
                        this.updateUpgradeMenuButtons();
                        this.upgradeMenuButtonsDiv.style.display = 'flex';
                        this.levelTransitionTimer = 60;
                        this.levelUpScoreThreshold += Math.floor(this.level * 2.5); // Increase threshold for next level
                    }

                    this.spawnEnemies(false);
                    this.spawnObstacles(false);
                    this.spawnBoss(false);

                    this.enemies = this.enemies.filter(en => Math.hypot(en.x - this.player.x, en.y - this.player.y) < this.DESPAWN_DISTANCE);
                    this.obstacles = this.obstacles.filter(ob => Math.hypot(ob.x - this.player.x, ob.y - this.player.y) < this.DESPAWN_DISTANCE);
                    this.powerups = this.powerups.filter(pw => Math.hypot(pw.x - this.player.x, pw.y - this.player.y) < this.DESPAWN_DISTANCE);
                    this.coins = this.coins.filter(c => Math.hypot(c.x - this.player.x, c.y - this.player.y) < this.DESPAWN_DISTANCE);
                }

                this.cameraX = this.player.x - this.GAME_VIEWPORT_WIDTH / 2;
                this.cameraY = this.player.y - this.GAME_VIEWPORT_HEIGHT / 2;

                this.ctx.save();
                this.ctx.translate(this.GAME_VIEWPORT_X_OFFSET - this.cameraX, this.GAME_VIEWPORT_Y_OFFSET - this.cameraY);
                this.applyShake();

                if(this.safeZone) {
                    this.ctx.fillStyle = "rgba(0,255,0,0.2)";
                    this.ctx.beginPath();
                    this.ctx.arc(this.safeZone.x, this.safeZone.y, this.safeZone.radius, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = "rgba(0,255,0,0.8)";
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                    this.ctx.font = "14px sans-serif";
                    this.ctx.fillStyle = "rgba(0,255,0,0.9)";
                    this.ctx.fillText("Safe Zone", this.safeZone.x - this.ctx.measureText("Safe Zone").width/2, this.safeZone.y);
                }

                this.ctx.fillStyle = "#444";
                this.ctx.fillRect(this.town.x, this.town.y, this.town.width, this.town.height);
                this.ctx.strokeStyle = "#fff";
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(this.town.x, this.town.y, this.town.width, this.town.height);
                this.ctx.font = "14px sans-serif";
                this.ctx.fillStyle = "#fff";
                this.ctx.fillText("Town", this.town.x + (this.town.width/2) - (this.ctx.measureText("Town").width/2), this.town.y + this.town.height/2);

                this.ctx.fillStyle = "#ff0";
                this.coins.forEach(c => {
                    this.ctx.beginPath();
                    this.ctx.arc(c.x, c.y, this.COIN_SIZE/2, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                this.ctx.fillStyle = "#888";
                this.obstacles.forEach(ob => {
                    this.ctx.beginPath();
                    this.ctx.arc(ob.x, ob.y, ob.size/2, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                this.enemies.forEach(en => {
                    this.ctx.fillStyle = (en.hitTimer > 0 && Math.floor(en.hitTimer / 2) % 2 === 0) ? this.enemyTypes[en.type].hitColor : this.enemyTypes[en.type].color;
                    this.ctx.beginPath();
                    this.ctx.arc(en.x, en.y, en.size/2, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.drawHealthBar(en.x - 10, en.y - en.size/2 - 5, 20, 3, en.h, en.maxH, "#f00");
                });

                if(this.boss) {
                    this.ctx.fillStyle = (this.boss.hitTimer > 0 && Math.floor(this.boss.hitTimer / 2) % 2 === 0) ? "#fff" : "#f0f";
                    this.ctx.beginPath();
                    this.ctx.arc(this.boss.x, this.boss.y, this.boss.size/2, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.drawHealthBar(this.boss.x - 20, this.boss.y - this.boss.size/2 - 10, 40, 5, this.boss.h, this.boss.maxH, "#f0f");
                }

                this.powerups.forEach(pw => {
                    this.ctx.fillStyle = "#00f";
                    let label = "";
                    if (pw.type === "inv") { this.ctx.fillStyle = "#0ff"; label = "I"; }
                    else if (pw.type === "speed") { this.ctx.fillStyle = "#f00"; label = "S"; }
                    else if (pw.type === "shield") { this.ctx.fillStyle = "#ff0"; label = "D"; }
                    else if (pw.type === "freeze") { this.ctx.fillStyle = "#00ffff"; label = "F"; }
                    else if (pw.type === "double") { this.ctx.fillStyle = "#ff8c00"; label = "2X"; }
                    else if (pw.type === "health") { this.ctx.fillStyle = "#0f0"; label = "H"; }
                    else if (pw.type === "bomb") { this.ctx.fillStyle = "#800080"; label = "B"; }
                    this.ctx.beginPath();
                    this.ctx.arc(pw.x, pw.y, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "bold 10px Arial";
                    this.ctx.fillText(label, pw.x - this.ctx.measureText(label).width/2, pw.y + 4);
                });

                this.ctx.fillStyle = "#fff";
                this.bullets.forEach(b => { this.ctx.fillRect(b.x, b.y, this.BULLET_SIZE, this.BULLET_SIZE); });

                this.ctx.fillStyle = "#ff8800";
                this.bossBullets.forEach(b => { this.ctx.fillRect(b.x, b.y, 4, 4); });

                this.drawDebris();

                // Player drawing with glow effect, updated colors and stroke
                this.ctx.save();
                this.ctx.shadowBlur = 10; // Apply blur for glow effect
                this.ctx.shadowColor = (this.player.hitTimer > 0 && Math.floor(this.player.hitTimer / 2) % 2 === 0) ? "#f00" : (this.invincible ? "#0ff" : "#FFFFFF");
                this.ctx.fillStyle = (this.player.hitTimer > 0 && Math.floor(this.player.hitTimer / 2) % 2 === 0) ? "#f00" : (this.invincible ? "#0ff" : "#FFFFFF"); // Changed default to pure white
                this.ctx.beginPath();
                this.ctx.arc(this.GAME_VIEWPORT_WIDTH / 2, this.GAME_VIEWPORT_HEIGHT / 2, this.PLAYER_SIZE/2, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0; // Reset shadow for stroke
                this.ctx.strokeStyle = "#fff";
                this.ctx.lineWidth = 4; // Increased stroke width
                this.ctx.stroke();
                this.ctx.restore();


                if(this.shieldActive) {
                    this.ctx.strokeStyle = "#ff0";
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(this.GAME_VIEWPORT_WIDTH / 2, this.GAME_VIEWPORT_HEIGHT / 2, this.PLAYER_SIZE/2 + 4, 0, Math.PI * 2);
                    this.ctx.stroke();
                }

                this.drawParticles(); // Draw particles after they are updated
                this.updateAndDrawDashParticles();

                this.ctx.restore();

                this.ctx.fillStyle = "#fff";
                this.ctx.font = "12px sans-serif";
                this.ctx.fillText("Score: " + this.score, 5, 12);
                this.ctx.fillText("Lives: " + this.lives, 5, 24);
                this.ctx.fillText("Level: " + this.level, 5, 36);

                this.ctx.fillText("Health:", 5, 50);
                this.drawHealthBar(50, 42, 100, 10, this.player.h, this.player.maxH, "#0f0");

                this.ctx.fillText("Shoot CD: " + (this.shootTimer/60).toFixed(1), 5, 68);
                this.ctx.fillText("Special CD: " + (this.specialTimer/60).toFixed(1), 5, 80);
                this.ctx.fillText("Dash CD: " + (this.dashTimer/60).toFixed(1), 5, 92);
                this.ctx.fillText("High Score: " + this.highScore, 5, 104);

                let hudYOffset = 116;
                if(this.invincible) { this.ctx.fillText("Invincible: " + (this.invTimer/60).toFixed(1) + "s", 5, hudYOffset); hudYOffset += 12; }
                if(this.speedBoostTimer > 0) { this.ctx.fillText("Speed: x" + this.playerSpeedBoost + " (" + (this.speedBoostTimer/60).toFixed(1) + "s)", 5, hudYOffset); hudYOffset += 12; }
                if(this.shieldActive) { this.ctx.fillText("Shield: " + (this.shieldTimer/60).toFixed(1) + "s", 5, hudYOffset); hudYOffset += 12; }
                if(this.freezeTimer > 0) { this.ctx.fillText("Freeze: " + (this.freezeTimer/60).toFixed(1) + "s", 5, hudYOffset); hudYOffset += 12; }
                if(this.doubleScoreActive) { this.ctx.fillText("Double Score: " + (this.doubleScoreTimer/60).toFixed(1) + "s", 5, hudYOffset); hudYOffset += 12; }
                if(this.comboCount > 1) { this.ctx.fillText("Combo: x" + this.comboCount, 5, hudYOffset); hudYOffset += 12; }

                this.ctx.fillStyle = "#0f0";
                this.ctx.fillRect(5, hudYOffset + 5, (this.energy/this.MAX_ENERGY)*100, 8);
                this.ctx.strokeStyle = "#fff";
                this.ctx.strokeRect(5, hudYOffset + 5, 100, 8);
                this.ctx.fillText("Energy", 110, hudYOffset + 13);

                if(this.levelTransitionTimer > 0 && !this.upgradeMenuActive) {
                    this.ctx.font = "20px sans-serif";
                    this.ctx.fillText("Level Up!", this.CANVAS_WIDTH/2 - this.ctx.measureText("Level Up!").width/2, this.CANVAS_HEIGHT/2 - 50);
                }

                if(this.gameState === "paused") {
                    this.ctx.font = "24px sans-serif";
                    this.ctx.fillStyle = "#fff";
                    this.ctx.fillText("PAUSED", this.CANVAS_WIDTH/2 - this.ctx.measureText("PAUSED").width/2, this.CANVAS_HEIGHT/2);
                    this.ctx.font = "16px sans-serif";
                    this.ctx.fillText("Press 'P' or Pause button to Resume", this.CANVAS_WIDTH/2 - this.ctx.measureText("Press 'P' or Pause button to Resume").width/2, this.CANVAS_HEIGHT/2 + 30);
                }
                if(this.upgradeMenuActive) {
                    this.upgradeMenuButtonsDiv.style.display = 'flex';
                } else {
                    this.upgradeMenuButtonsDiv.style.display = 'none';
                }

                if(this.gameState === "gameover") {
                    this.ctx.font = "30px sans-serif";
                    this.ctx.fillStyle = "#f00";
                    this.ctx.fillText("GAME OVER", this.CANVAS_WIDTH/2 - this.ctx.measureText("GAME OVER").width/2, this.CANVAS_HEIGHT/2 - 20);
                    this.ctx.font = "18px sans-serif";
                    this.ctx.fillStyle = "#fff";
                    this.ctx.fillText("Score: " + this.score, this.CANVAS_WIDTH/2 - this.ctx.measureText("Score: " + this.score).width/2, this.CANVAS_HEIGHT/2 + 20);
                    this.ctx.fillText("High Score: " + this.highScore, this.CANVAS_WIDTH/2 - this.ctx.measureText("High Score: " + this.highScore).width/2, this.CANVAS_HEIGHT/2 + 40);
                    this.ctx.fillText("Press 'R' or Tap to Restart", this.CANVAS_WIDTH/2 - this.ctx.measureText("Press 'R' or Tap to Restart").width/2, this.CANVAS_HEIGHT/2 + 70);
                }
                if(this.gameState === "start") {
                    this.ctx.font = "24px sans-serif";
                    this.ctx.fillStyle = "#fff";
                    this.ctx.fillText("Press 'Enter' or Tap to Start", this.CANVAS_WIDTH/2 - this.ctx.measureText("Press 'Enter' or Tap to Start").width/2, this.CANVAS_HEIGHT/2);
                    this.ctx.font = "16px sans-serif";
                    this.ctx.fillText("Move with Joystick (Left) or WASD/Arrow Keys", this.CANVAS_WIDTH/2 - this.ctx.measureText("Move with Joystick (Left) or WASD/Arrow Keys").width/2, this.CANVAS_HEIGHT/2 + 30);
                    this.ctx.fillText("Collect coins, defeat enemies, survive!", this.CANVAS_WIDTH/2 - this.ctx.measureText("Collect coins, defeat enemies, survive!").width/2, this.CANVAS_HEIGHT/2 + 50);
                }

                this.drawMinimap();
                this.coins.forEach(c => this.drawIndicator(c.x, c.y, "#ff0", "Coin"));
                if (this.boss) {
                    this.drawIndicator(this.boss.x, this.boss.y, "#f0f", "Boss");
                }
                this.drawScorePopups(); // Draw score popups after they are updated

                requestAnimationFrame(this.loop.bind(this));
            }

            /**
             * Starts the game loop.
             */
            start() {
                this.loop();
            }
        }

        // Initialize and start the game when the window loads
        window.onload = function() {
            const game = new Game();
            game.init();
            game.start();

            // Handle window resizing to make canvas responsive
            window.addEventListener('resize', () => {
                // This example keeps the canvas fixed size, but adjusts its display via CSS.
                // For a truly dynamic canvas, you would update canvas.width and canvas.height here
                // and then re-render all elements proportionally.
            });
        };
    </script>
</body>
</html>
