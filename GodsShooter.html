<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Divine Shooter: GANESH v5.0 â€“ Mobile Ultimate Edition</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            justify-content: flex-start; /* Align content to the top */
            align-items: center; /* Center horizontally */
            min-height: 100vh; /* Ensure body takes full viewport height */
            font-family: 'Inter', sans-serif; /* Using Inter font */
        }
        canvas {
            display: block;
            background: #1a1a1a;
            touch-action: none; /* Prevents default browser touch gestures */
            border-radius: 10px; /* Rounded corners for the canvas */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* Glowing border */
            width: 340px; /* Fixed width */
            height: 340px; /* Fixed height as requested */
            margin-top: 20px; /* Small margin from the top */
        }

        /* Overlay for Start Button and Full Leaderboard */
        #main-ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10; /* Above canvas, below tutorial */
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent background */
            display: none; /* Hidden by default */
        }
        #main-ui-overlay button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.4);
            transition: background-color 0.3s ease, transform 0.2s ease;
            position: relative;
            overflow: hidden;
            margin-bottom: 10px; /* Space between button and leaderboard */
        }
        #main-ui-overlay button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #main-ui-overlay button:active::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: width 0.4s ease-out, height 0.4s ease-out, opacity 0.4s ease-out;
        }
        #main-ui-overlay button:active::before {
            width: 200%;
            height: 200%;
            opacity: 1;
        }

        #main-ui-overlay ul {
            list-style: none;
            padding: 0;
            margin: 0;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 10px 20px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            color: #fff;
            font-family: 'Inter', sans-serif;
            font-size: 16px;
        }
        #main-ui-overlay ul li {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        #main-ui-overlay ul li:last-child {
            border-bottom: none;
        }

        /* Tutorial overlay styling */
        #tutorialOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-family: 'Inter', sans-serif;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        #tutorialOverlay h2 {
            font-size: 1.3em; /* Adjusted for smaller screen */
            margin-bottom: 13px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        #tutorialOverlay p {
            font-size: 0.8em; /* Adjusted for smaller screen */
            margin-bottom: 10px;
            line-height: 1.2; /* Adjusted for smaller screen */
            max-width: 300px; /* Constrain width for smaller screen */
        }
        #tutorialOverlay button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px; /* Adjusted for smaller screen */
            font-size: 16px; /* Adjusted for smaller screen */
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px; /* Adjusted for smaller screen */
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.4);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        #tutorialOverlay button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #tutorialOverlay button:active {
            transform: translateY(1px);
        }

        /* Divine Blast Button */
        #divineBlastBtn {
            position: absolute;
            bottom: 20px; /* Adjust as needed */
            right: 20px; /* Adjust as needed */
            background-color: #8a2be2; /* Purple color */
            color: white;
            border: none;
            padding: 10px 15px;
            font-size: 14px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
            transition: background-color 0.3s ease, transform 0.2s ease;
            z-index: 10;
            display: none; /* Hidden by default, shown when game starts */
        }
        #divineBlastBtn:hover {
            background-color: #6a00b3;
            transform: translateY(-2px);
        }
        #divineBlastBtn:active {
            transform: translateY(1px);
        }
        #divineBlastBtn.disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Pause Button */
        #pauseBtn {
            position: absolute;
            top: 20px; /* Adjust as needed */
            right: 20px; /* Adjust as needed */
            background-color: #ffc107; /* Yellow color */
            color: #333;
            border: none;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4);
            transition: background-color 0.3s ease, transform 0.2s ease;
            z-index: 10;
            display: none; /* Hidden by default, shown when game starts */
        }
        #pauseBtn:hover {
            background-color: #e0a800;
            transform: translateY(-2px);
        }
        #pauseBtn:active {
            transform: translateY(1px);
        }
    </style>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="tutorialOverlay">
        <h2>Welcome to Divine Shooter: GANESH v5.0!</h2>
        <p>Protect the universe from rogue divinities!</p>
        <p><strong>Desktop Controls:</strong></p>
        <p>Use <strong>WASD</strong> or <strong>Arrow Keys</strong> to move.</p>
        <p>Your bullets will **auto-fire** towards your **mouse cursor**.</p>
        <p>Press <strong>P</strong> to pause/unpause the game.</p>
        <p><strong>Mobile Controls:</strong></p>
        <p><strong>Drag your finger on the left side of the screen</strong> to move.</p>
        <p><strong>Drag your finger on the right side of the screen</strong> to control **auto-fire direction**.</p>
        <p><strong>Two-finger tap anywhere</strong> to activate **Divine Blast**!</p>
        <p>Tap the **Pause button** on the top-right to pause/unpause.</p>
        <button id="closeTutorialBtn">Got It! Start Game</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="main-ui-overlay">
        <button id="startBtn">Start Game</button>
        <button id="soundToggleBtn">Start Sound</button> <!-- New Sound Toggle Button -->
        <ul id="lbListEl"></ul>
    </div>

    <button id="divineBlastBtn">Divine Blast (0)</button> <!-- Divine Blast Button -->
    <button id="pauseBtn">Pause</button> <!-- Pause Button -->

    <script>
        // Consolidated utility functions.
        const Utils = {
            distance: (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1),
            angleBetween: (x1, y1, x2, y2) => Math.atan2(y2 - y1, x2 - x1),
            pointToLineDistance: (px, py, x1, y1, x2, y2) => {
                const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                let param = len_sq !== 0 ? dot / len_sq : -1;
                let xx, yy;
                if (param < 0) { xx = x1; yy = y1; }
                else if (param > 1) { xx = x2; yy = y2; }
                else { xx = x1 + param * C; yy = y1 + param * D; }
                return Utils.distance(px, py, xx, yy);
            }
        };

        // Configuration for game constants.
        const config = {
            canvas: { width: 340, height: 340 }, // Fixed size as requested
            player: { size: 7.5, acceleration: 300, friction: 0.9, maxSpeed: 100, color: "#00ff00", name: "GANESH", level: 1 }, // Adjusted player size/speed for smaller canvas
            bullet: { size: 1.5, speed: 175, lifetime: 1000, color: "#ffffff", count: 1 }, // Added bullet count
            divine: {
                types: ["Loki", "Thor", "Buddha", "Sun", "Hermes", "Zeus", "Odin", "Ra", "Anubis", "Shiva"], // Added Shiva
                boss: "Boss",
                baseSize: 10, // Adjusted base enemy size
                vanishInterval: 2000,
                vanishDuration: 500,
                lightningDelay: 1200,
                circleGrowth: 20, // Adjusted circle growth
                sunHits: 3,
                shivaProjectileSize: 5, // Shiva projectile size
                shivaProjectileSpeed: 100, // Shiva projectile speed
                shivaTeleportInterval: 2500 // Shiva teleport interval
            },
            enemy: { spawnInterval: 2000, baseSpeed: 30, speedIncrease: 2, maxSpeed: 50 }, // Adjusted enemy speed
            boss: { color: "#ff00ff", size: 17.5, health: 5, speed: 17.5 }, // Adjusted boss size/speed
            particles: { count: 15, size: 1, lifetime: 500, colors: ["#ff4444", "#ffcc00", "#00aaff"] }, // Adjusted particle size/count
            levelUpScore: 750, // Adjusted level up score
            continueCost: 350, // Adjusted continue cost
            powerUpSpawnInterval: 7000, // Adjusted power-up spawn interval
            divineBlast: { cooldown: 5000, maxCharges: 3, radius: 75, damage: 2 }, // Divine Blast properties
            autoShoot: { enabled: true, interval: 200 } // Auto-shoot properties - ENABLED BY DEFAULT
        };

        // Canvas setup.
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        function resizeCanvas() {
            // Set canvas dimensions explicitly to the fixed size
            canvas.width = config.canvas.width;
            canvas.height = config.canvas.height;
        }
        resizeCanvas();
        // No need to listen for window resize if fixed size
        // window.addEventListener("resize", resizeCanvas);

        // Web Audio API context
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Custom Sound class using Web Audio API
        class Sound {
            constructor(frequency, duration, type = 'sine', initialVolume = 0) { // Default initialVolume to 0
                this.frequency = frequency;
                this.duration = duration;
                this.type = type;
                this.initialVolume = initialVolume; // Store the desired volume
                this.currentVolume = initialVolume; // Current active volume
                this.oscillator = null;
                this.gainNode = null;
            }

            play() {
                // If audio context is suspended, resume it (common for autoplay policies)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                if (this.currentVolume === 0) return; // Don't play if muted

                const tempOscillator = audioContext.createOscillator();
                const tempGainNode = audioContext.createGain();

                tempOscillator.type = this.type;
                tempOscillator.frequency.setValueAtTime(this.frequency, audioContext.currentTime);
                tempGainNode.gain.setValueAtTime(this.currentVolume, audioContext.currentTime);

                tempOscillator.connect(tempGainNode);
                tempGainNode.connect(audioContext.destination);

                tempOscillator.start();
                tempOscillator.stop(audioContext.currentTime + this.duration);
            }

            // For continuous sounds like background music
            startContinuous() {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                if (this.oscillator) {
                    this.oscillator.stop();
                    this.oscillator.disconnect();
                }

                this.oscillator = audioContext.createOscillator();
                this.gainNode = audioContext.createGain();

                this.oscillator.type = this.type;
                this.oscillator.frequency.setValueAtTime(this.frequency, audioContext.currentTime);
                this.gainNode.gain.setValueAtTime(this.currentVolume, audioContext.currentTime); // Set initial volume

                this.oscillator.connect(this.gainNode);
                this.gainNode.connect(audioContext.destination);

                this.oscillator.start();
            }

            stopContinuous() {
                if (this.oscillator) {
                    this.oscillator.stop();
                    this.oscillator.disconnect();
                    this.oscillator = null;
                    this.gainNode = null;
                }
            }

            setVolume(volume) {
                this.currentVolume = volume; // Update current volume
                if (this.gainNode) {
                    this.gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                }
            }
        }

        // Audio assets using generated sounds (Web Audio API)
        // Initial volume is 0 (muted)
        const shootSound = new Sound(880, 0.05, 'sine', 0);
        const enemyHitSound = new Sound(440, 0.1, 'square', 0);
        const playerHitSound = new Sound(220, 0.2, 'sawtooth', 0);
        const backgroundMusic = new Sound(110, 1000, 'sine', 0); // Continuous, very low volume initially
        backgroundMusic.loop = true; // Loop property for continuous sound (handled manually with start/stop)

        // Global joysticks for mobile.
        let movementJoystick = { active: false, touchId: null, startX: 0, startY: 0, currentX: 0, currentY: 0, dx: 0, dy: 0 };
        let shootingJoystick = { active: false, touchId: null, startX: 0, startY: 0, currentX: 0, currentY: 0, dx: 0, dy: 0 };
        let tutorialVisible = true; // Set to true to show tutorial on first load
        let isMobileDevice = /Mobi|Android/i.test(navigator.userAgent); // Detect mobile device

        // UI elements.
        const startBtn = document.getElementById("startBtn");
        const soundToggleBtn = document.getElementById("soundToggleBtn"); // Get the new sound toggle button
        const lbListEl = document.getElementById("lbListEl");
        const tutorialOverlay = document.getElementById("tutorialOverlay");
        const closeTutorialBtn = document.getElementById("closeTutorialBtn");
        const mainUiOverlay = document.getElementById("main-ui-overlay"); // Get the new overlay div
        const divineBlastBtn = document.getElementById("divineBlastBtn"); // Divine Blast button
        const pauseBtn = document.getElementById("pauseBtn"); // Pause button

        /**
         * Provides haptic feedback (vibration) if the device supports it.
         * @param {number} duration The duration of the vibration in milliseconds.
         */
        function vibrate(duration) {
            if (navigator.vibrate) {
                navigator.vibrate(duration);
            }
        }

        // Starfield background.
        class Star {
            constructor() {
                this.x = Math.random() * config.canvas.width;
                this.y = Math.random() * config.canvas.height;
                this.radius = Math.random() * 1.5 + 0.5;
                this.speed = Math.random() * 0.5 + 0.2;
            }
            update(dt) {
                this.y += this.speed * dt * 20; // Adjusted speed for smaller canvas
                if (this.y > config.canvas.height) {
                    this.y = 0;
                    this.x = Math.random() * config.canvas.width;
                }
            }
            draw(ctx) {
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Particle class for explosion effects.
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * 2 * Math.PI;
                const speed = Math.random() * 50 + 25; // Adjusted speed for smaller canvas
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.size = config.particles.size;
                this.lifetime = config.particles.lifetime;
                this.created = performance.now();
                this.color = config.particles.colors[Math.floor(Math.random() * config.particles.colors.length)];
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
            draw(ctx) {
                const lifeProgress = (performance.now() - this.created) / this.lifetime;
                ctx.globalAlpha = Math.max(1 - lifeProgress, 0);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // PowerUp class.
        class PowerUp {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.size = 4; // Adjusted size (50% of 8)
            }
            update(dt) { }
            draw(ctx) {
                ctx.font = "4px Arial"; // Adjusted font size (50% of 8)
                ctx.textAlign = "center";
                let label = "";
                if (this.type === "extraLife") {
                    ctx.fillStyle = "#00ff00";
                    label = "â¤ï¸"; // Heart emoji for extra life
                } else if (this.type === "timeSlow") {
                    ctx.fillStyle = "#00ccff";
                    label = "â³"; // Hourglass emoji for time slow
                } else if (this.type === "speedBoost") {
                    ctx.fillStyle = "#ff00ff";
                    label = "âš¡"; // Lightning emoji for speed boost
                } else if (this.type === "shieldRecharge") { // New power-up
                    ctx.fillStyle = "#00ffff";
                    label = "ðŸ›¡ï¸"; // Shield emoji for shield recharge
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#fff";
                ctx.fillText(label, this.x, this.y + 1.5); // Adjusted text position (50% of 3)
            }
        }

        // Player class.
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.isHit = false; // New property for hit effect
                this.hitEffectEndTime = 0; // New property for hit effect duration
            }
            update(dt, keys) {
                let effectiveAccel = config.player.acceleration;
                if (game.speedBoostActive) { effectiveAccel *= 1.5; }
                if (keys["ArrowUp"] || keys["w"]) this.vy -= effectiveAccel * dt;
                if (keys["ArrowDown"] || keys["s"]) this.vy += effectiveAccel * dt;
                if (keys["ArrowLeft"] || keys["a"]) this.vx -= effectiveAccel * dt;
                if (keys["ArrowRight"] || keys["d"]) this.vx += effectiveAccel * dt;

                // Movement Joystick input
                if (movementJoystick.active) {
                    let mag = Math.hypot(movementJoystick.dx, movementJoystick.dy);
                    if (mag > 5) { // Dead zone for joystick, adjusted
                        let normX = movementJoystick.dx / mag;
                        let normY = movementJoystick.dy / mag;
                        // Scale joystick input to player acceleration
                        this.vx += normX * effectiveAccel * dt * 0.5;
                        this.vy += normY * effectiveAccel * dt * 0.5;
                    }
                }

                this.vx *= config.player.friction;
                this.vy *= config.player.friction;

                const speed = Math.hypot(this.vx, this.vy);
                if (speed > config.player.maxSpeed) {
                    const factor = config.player.maxSpeed / speed;
                    this.vx *= factor;
                    this.vy *= factor;
                }

                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Keep player within canvas bounds
                this.x = Math.max(config.player.size, Math.min(config.canvas.width - config.player.size, this.x));
                this.y = Math.max(config.player.size, Math.min(config.canvas.height - config.player.size, this.y));

                // Update hit effect
                if (this.isHit && performance.now() > this.hitEffectEndTime) {
                    this.isHit = false;
                }
            }
            draw(ctx) {
                if (game.playerPerks.invisibility) { ctx.globalAlpha = 0.3; }
                
                // Player hit effect: flash red
                if (this.isHit && !game.playerPerks.invisibility) { // Only show hit effect if not invisible
                    ctx.fillStyle = "rgba(255, 0, 0, 0.7)"; // Red flash
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, config.player.size * 1.2, 0, Math.PI * 2); // Slightly larger red circle
                    ctx.fill();
                }

                ctx.fillStyle = config.player.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, config.player.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#fff";
                ctx.textAlign = "center";
                ctx.font = "8px Arial"; // Adjusted font size
                ctx.fillText(config.player.name, this.x, this.y - config.player.size - 1.5); // Adjusted text position (50% of 3)

                // Draw shield if active
                if (game.playerPerks.shield && game.playerPerks.shieldDurability > 0) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, config.player.size + 1.5, 0, Math.PI * 2); // Adjusted shield size (50% of 3)
                    ctx.strokeStyle = `rgba(0, 200, 255, ${game.playerPerks.shieldDurability / game.playerPerks.initialShieldDurability})`;
                    ctx.lineWidth = 2; // Adjusted line width
                    ctx.stroke();
                    ctx.fillStyle = `rgba(0, 200, 255, ${game.playerPerks.shieldDurability / game.playerPerks.initialShieldDurability * 0.2})`;
                    ctx.fill();
                }

                ctx.globalAlpha = 1;
            }
        }

        // Bullet class.
        class Bullet {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = config.bullet.speed;
                this.size = config.bullet.size;
                this.lifetime = 1000; // Bullet lifetime
                this.created = performance.now();
            }
            update(dt) {
                this.x += Math.cos(this.angle) * this.speed * dt;
                this.y += Math.sin(this.angle) * this.speed * dt;
            }
            draw(ctx) {
                ctx.fillStyle = config.bullet.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // MagicBullet class (homing bullet).
        class MagicBullet extends Bullet {
            constructor(x, y, angle, target) {
                super(x, y, angle);
                this.homing = true;
                this.target = target;
                this.size = config.bullet.size * 1.5; // Larger size for magic bullet
                this.color = "#ff00ff"; // Distinct color
            }
            update(dt) {
                // If target exists and is alive, home in on it
                if (this.target && this.target.hp > 0) {
                    let desiredAngle = Utils.angleBetween(this.x, this.y, this.target.x, this.target.y);
                    let angleDiff = desiredAngle - this.angle;
                    // Normalize angle difference to be between -PI and PI
                    angleDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                    this.angle += angleDiff * dt * 3; // Homing speed
                } else {
                    // If target is gone or no target, find the nearest enemy
                    let nearest = null;
                    let nearestDist = Infinity;
                    for (let enemy of game.enemies) {
                        let d = Utils.distance(this.x, this.y, enemy.x, enemy.y);
                        if (d < nearestDist) { nearestDist = d; nearest = enemy; }
                    }
                    this.target = nearest; // Set new target
                }
                super.update(dt); // Move bullet
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                // Add a small trail effect
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(this.x - Math.cos(this.angle) * this.size, this.y - Math.sin(this.angle) * this.size, this.size * 0.7, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Shiva's Projectile
        class ShivaProjectile {
            constructor(x, y, targetX, targetY) {
                this.x = x;
                this.y = y;
                this.size = config.divine.shivaProjectileSize;
                this.speed = config.divine.shivaProjectileSpeed;
                this.angle = Utils.angleBetween(x, y, targetX, targetY);
                this.lifetime = 2000; // Projectile disappears after a while
                this.created = performance.now();
            }

            update(dt) {
                this.x += Math.cos(this.angle) * this.speed * dt;
                this.y += Math.sin(this.angle) * this.speed * dt;
            }

            draw(ctx) {
                ctx.fillStyle = "#8a2be2"; // Purple color for Shiva's projectile
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // Enemy class with behavior determined by type.
        class Enemy {
            constructor(type, game) {
                this.game = game;
                this.type = type;
                this.size = config.divine.baseSize;
                this.visible = true;
                this.state = {};
                this.projectiles = []; // For Shiva's projectiles

                // Set defaults for health and speed based on type and level.
                if (game.level % 10 === 0 || type === config.divine.boss) {
                    this.type = config.divine.boss;
                    this.hp = config.boss.health + Math.floor(game.level / 5); // Boss health scales with level
                    this.maxHp = this.hp;
                    this.size = config.boss.size;
                    this.speed = config.boss.speed + Math.floor(game.level / 10); // Boss speed scales
                } else {
                    let computedSpeed = config.enemy.baseSpeed + game.level * config.enemy.speedIncrease;
                    this.speed = Math.min(computedSpeed, config.enemy.maxSpeed);
                    let baseHealth = (type === "Sun") ? config.divine.sunHits : 1;
                    this.hp = Math.ceil(baseHealth * (1 + game.level / 5)); // Enemy health scales with level
                    this.maxHp = this.hp;
                }

                // Add baseHit property â€“ by default it is 1 but scales with level;
                // for "Sun" type enemies, the scaling factor is config.divine.sunHits.
                let baseHitFactor = (this.type === "Sun") ? config.divine.sunHits : 1;
                this.baseHit = Math.ceil(baseHitFactor * (1 + game.level / 5));
                this.spawn(); // Call spawn method after properties are set
            }

            // Spawn method moved inside the class definition
            spawn() {
                // Spawn logic for different enemy types
                if (this.type === "Buddha") {
                    // Buddha spawns near player, but not too close
                    const minDistance = 75; // Adjusted min distance
                    let angle = Math.random() * Math.PI * 2;
                    let dist = minDistance + Math.random() * (Math.min(config.canvas.width, config.canvas.height) / 3);
                    this.x = game.player.x + Math.cos(angle) * dist;
                    this.y = game.player.y + Math.sin(angle) * dist;
                } else if (["Loki", "Thor", config.divine.boss, "Anubis", "Shiva"].includes(this.type)) { // Added Shiva
                    // These types spawn from edges, ensuring they are fully inside
                    const side = Math.floor(Math.random() * 4);
                    if (side === 0) { // Left edge
                        this.x = this.size;
                        this.y = Math.random() * (config.canvas.height - 2 * this.size) + this.size;
                    } else if (side === 1) { // Right edge
                        this.x = config.canvas.width - this.size;
                        this.y = Math.random() * (config.canvas.height - 2 * this.size) + this.size;
                    } else if (side === 2) { // Top edge
                        this.x = Math.random() * (config.canvas.width - 2 * this.size) + this.size;
                        this.y = this.size;
                    } else { // Bottom edge
                        this.x = Math.random() * (config.canvas.width - 2 * this.size) + this.size;
                        this.y = config.canvas.height - this.size;
                    }
                } else {
                    // Default random spawn anywhere, ensuring they are fully inside
                    this.x = Math.random() * (config.canvas.width - 2 * this.size) + this.size;
                    this.y = Math.random() * (config.canvas.height - 2 * this.size) + this.size;
                }

                // Initialize type-specific states.
                if (this.type === "Loki") {
                    this.state.lastVanish = performance.now();
                    this.state.vanishInterval = (game.level >= 10) ? 1500 : config.divine.vanishInterval; // Faster vanish at higher levels
                    this.state.vanishDuration = (game.level >= 10) ? 200 : config.divine.vanishDuration; // Shorter vanish duration
                } else if (this.type === "Thor") {
                    this.state.attackDelay = config.divine.lightningDelay;
                    this.state.attacking = false;
                } else if (this.type === "Buddha") {
                    this.state.circleRadius = 0;
                    this.state.circleGrowth = config.divine.circleGrowth * (1 + game.level / 10); // Faster growth at higher levels
                } else if (this.type === "Hermes") {
                    this.speed *= 1.5; // Hermes is naturally faster
                } else if (this.type === "Zeus") {
                    this.state.attacking = false;
                    this.state.attackInterval = 3000 - (game.level * 50); // Zeus attacks faster at higher levels
                    if (this.state.attackInterval < 1000) this.state.attackInterval = 1000;
                    this.state.lastAttack = performance.now();
                } else if (this.type === "Odin") {
                    this.baseX = this.x;
                    this.state.shieldActive = false;
                    this.state.lastShield = performance.now() - 3000; // Allow shield from start
                    this.state.shieldDuration = 2000 - (game.level * 20); // Shorter shield duration at higher levels
                    if (this.state.shieldDuration < 500) this.state.shieldDuration = 500;
                } else if (this.type === "Ra") {
                    this.state.circleRadius = 0;
                    this.state.circleGrowth = config.divine.circleGrowth * (1 + game.level / 10);
                    this.state.lastFlare = performance.now();
                    this.state.flareActive = false;
                    this.state.flareInterval = 3000 - (game.level * 50);
                    if (this.state.flareInterval < 1000) this.state.flareInterval = 1000;
                } else if (this.type === "Anubis") {
                    this.state.lastTeleport = performance.now();
                    this.state.teleportInterval = 1600 - (game.level * 30); // Anubis teleports faster
                    if (this.state.teleportInterval < 500) this.state.teleportInterval = 500;
                } else if (this.type === "Shiva") { // Shiva specific state
                    this.state.lastTeleport = performance.now();
                    this.state.teleportInterval = config.divine.shivaTeleportInterval;
                    this.state.lastProjectileFire = performance.now();
                    this.state.projectileFireInterval = 1000; // Shiva fires every 1 second after teleport
                }
            }
            update(dt) {
                const now = performance.now();
                let effectiveDt = dt;
                if (game.slowTimeActive) { effectiveDt = dt * 0.5; } // Enemies are affected by slow time

                switch (this.type) {
                    case "Loki": this.updateLoki(effectiveDt); break;
                    case "Thor": this.updateThor(effectiveDt); break;
                    case "Buddha": this.updateBuddha(effectiveDt); break;
                    case "Sun": this.updateSun(effectiveDt); break;
                    case "Hermes": this.moveTowardsPlayer(effectiveDt); break;
                    case "Zeus": this.updateZeus(effectiveDt); break;
                    case "Odin": this.updateOdin(effectiveDt); break;
                    case "Ra": this.updateRa(effectiveDt); break;
                    case "Anubis": this.updateAnubis(effectiveDt); break;
                    case "Shiva": this.updateShiva(effectiveDt); break; // Shiva update
                    case config.divine.boss: this.updateBoss(effectiveDt); break;
                    default: this.moveTowardsPlayer(effectiveDt);
                }
                // Update Shiva's projectiles
                this.projectiles = this.projectiles.filter(p => {
                    p.update(effectiveDt);
                    return (now - p.created) < p.lifetime;
                });
            }
            updateLoki(dt) {
                if (performance.now() - this.state.lastVanish > this.state.vanishInterval) {
                    this.visible = false;
                    setTimeout(() => {
                        this.visible = true;
                        // Teleport to a random edge, ensuring it's fully inside
                        const side = Math.floor(Math.random() * 4);
                        if (side === 0) { // Left edge
                            this.x = this.size;
                            this.y = Math.random() * (config.canvas.height - 2 * this.size) + this.size;
                        } else if (side === 1) { // Right edge
                            this.x = config.canvas.width - this.size;
                            this.y = Math.random() * (config.canvas.height - 2 * this.size) + this.size;
                        } else if (side === 2) { // Top edge
                            this.x = Math.random() * (config.canvas.width - 2 * this.size) + this.size;
                            this.y = this.size;
                        } else { // Bottom edge
                            this.x = Math.random() * (config.canvas.width - 2 * this.size) + this.size;
                            this.y = config.canvas.height - this.size;
                        }
                        this.state.lastVanish = performance.now();
                    }, this.state.vanishDuration);
                }
                if (this.visible) { this.moveTowardsPlayer(dt); }
            }
            updateThor(dt) {
                const desiredDistance = 50; // Adjusted desired distance (50% of 100)
                const d = Utils.distance(this.x, this.y, game.player.x, game.player.y);
                if (d > desiredDistance) { this.moveTowardsPlayer(dt); }
                else if (!this.state.attacking) {
                    this.state.attacking = true;
                    this.state.chargeStart = performance.now();
                    setTimeout(() => {
                        const angle = Utils.angleBetween(this.x, this.y, game.player.x, game.player.y);
                        // Lightning strikes in a line towards the player's last known position
                        const lightningEndX = this.x + Math.cos(angle) * 75; // Adjusted lightning length (50% of 150)
                        const lightningEndY = this.y + Math.sin(angle) * 75;
                        const lineDist = Utils.pointToLineDistance(game.player.x, game.player.y, this.x, this.y, lightningEndX, lightningEndY);
                        if (lineDist < 7.5) { // Adjusted hit detection radius (50% of 15)
                            playerHitSound.play();
                            game.loseLife(this.baseHit);
                            game.player.isHit = true; // Trigger player hit effect
                            game.player.hitEffectEndTime = performance.now() + 200; // 200ms flash
                            vibrate(50); // Vibrate on player hit
                        }
                        this.state.attacking = false;
                    }, this.state.attackDelay);
                }
            }
            updateBuddha(dt) {
                this.state.circleRadius += this.state.circleGrowth * dt;
                // If the circle radius exceeds a certain size, reset it
                if (this.state.circleRadius > Math.max(config.canvas.width, config.canvas.height) * 0.7) {
                    this.state.circleRadius = 0;
                }
                // Check if player is on the circle's edge
                const diff = Math.abs(Utils.distance(this.x, this.y, game.player.x, game.player.y) - this.state.circleRadius);
                if (diff < 5) { // Player takes damage if close to the circle's edge, adjusted (50% of 10)
                    playerHitSound.play();
                    game.loseLife(this.baseHit);
                    game.player.isHit = true; // Trigger player hit effect
                    game.player.hitEffectEndTime = performance.now() + 200; // 200ms flash
                    vibrate(50); // Vibrate on player hit
                    this.state.circleRadius = 0; // Reset circle after hit
                }
            }
            updateSun(dt) {
                // Sun glows less as it takes damage
                this.glow = 1 - ((config.divine.sunHits - this.hp) / config.divine.sunHits);
            }
            updateZeus(dt) {
                const desiredDistance = 50; // Adjusted desired distance (50% of 100)
                let d = Utils.distance(this.x, this.y, game.player.x, game.player.y);
                if (d > desiredDistance) { this.moveTowardsPlayer(dt); }
                else if (!this.state.attacking && performance.now() - this.state.lastAttack >= this.state.attackInterval) {
                    this.state.attacking = true;
                    this.state.chargeStart = performance.now();
                    setTimeout(() => {
                        // Zeus strikes vertically at the targeted X position
                        if (Math.abs(game.player.x - this.state.attackX) < 12.5) { // Adjusted hit radius (50% of 25)
                            playerHitSound.play();
                            game.loseLife(this.baseHit);
                            game.player.isHit = true; // Trigger player hit effect
                            game.player.hitEffectEndTime = performance.now() + 200; // 200ms flash
                            vibrate(50); // Vibrate on player hit
                        }
                        this.state.attacking = false;
                        this.state.lastAttack = performance.now();
                    }, 750); // Adjusted charge time for Zeus's attack
                }
            }
            updateOdin(dt) {
                if (!this.state.shieldActive && (performance.now() - this.state.lastShield >= 3000)) {
                    this.state.shieldActive = true;
                    this.state.shieldStart = performance.now();
                }
                if (this.state.shieldActive) {
                    if (performance.now() - this.state.shieldStart >= this.state.shieldDuration) {
                        this.state.shieldActive = false;
                        this.state.lastShield = performance.now();
                    }
                }
                // Odin moves in a small sine wave pattern
                if (!this.baseX) { this.baseX = this.x; }
                this.x = this.baseX + 5 * Math.sin(performance.now() / 1000 * (1 + game.level / 20)); // Adjusted oscillation amplitude (50% of 10)
                this.moveTowardsPlayer(dt); // Still moves towards player
            }
            updateRa(dt) {
                this.state.circleRadius = (this.state.circleRadius || 0) + (this.state.circleGrowth || config.divine.circleGrowth) * dt;
                if (this.state.circleRadius > this.size * 3) { // Reset circle after it gets too big, adjusted
                    this.state.circleRadius = 0;
                }

                if (performance.now() - this.state.lastFlare >= this.state.flareInterval && !this.state.flareActive) {
                    this.state.flareActive = true;
                    this.state.flareStart = performance.now();
                }
                if (this.state.flareActive) {
                    if (performance.now() - this.state.flareStart < 250) { // Flare duration, adjusted
                        if (Utils.distance(this.x, this.y, game.player.x, game.player.y) < this.size + 5) { // If player is close during flare, adjusted (50% of 10)
                            playerHitSound.play();
                            game.loseLife(this.baseHit);
                            game.player.isHit = true; // Trigger player hit effect
                            game.player.hitEffectEndTime = performance.now() + 200; // 200ms flash
                            vibrate(50); // Vibrate on player hit
                        }
                    } else {
                        this.state.flareActive = false;
                        this.state.lastFlare = performance.now();
                    }
                }
                this.moveTowardsPlayer(dt); // Ra still moves towards player
            }
            updateAnubis(dt) {
                if (!this.state.lastTeleport) { this.state.lastTeleport = performance.now(); }
                if (performance.now() - this.state.lastTeleport >= this.state.teleportInterval) {
                    // Teleport to a random edge, ensuring it's fully inside
                    let edge = Math.floor(Math.random() * 4);
                    if (edge === 0) { // Left edge
                        this.x = this.size;
                        this.y = Math.random() * (config.canvas.height - 2 * this.size) + this.size;
                    } else if (edge === 1) { // Right edge
                        this.x = config.canvas.width - this.size;
                        this.y = Math.random() * (config.canvas.height - 2 * this.size) + this.size;
                    } else if (edge === 2) { // Top edge
                        this.x = Math.random() * (config.canvas.width - 2 * this.size) + this.size;
                        this.y = this.size;
                    } else { // Bottom edge
                        this.x = Math.random() * (config.canvas.width - 2 * this.size) + this.size;
                        this.y = config.canvas.height - this.size;
                    }
                    this.state.lastTeleport = performance.now();
                }
                this.moveTowardsPlayer(dt); // Anubis still moves towards player when not teleporting
            }
            updateShiva(dt) {
                const now = performance.now();
                if (now - this.state.lastTeleport > this.state.teleportInterval) {
                    // Teleport to a random position on the canvas, ensuring it's fully inside
                    this.x = Math.random() * (config.canvas.width - 2 * this.size) + this.size;
                    this.y = Math.random() * (config.canvas.height - 2 * this.size) + this.size;
                    this.state.lastTeleport = now;
                    this.state.lastProjectileFire = now; // Reset projectile fire timer after teleport
                }

                // Fire projectile after a delay from teleport
                if (now - this.state.lastProjectileFire > this.state.projectileFireInterval) {
                    this.projectiles.push(new ShivaProjectile(this.x, this.y, game.player.x, game.player.y));
                    this.state.lastProjectileFire = now;
                }
            }
            updateBoss(dt) {
                this.moveWithBounce(dt); // Boss moves and bounces off walls
                if (!this.state.attacking && Math.random() < 0.05 * dt * 60) { // Boss attacks randomly
                    this.state.attacking = true;
                    setTimeout(() => {
                        const angle = Utils.angleBetween(this.x, this.y, game.player.x, game.player.y);
                        const lightningEndX = this.x + Math.cos(angle) * 50; // Adjusted lightning length (50% of 100)
                        const lightningEndY = this.y + Math.sin(angle) * 50;
                        const lineDist = Utils.pointToLineDistance(game.player.x, game.player.y, this.x, this.y, lightningEndX, lightningEndY);
                        if (lineDist < 7.5) { // Adjusted hit detection radius (50% of 15)
                            playerHitSound.play();
                            game.loseLife(this.baseHit);
                            game.player.isHit = true; // Trigger player hit effect
                            game.player.hitEffectEndTime = performance.now() + 200; // 200ms flash
                            vibrate(50); // Vibrate on player hit
                        }
                        this.state.attacking = false;
                    }, 400); // Adjusted boss attack delay
                }
            }
            moveTowardsPlayer(dt) {
                const angle = Utils.angleBetween(this.x, this.y, game.player.x, game.player.y);
                this.x += Math.cos(angle) * this.speed * dt;
                this.y += Math.sin(angle) * this.speed * dt;

                // Keep enemy within canvas bounds
                this.x = Math.max(this.size, Math.min(config.canvas.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(config.canvas.height - this.size, this.y));
            }
            moveWithBounce(dt) {
                // Initial velocity for boss if not set
                if (this.vx === undefined) {
                    const angle = Math.random() * Math.PI * 2;
                    this.vx = Math.cos(angle) * this.speed;
                    this.vy = Math.sin(angle) * this.speed;
                }

                let newX = this.x + this.vx * dt;
                let newY = this.y + this.vy * dt;

                // Bounce off horizontal walls
                if (newX < this.size || newX > config.canvas.width - this.size) {
                    this.vx *= -1;
                    newX = this.x + this.vx * dt; // Re-calculate to prevent sticking
                }
                // Bounce off vertical walls
                if (newY < this.size || newY > config.canvas.height - this.size) {
                    this.vy *= -1;
                    newY = this.y + this.vy * dt; // Re-calculate to prevent sticking
                }
                this.x = newX;
                this.y = newY;
            }
            draw(ctx) {
                // Odin's shield
                if (this.type === "Odin" && this.state.shieldActive) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 2.5, 0, Math.PI * 2); // Adjusted shield size (50% of 5)
                    ctx.strokeStyle = "rgba(0,0,255,0.5)";
                    ctx.lineWidth = 2; // Keep line width same for visibility
                    ctx.stroke();
                }
                // Ra's flare aura
                if (this.type === "Ra" && this.state.flareActive) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2); // Adjusted flare size (50% of 10)
                    ctx.strokeStyle = "rgba(255,165,0,0.9)"; // Brighter color
                    ctx.lineWidth = 3; // Thicker line
                    ctx.stroke();
                }
                // Zeus charging indicator
                if (this.type === "Zeus" && this.state.attacking) {
                    ctx.fillStyle = "#ffff00";
                    ctx.font = "bold 8px Arial"; // Adjusted font size
                    ctx.textAlign = "center";
                    ctx.fillText("Charging...", this.x, this.y - this.size - 7.5); // Adjusted text position (50% of 15)
                    // Draw target line for Zeus's attack
                    ctx.strokeStyle = "rgba(255,255,0,0.8)"; // Brighter color
                    ctx.lineWidth = 2; // Thicker line
                    ctx.beginPath();
                    ctx.moveTo(this.state.attackX, 0);
                    ctx.lineTo(this.state.attackX, config.canvas.height);
                    ctx.stroke();
                }

                // Sun's glow effect
                if (this.type === "Sun") {
                    const glow = this.glow || 1;
                    ctx.fillStyle = `rgba(255,165,0,${glow})`;
                } else {
                    ctx.fillStyle = "#ff0000"; // Default enemy color
                }

                // Loki's invisibility
                if (!this.visible) ctx.globalAlpha = 0.5;

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Thor's attack countdown
                if (this.type === "Thor" && this.state.attacking) {
                    const remaining = Math.max(0, ((this.state.attackDelay || config.divine.lightningDelay) - (performance.now() - this.state.chargeStart)) / 1000).toFixed(1);
                    ctx.fillStyle = "#ffff00";
                    ctx.font = "bold 8px Arial"; // Adjusted font size
                    ctx.fillText("âš¡ " + remaining + "s", this.x, this.y - this.size - 5); // Adjusted text position (50% of 10)
                    // Draw lightning visual
                    const angle = Utils.angleBetween(this.x, this.y, game.player.x, game.player.y);
                    const lightningEndX = this.x + Math.cos(angle) * 75;
                    const lightningEndY = this.y + Math.sin(angle) * 75;
                    ctx.strokeStyle = "rgba(255,255,0,0.8)"; // Brighter color
                    ctx.lineWidth = 3; // Thicker line
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(lightningEndX, lightningEndY);
                    ctx.stroke();
                }
                // Buddha's expanding circle
                if (this.type === "Buddha") {
                    ctx.strokeStyle = "#ffcc00";
                    ctx.lineWidth = 2.5; // Thicker line
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.state.circleRadius || 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // Enemy type label
                ctx.fillStyle = "#fff";
                ctx.font = "bold 8px Arial"; // Adjusted font size
                ctx.textAlign = "center";
                ctx.fillText(this.type, this.x, this.y - this.size - 6); // Adjusted text position (50% of 12)

                // Health bar for enemies with more than 1 HP
                if (this.maxHp > 1) {
                    const barWidth = this.size * 1.5; // Adjusted bar width (proportional)
                    const barHeight = 1; // Adjusted bar height (50% of 2)
                    const barX = this.x - barWidth / 2;
                    const barY = this.y - this.size - 3.5; // Adjusted bar position (50% of 7)
                    ctx.fillStyle = "#555";
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    const healthWidth = (this.hp / this.maxHp) * barWidth;
                    ctx.fillStyle = "#0f0";
                    ctx.fillRect(barX, barY, healthWidth, barHeight);
                }

                // Draw Shiva's projectiles
                this.projectiles.forEach(p => p.draw(ctx));
            }
        }

        // Helper function for random spawn from edges.
        function getRandomSpawn() {
            // This function is now modified within the Enemy.spawn() method
            // to ensure enemies are spawned fully inside the canvas.
            // This placeholder is kept for clarity but its logic is integrated directly.
            return { x: 0, y: 0 }; // Placeholder
        }

        // Main Game class.
        class Game {
            constructor() {
                this.canvas = canvas;
                this.ctx = ctx;
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.scoreMultiplier = 1;
                this.player = new Player(config.canvas.width / 2, config.canvas.height / 2);
                this.bullets = [];
                this.enemies = [];
                this.powerUps = [];
                this.particles = [];
                this.stars = [];
                this.lastEnemySpawn = performance.now();
                this.lastPowerUpSpawn = performance.now();
                this.lastMagicBulletTime = performance.now();
                this.running = false;
                this.paused = false;
                this.lastKillTime = 0;
                this.comboCount = 0;
                this.playerPerks = {};
                this.shopOpen = false;
                this.upgradeOptions = [];
                this.slowTimeActive = false;
                this.speedBoostActive = false;
                this.isSoundOn = false; // Track sound state
                this.lastAutoShootTime = 0; // For auto-shoot cooldown

                // Divine Blast properties
                this.divineBlastCharges = 0;
                this.lastDivineBlastTime = 0;

                // For shield perk, store initial durability to calculate alpha
                this.playerPerks.initialShieldDurability = 5;

                for (let i = 0; i < 75; i++) { this.stars.push(new Star()); } // Adjusted stars for new canvas size
            }
            start() {
                this.reset();
                this.running = true;
                this.paused = false;
                lastTime = performance.now();
                // Background music control moved to soundToggleBtn
                divineBlastBtn.style.display = 'block'; // Show divine blast button
                pauseBtn.style.display = 'block'; // Show pause button
                this.updateDivineBlastUI();
                requestAnimationFrame(this.gameLoop.bind(this));
            }
            reset() {
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.scoreMultiplier = 1;
                this.player = new Player(config.canvas.width / 2, config.canvas.height / 2);
                this.bullets = [];
                this.enemies = [];
                this.powerUps = [];
                this.particles = [];
                this.lastEnemySpawn = performance.now();
                this.lastPowerUpSpawn = performance.now();
                this.lastMagicBulletTime = performance.now();
                this.comboCount = 0;
                this.lastKillTime = 0;
                this.playerPerks = {}; // Reset all perks
                this.playerPerks.initialShieldDurability = 5; // Reset initial shield durability
                this.shopOpen = false;
                this.slowTimeActive = false;
                this.speedBoostActive = false;
                this.divineBlastCharges = 0; // Reset divine blast charges
                this.lastDivineBlastTime = 0; // Reset divine blast cooldown
                config.bullet.count = 1; // Reset bullet count on game reset
                config.autoShoot.enabled = true; // Auto-shoot is now always enabled
                config.autoShoot.interval = 200; // Reset auto-shoot interval
                this.lastAutoShootTime = 0;
                // Do not reset isSoundOn here, it's controlled by the button
            }
            togglePause() {
                this.paused = !this.paused;
                if (this.paused) {
                    pauseBtn.textContent = "Resume";
                    backgroundMusic.stopContinuous(); // Pause music
                } else {
                    pauseBtn.textContent = "Pause";
                    if (this.isSoundOn) { // Resume music only if sound is generally on
                        backgroundMusic.startContinuous();
                        backgroundMusic.setVolume(0.3);
                    }
                    lastTime = performance.now(); // Reset lastTime to prevent large dt jump
                    requestAnimationFrame(this.gameLoop.bind(this)); // Resume game loop
                }
            }
            openShop() {
                this.shopOpen = true;
                this.paused = true; // Pause game when shop is open
                backgroundMusic.stopContinuous(); // Pause music when shop is open

                // Define possible upgrades with level-based scaling
                const allPossibleUpgrades = [
                    {
                        name: "Increase Bullet Speed",
                        cost: 50 + (this.level * 5),
                        effect: () => { config.bullet.speed *= (1.1 + this.level * 0.005); }
                    },
                    {
                        name: "Increase Player Speed",
                        cost: 50 + (this.level * 5),
                        effect: () => { config.player.maxSpeed += (10 + this.level * 0.5); }
                    },
                    {
                        name: "Improve Shield",
                        cost: 75 + (this.level * 7),
                        effect: () => {
                            this.playerPerks.initialShieldDurability += (1 + Math.floor(this.level / 5)); // More durability at higher levels
                            this.playerPerks.shield = true;
                            this.playerPerks.shieldDurability = this.playerPerks.initialShieldDurability;
                        }
                    },
                    {
                        name: "Boost Score Multiplier",
                        cost: 100 + (this.level * 10),
                        effect: () => { this.scoreMultiplier += (0.1 + this.level * 0.005); }
                    },
                    {
                        name: "Extra Life",
                        cost: 150 + (this.level * 15),
                        effect: () => { this.lives++; }
                    },
                    {
                        name: "Invisibility Perk",
                        cost: 125 + (this.level * 12),
                        effect: () => {
                            this.playerPerks.invisibility = true;
                            this.playerPerks.invisibilityDuration = 3000 + this.level * 100; // Longer duration
                            this.playerPerks.invisibilityStart = performance.now();
                        }
                    },
                    {
                        name: "Magic Bullets",
                        cost: 200 + (this.level * 20),
                        effect: () => { this.playerPerks.magicBullets = true; }
                    },
                    {
                        name: "Magnetic Field",
                        cost: 75 + (this.level * 7),
                        effect: () => { this.playerPerks.magnetic = true; }
                    },
                    {
                        name: "Divine Blast Charge", // Allows increasing charges if perk exists
                        cost: 250 + (this.level * 25),
                        effect: () => {
                            if (this.divineBlastCharges < config.divineBlast.maxCharges) {
                                this.divineBlastCharges++;
                            } else {
                                config.divineBlast.maxCharges++; // Increase max charges if already full
                                this.divineBlastCharges++;
                            }
                            this.updateDivineBlastUI();
                        }
                    },
                    {
                        name: "Bullet Barrage", // New upgrade
                        cost: 175 + (this.level * 15),
                        effect: () => { config.bullet.count++; } // Increase bullets fired per shot
                    },
                    // "Enable Auto Shoot" is removed as it's now default
                    {
                        name: "Increase Auto Shoot Rate",
                        cost: 75 + (this.level * 7),
                        effect: () => { config.autoShoot.interval = Math.max(50, config.autoShoot.interval - 25); } // Make it faster, min 50ms
                    }
                ];

                this.upgradeOptions = [];
                let numberOfOptions = 3;
                if (this.level >= 6 && this.level <= 10) {
                    numberOfOptions = 4;
                } else if (this.level > 10) {
                    numberOfOptions = 5;
                }

                // Create a temporary copy to pick from without modifying original
                let availableUpgrades = [...allPossibleUpgrades];

                // Select unique random upgrades
                while (this.upgradeOptions.length < numberOfOptions && availableUpgrades.length > 0) {
                    let randomIndex = Math.floor(Math.random() * availableUpgrades.length);
                    let upgrade = availableUpgrades[randomIndex];

                    // Special handling for "Increase Auto Shoot Rate": only offer if auto shoot is enabled (which it always is now)
                    // No need to check config.autoShoot.enabled here as it's always true.
                    // This check is now effectively just ensuring the upgrade is offered.
                    if (upgrade.name === "Increase Auto Shoot Rate" && config.autoShoot.interval <= 50) {
                        // Don't offer if already at max rate
                        availableUpgrades.splice(randomIndex, 1);
                        continue;
                    }

                    // Special handling for Divine Blast Charge: only offer if player has it or if it's the initial purchase
                    if (upgrade.name === "Divine Blast Charge" && !this.playerPerks.divineBlast && this.divineBlastCharges === 0) {
                         // This case means Divine Blast is offered as the initial perk purchase
                         this.playerPerks.divineBlast = true; // Mark that player has the perk
                    } else if (upgrade.name === "Divine Blast Charge" && !this.playerPerks.divineBlast) {
                         // If it's a charge upgrade and player doesn't have the perk yet, skip this option
                         availableUpgrades.splice(randomIndex, 1);
                         continue;
                    }

                    this.upgradeOptions.push(upgrade);
                    availableUpgrades.splice(randomIndex, 1); // Remove selected upgrade to ensure uniqueness
                }
            }
            processShopClick(x, y) {
                for (let option of this.upgradeOptions) {
                    // Check if click is within option bounds
                    if (x >= option.x && x <= option.x + option.width &&
                        y >= option.y && y <= option.y + option.height) {
                        if (this.score >= option.cost) {
                            option.effect();
                            this.score -= option.cost; // Deduct cost
                            this.shopOpen = false;
                            this.paused = false;
                            vibrate(100); // Vibrate on successful upgrade purchase
                            if (this.isSoundOn) { // Resume music only if sound is generally on
                                backgroundMusic.startContinuous();
                                backgroundMusic.setVolume(0.3);
                            }
                            lastTime = performance.now(); // Reset lastTime after shop close
                            requestAnimationFrame(this.gameLoop.bind(this)); // Resume game loop
                            break;
                        } else {
                            console.log("Not enough score for this upgrade!"); // Visual feedback could be added here
                        }
                    }
                }
            }
            update(dt, timestamp) {
                if (!this.paused && !this.shopOpen) {
                    const now = performance.now();

                    // Update stars, player, bullets, enemies, power-ups, and particles.
                    this.stars.forEach(star => star.update(dt));
                    this.player.update(dt, keysPressed);

                    let effectiveDt = dt;
                    if (this.slowTimeActive) {
                        effectiveDt = dt * 0.5; // Game elements move slower
                        if (now > this.slowTimeEnd) { this.slowTimeActive = false; }
                    }

                    this.bullets = this.bullets.filter(bullet => {
                        bullet.update(effectiveDt);
                        // Remove bullets that are too old or off-screen
                        return (timestamp - bullet.created) < bullet.lifetime &&
                            bullet.x > -10 && bullet.x < config.canvas.width + 10 &&
                            bullet.y > -10 && bullet.y < config.canvas.height + 10;
                    });

                    this.enemies.forEach(enemy => enemy.update(effectiveDt));
                    this.powerUps.forEach(pu => {
                        pu.update(effectiveDt);
                        // Magnetic perk pulls power-ups towards player
                        if (this.playerPerks.magnetic) {
                            let dx = this.player.x - pu.x;
                            let dy = this.player.y - pu.y;
                            let mag = Utils.distance(0, 0, dx, dy);
                            if (mag > 0) {
                                const magnetSpeed = 70; // Adjusted magnet speed
                                pu.x += (dx / mag) * magnetSpeed * dt;
                                pu.y += (dy / mag) * magnetSpeed * dt;
                            }
                        }
                    });

                    this.particles.forEach(p => p.update(dt));
                    this.particles = this.particles.filter(p => (timestamp - p.created) < p.lifetime);

                    // Deactivate speed boost if time is up
                    if (this.speedBoostActive && now > this.speedBoostEnd) { this.speedBoostActive = false; }

                    // Deactivate invisibility if time is up
                    if (this.playerPerks.invisibility) {
                        if (now > this.playerPerks.invisibilityStart + this.playerPerks.invisibilityDuration) {
                            delete this.playerPerks.invisibility;
                            delete this.playerPerks.invisibilityStart;
                            delete this.playerPerks.invisibilityDuration;
                        }
                    }

                    // Magic Bullet perk logic: auto-fire homing bullets at nearest enemy
                    if (this.playerPerks.magicBullets) {
                        // Fire a magic bullet every 1.2 seconds (or config.divine.lightningDelay)
                        if (now - this.lastMagicBulletTime > config.divine.lightningDelay / 2 && this.enemies.length > 0) {
                            let nearest = this.enemies[0];
                            let nearestDist = Utils.distance(this.player.x, this.player.y, nearest.x, nearest.y);
                            for (let enemy of this.enemies) {
                                let d = Utils.distance(this.player.x, this.player.y, enemy.x, enemy.y);
                                if (d < nearestDist) { nearestDist = d; nearest = enemy; }
                            }
                            const angle = Utils.angleBetween(this.player.x, this.player.y, nearest.x, nearest.y);
                            const mb = new MagicBullet(this.player.x, this.player.y, angle, nearest);
                            this.bullets.push(mb);
                            this.lastMagicBulletTime = now;
                        }
                    }

                    // Auto-shoot logic
                    if (config.autoShoot.enabled && now - this.lastAutoShootTime > config.autoShoot.interval) {
                        let targetX, targetY;
                        if (isMobileDevice) {
                            // Use shooting joystick direction if active, otherwise default to straight up
                            if (shootingJoystick.active && (shootingJoystick.dx !== 0 || shootingJoystick.dy !== 0)) {
                                targetX = this.player.x + shootingJoystick.dx;
                                targetY = this.player.y + shootingJoystick.dy;
                            } else {
                                // Default to shooting straight up if no shooting joystick input
                                targetX = this.player.x;
                                targetY = this.player.y - 10;
                            }
                        } else { // Desktop
                            targetX = mouseX;
                            targetY = mouseY;
                        }
                        // Fire multiple bullets if config.bullet.count is > 1
                        for (let i = 0; i < config.bullet.count; i++) {
                            const spreadAngle = (i - (config.bullet.count - 1) / 2) * (Math.PI / 30); // 6-degree spread per bullet
                            const angle = Utils.angleBetween(this.player.x, this.player.y, targetX, targetY) + spreadAngle;
                            this.bullets.push(new Bullet(this.player.x, this.player.y, angle));
                        }
                        if (this.isSoundOn) { // Only play sound if sound is enabled
                            shootSound.play();
                        }
                        this.lastAutoShootTime = now;
                    }

                    this.checkCollisions();
                    this.updateLevel();

                    // Enemy spawning
                    if (timestamp - this.lastEnemySpawn > config.enemy.spawnInterval) {
                        this.spawnEnemy();
                        this.lastEnemySpawn = timestamp;
                    }

                    // Power-up spawning
                    if (timestamp - this.lastPowerUpSpawn > config.powerUpSpawnInterval) {
                        this.spawnPowerUp();
                        this.lastPowerUpSpawn = timestamp;
                    }

                    // Divine Blast Cooldown
                    if (this.divineBlastCharges < config.divineBlast.maxCharges && now - this.lastDivineBlastTime > config.divineBlast.cooldown) {
                        this.divineBlastCharges++;
                        this.lastDivineBlastTime = now;
                        this.updateDivineBlastUI();
                    }
                }
            }
            draw() {
                // Clear and redraw canvas.
                this.ctx.clearRect(0, 0, config.canvas.width, config.canvas.height);
                this.stars.forEach(star => star.draw(ctx));

                // TODO: For more complex games, consider optimizing drawing for mobile by pre-rendering
                // static elements to off-screen canvases to reduce CPU load during the main game loop.

                // Draw game UI if not in shop or paused
                if (!this.shopOpen && !this.paused) {
                    let expProgress = (this.score % config.levelUpScore) / config.levelUpScore;
                    ctx.fillStyle = "#333";
                    ctx.fillRect(0, 0, config.canvas.width, 10); // Experience bar background, adjusted height
                    ctx.fillStyle = "#0f0";
                    ctx.fillRect(0, 0, config.canvas.width * expProgress, 10); // Experience bar fill, adjusted height

                    ctx.fillStyle = "#fff";
                    // TODO: Implement adaptive font sizing for mobile devices based on canvas/viewport dimensions
                    // For example: ctx.font = `${Math.max(8, config.canvas.width * 0.03)}px 'Inter', sans-serif`;
                    ctx.font = "10px 'Inter', sans-serif"; // Adjusted font size
                    ctx.textAlign = "center";
                    ctx.fillText(`Score: ${this.score}   Level: ${this.level}`, config.canvas.width / 2, 25); // Adjusted Y position

                    // Draw lives as hearts
                    ctx.textAlign = "left";
                    for (let i = 0; i < this.lives; i++) {
                        ctx.fillText("â¤ï¸", 5 + (i * 12), 25); // Adjusted position for hearts
                    }
                    ctx.textAlign = "center"; // Reset alignment

                    if (this.comboCount > 1) {
                        ctx.fillStyle = "#ffcc00"; // Combo text color
                        ctx.fillText(`Combo: ${this.comboCount}x`, config.canvas.width / 2, 35); // Adjusted Y position
                    }
                    if (this.slowTimeActive) {
                        ctx.fillStyle = "#00ccff";
                        ctx.fillText("Time Slow! â³", config.canvas.width / 2, 45); // Adjusted Y position
                    }
                    if (this.speedBoostActive) {
                        ctx.fillStyle = "#ff00ff";
                        ctx.fillText("Speed Boost! âš¡", config.canvas.width / 2, 55); // Adjusted Y position
                    }
                    if (this.playerPerks.magnetic) {
                        ctx.fillStyle = "#ff9900";
                        ctx.fillText("Magnetic Field Active!", config.canvas.width / 2, 65); // Adjusted Y position
                    }
                    if (this.playerPerks.magicBullets) {
                        ctx.fillStyle = "#ff00ff";
                        ctx.fillText("Magic Bullets Active! âœ¨", config.canvas.width / 2, 75);
                    }
                    if (config.bullet.count > 1) { // Display bullet barrage info
                        ctx.fillStyle = "#ffa500";
                        ctx.fillText(`Bullets: ${config.bullet.count}`, config.canvas.width / 2, 85);
                    }
                    if (config.autoShoot.enabled) { // Display auto-shoot info
                        ctx.fillStyle = "#00ffff";
                        ctx.fillText("Auto Shoot Active!", config.canvas.width / 2, 95);
                    }
                }

                this.player.draw(this.ctx);
                this.bullets.forEach(bullet => bullet.draw(this.ctx));
                this.enemies.forEach(enemy => enemy.draw(this.ctx));
                this.powerUps.forEach(pu => pu.draw(this.ctx));
                this.particles.forEach(p => p.draw(this.ctx));

                // Draw movement joystick if active.
                if (movementJoystick.active) {
                    ctx.beginPath();
                    // Joystick drawn relative to bottom-left of canvas
                    const joystickBaseX = config.canvas.width * 0.2;
                    const joystickBaseY = config.canvas.height * 0.8;
                    ctx.arc(joystickBaseX, joystickBaseY, 12, 0, Math.PI * 2); // Slightly larger
                    ctx.fillStyle = "rgba(255,255,255,0.3)"; // More opaque
                    ctx.fill();
                    let dx = movementJoystick.currentX - movementJoystick.startX;
                    let dy = movementJoystick.currentY - movementJoystick.startY;
                    let dist = Math.hypot(dx, dy);
                    let maxDist = 12; // Adjusted maxDist
                    if (dist > maxDist) { dx = dx / dist * maxDist; dy = dy / dist * maxDist; }
                    ctx.beginPath();
                    ctx.arc(joystickBaseX + dx, joystickBaseY + dy, 6, 0, Math.PI * 2); // Slightly larger knob
                    ctx.fillStyle = "rgba(255,255,255,0.7)"; // More opaque
                    ctx.fill();
                }

                // Draw shooting joystick if active.
                if (shootingJoystick.active) {
                    ctx.beginPath();
                    const shootingJoystickBaseX = config.canvas.width * 0.8; // Right side
                    const shootingJoystickBaseY = config.canvas.height * 0.8;
                    ctx.arc(shootingJoystickBaseX, shootingJoystickBaseY, 12, 0, Math.PI * 2); // Slightly larger
                    ctx.fillStyle = "rgba(255,255,255,0.3)"; // More opaque
                    ctx.fill();
                    let dx = shootingJoystick.currentX - shootingJoystick.startX;
                    let dy = shootingJoystick.currentY - shootingJoystick.startY;
                    let dist = Math.hypot(dx, dy);
                    let maxDist = 12;
                    if (dist > maxDist) { dx = dx / dist * maxDist; dy = dy / dist * maxDist; }
                    ctx.beginPath();
                    ctx.arc(shootingJoystickBaseX + dx, shootingJoystickBaseY + dy, 6, 0, Math.PI * 2); // Slightly larger knob
                    ctx.fillStyle = "rgba(255,255,255,0.7)"; // More opaque
                    ctx.fill();
                }


                // Draw Top 2 High Scores at bottom right
                let leaderboard = JSON.parse(localStorage.getItem("divineShooterLeaderboard")) || [];
                if (leaderboard.length > 0) {
                    ctx.fillStyle = "#fff";
                    ctx.font = "10px 'Inter', sans-serif";
                    ctx.textAlign = "right";
                    ctx.fillText("High Scores:", config.canvas.width - 10, config.canvas.height - 30);
                    for (let i = 0; i < Math.min(2, leaderboard.length); i++) { // Limit to top 2
                        const entry = leaderboard[i];
                        ctx.fillText(`${i + 1}. ${entry.name}: ${entry.score}`, config.canvas.width - 10, config.canvas.height - 15 + (i * 10));
                    }
                }


                // Draw shop overlay
                if (this.shopOpen) {
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
                    this.ctx.fillRect(0, 0, config.canvas.width, config.canvas.height);
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "bold 1.2em 'Inter', sans-serif";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("Upgrade Shop", config.canvas.width / 2, config.canvas.height / 2 - 40);
                    this.ctx.font = "0.8em 'Inter', sans-serif";
                    this.ctx.fillText(`Your Score: ${this.score}`, config.canvas.width / 2, config.canvas.height / 2 - 20);

                    const optionWidth = Math.min(150, config.canvas.width * 0.7);
                    const optionHeight = 30;
                    const startY = config.canvas.height / 2 - 5;
                    const padding = 10;

                    this.upgradeOptions.forEach((option, index) => {
                        const x = config.canvas.width / 2 - optionWidth / 2;
                        const y = startY + index * (optionHeight + padding);
                        option.x = x;
                        option.y = y;
                        option.width = optionWidth;
                        option.height = optionHeight;

                        ctx.fillStyle = this.score >= option.cost ? "#007bff" : "#888";
                        ctx.beginPath();
                        ctx.roundRect(x, y, optionWidth, optionHeight, 5);
                        ctx.fill();
                        ctx.strokeStyle = "#fff";
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        ctx.fillStyle = "#fff";
                        ctx.font = "bold 0.7em 'Inter', sans-serif";
                        ctx.fillText(option.name, x + optionWidth / 2, y + optionHeight / 2 - 5);
                        ctx.font = "0.6em 'Inter', sans-serif";
                        ctx.fillText(`Cost: ${option.cost} Score`, x + optionWidth / 2, y + optionHeight / 2 + 8);
                    });
                }

                // Game Over and Continue options
                if (!this.running && this.lives <= 0) {
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
                    this.ctx.fillRect(0, 0, config.canvas.width, config.canvas.height);
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "bold 1.5em 'Inter', sans-serif";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("GAME OVER", config.canvas.width / 2, config.canvas.height / 2 - 30);
                    this.ctx.font = "bold 0.8em 'Inter', sans-serif";
                    this.ctx.fillText(`Final Score: ${this.score}`, config.canvas.width / 2, config.canvas.height / 2 - 5);

                    // "Continue?" button
                    const continueButtonWidth = Math.min(120, config.canvas.width * 0.6);
                    const continueButtonHeight = 30;
                    const continueButtonX = config.canvas.width / 2 - continueButtonWidth / 2;
                    const continueButtonY = config.canvas.height / 2 + 15;

                    ctx.fillStyle = this.score >= config.continueCost ? "#00ff00" : "#ff0000";
                    ctx.beginPath();
                    ctx.roundRect(continueButtonX, continueButtonY, continueButtonWidth, continueButtonHeight, 5);
                    ctx.fill();
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.fillStyle = "#000";
                    ctx.font = "bold 0.7em 'Inter', sans-serif";
                    ctx.fillText(`Continue? (${config.continueCost} Score)`, config.canvas.width / 2, continueButtonY + 18);
                    game.continueButton = { x: continueButtonX, y: continueButtonY, width: continueButtonWidth, height: continueButtonHeight };

                    // "Restart" button
                    const restartButtonWidth = Math.min(120, config.canvas.width * 0.6);
                    const restartButtonHeight = 30;
                    const restartButtonX = config.canvas.width / 2 - restartButtonWidth / 2;
                    const restartButtonY = config.canvas.height / 2 + 55;

                    ctx.fillStyle = "#007bff";
                    ctx.beginPath();
                    ctx.roundRect(restartButtonX, restartButtonY, restartButtonWidth, restartButtonHeight, 5);
                    ctx.fill();
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.fillStyle = "#000";
                    ctx.font = "bold 0.7em 'Inter', sans-serif";
                    ctx.fillText("Restart Game", config.canvas.width / 2, restartButtonY + 18);
                    game.restartButton = { x: restartButtonX, y: restartButtonY, width: restartButtonWidth, height: restartButtonHeight };
                }
            }
            gameLoop(timestamp) {
                const dt = (timestamp - lastTime) / 1000;
                lastTime = timestamp;

                this.update(dt, timestamp);
                this.draw();

                if (this.running) {
                    requestAnimationFrame(this.gameLoop.bind(this));
                } else {
                    // Only draw leaderboard if game is over and not continuing/restarting
                    if (this.lives <= 0) {
                        this.drawLeaderboard();
                    }
                }
            }
            checkCollisions() {
                // Bullet-Enemy collisions
                this.bullets = this.bullets.filter(bullet => {
                    let hitEnemy = false;
                    this.enemies = this.enemies.filter(enemy => {
                        if (enemy.visible && Utils.distance(bullet.x, bullet.y, enemy.x, enemy.y) < enemy.size + bullet.size) {
                            if (enemy.type === "Odin" && enemy.state.shieldActive) {
                                // Odin's shield blocks the bullet
                                hitEnemy = true; // Bullet is consumed
                                return true; // Enemy remains
                            }
                            // Play sound on hit
                            shootSound.play();
                            enemy.hp--;
                            for (let i = 0; i < config.particles.count; i++) {
                                this.particles.push(new Particle(enemy.x, enemy.y));
                            }
                            // TODO: Implement object pooling for particles and bullets to reduce garbage collection.
                            // Instead of `new Particle()`, get from pool; instead of `push`, add to pool.
                            hitEnemy = true; // Mark bullet for removal

                            if (enemy.hp <= 0) {
                                this.score += 100 * this.scoreMultiplier;
                                const now = performance.now();
                                if (now - this.lastKillTime < 1000) { this.comboCount++; } // Combo within 1 second
                                else { this.comboCount = 1; }
                                this.lastKillTime = now;
                                return false; // Remove enemy
                            }
                            return true; // Enemy remains
                        }
                        return true; // Enemy remains
                    });
                    return !hitEnemy; // Remove bullet if it hit an enemy
                });

                // Player-Enemy collisions
                this.enemies = this.enemies.filter(enemy => {
                    if (enemy.visible && Utils.distance(this.player.x, this.player.y, enemy.x, enemy.y) < config.player.size + enemy.size) {
                        if (!this.playerPerks.invisibility) { // Player cannot be hit if invisible
                            playerHitSound.play();
                            this.loseLife(enemy.baseHit);
                            game.player.isHit = true; // Trigger player hit effect
                            game.player.hitEffectEndTime = performance.now() + 200; // 200ms flash
                            vibrate(50); // Vibrate on player hit
                            return false; // Remove enemy on collision
                        }
                    }
                    return true; // Enemy remains
                });

                // Player-Shiva Projectile collisions
                this.enemies.forEach(enemy => {
                    if (enemy.type === "Shiva") {
                        enemy.projectiles = enemy.projectiles.filter(p => {
                            if (Utils.distance(this.player.x, this.player.y, p.x, p.y) < config.player.size + p.size) {
                                if (!this.playerPerks.invisibility) {
                                    playerHitSound.play();
                                    this.loseLife(1); // Shiva's projectile deals 1 damage
                                    game.player.isHit = true; // Trigger player hit effect
                                    game.player.hitEffectEndTime = performance.now() + 200; // 200ms flash
                                    vibrate(50); // Vibrate on player hit
                                }
                                return false; // Remove projectile
                            }
                            return true; // Projectile remains
                        });
                    }
                });


                // Player-PowerUp collisions
                this.powerUps = this.powerUps.filter(pu => {
                    if (Utils.distance(this.player.x, this.player.y, pu.x, pu.y) < config.player.size + pu.size) {
                        if (pu.type === "extraLife") {
                            this.lives++;
                        } else if (pu.type === "timeSlow") {
                            this.slowTimeActive = true;
                            this.slowTimeEnd = performance.now() + 5000; // 5 seconds slow time
                        } else if (pu.type === "speedBoost") {
                            this.speedBoostActive = true;
                            this.speedBoostEnd = performance.now() + 7000; // 7 seconds speed boost
                        } else if (pu.type === "shieldRecharge") { // New power-up effect
                            if (this.playerPerks.shield) {
                                this.playerPerks.shieldDurability = this.playerPerks.initialShieldDurability;
                            } else {
                                this.playerPerks.shield = true;
                                this.playerPerks.shieldDurability = this.playerPerks.initialShieldDurability;
                            }
                        }
                        vibrate(30); // Vibrate on power-up pickup
                        return false; // Remove power-up
                    }
                    return true; // Power-up remains
                });
            }
            loseLife(damage = 1) {
                if (this.playerPerks.shield && this.playerPerks.shieldDurability > 0) {
                    this.playerPerks.shieldDurability -= damage;
                    console.log("Shield hit! Durability left: " + this.playerPerks.shieldDurability);
                } else {
                    this.lives -= damage;
                    if (this.lives <= 0) {
                        this.gameOver();
                    }
                }
            }
            gameOver() {
                this.running = false;
                backgroundMusic.stopContinuous(); // Stop background music
                divineBlastBtn.style.display = 'none'; // Hide divine blast button
                pauseBtn.style.display = 'none'; // Hide pause button
                this.updateLeaderboard(config.player.name, this.score);
                mainUiOverlay.style.display = 'flex'; // Show the overlay for game over
                vibrate(200); // Vibrate on game over
            }
            updateLevel() {
                // Level up when score reaches the threshold
                if (this.score >= this.level * config.levelUpScore) {
                    this.level++;
                    config.player.level = this.level; // Update player level in config for enemy scaling
                    this.openShop(); // Open shop on level up
                    vibrate(75); // Vibrate on level up
                }
            }
            spawnEnemy() {
                const types = config.divine.types;
                let chosenType = types[Math.floor(Math.random() * types.length)];

                // Ensure a boss spawns at certain levels
                if (this.level % 5 === 0 && this.enemies.length === 0) { // Spawn boss every 5 levels if no enemies are present
                    chosenType = config.divine.boss;
                } else if (this.level % 2 === 0 && Math.random() < 0.3) { // Higher chance for specific enemies at higher levels
                    chosenType = types[Math.floor(Math.random() * types.length)]; // Pick any type for variety
                }

                this.enemies.push(new Enemy(chosenType, this));
            }
            spawnPowerUp() {
                const powerUpTypes = ["extraLife", "timeSlow", "speedBoost", "shieldRecharge"]; // Added shieldRecharge
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                const x = Math.random() * (config.canvas.width - 2 * 4) + 4; // Ensure power-up spawns fully inside
                const y = Math.random() * (config.canvas.height - 2 * 4) + 4;
                this.powerUps.push(new PowerUp(type, x, y));
            }
            updateLeaderboard(name, score) {
                let leaderboard = JSON.parse(localStorage.getItem("divineShooterLeaderboard")) || [];
                leaderboard.push({ name: name, score: score });
                leaderboard.sort((a, b) => b.score - a.score); // Sort descending
                leaderboard = leaderboard.slice(0, 5); // Keep top 5
                localStorage.setItem("divineShooterLeaderboard", JSON.stringify(leaderboard));
                this.drawLeaderboard(); // Update the full leaderboard on the overlay
            }
            drawLeaderboard() {
                lbListEl.innerHTML = "";
                let leaderboard = JSON.parse(localStorage.getItem("divineShooterLeaderboard")) || [];
                // Add a title to the leaderboard
                const titleLi = document.createElement("li");
                titleLi.innerHTML = "<strong>Leaderboard</strong>";
                lbListEl.appendChild(titleLi);

                if (leaderboard.length === 0) {
                    const noEntryLi = document.createElement("li");
                    noEntryLi.textContent = "No scores yet!";
                    lbListEl.appendChild(noEntryLi);
                } else {
                    leaderboard.forEach((entry, index) => {
                        const li = document.createElement("li");
                        li.textContent = `${index + 1}. ${entry.name}: ${entry.score}`;
                        lbListEl.appendChild(li);
                    });
                }
            }
            // New Divine Blast method
            activateDivineBlast() {
                if (this.divineBlastCharges > 0 && !this.paused && this.running) {
                    this.divineBlastCharges--;
                    this.lastDivineBlastTime = performance.now(); // Start cooldown
                    this.updateDivineBlastUI();
                    vibrate(150); // Vibrate on divine blast activation

                    // Create a visual blast effect (e.g., a rapidly expanding circle)
                    let blastRadius = 0;
                    const maxBlastRadius = config.divineBlast.radius;
                    const blastDuration = 150; // ms
                    const blastStart = performance.now();

                    const animateBlast = () => {
                        const elapsed = performance.now() - blastStart;
                        if (elapsed < blastDuration) {
                            blastRadius = maxBlastRadius * (elapsed / blastDuration);
                            // Draw blast effect
                            ctx.beginPath();
                            ctx.arc(this.player.x, this.player.y, blastRadius, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(138, 43, 226, ${1 - (elapsed / blastDuration)})`; // Fade out
                            ctx.fill();
                            requestAnimationFrame(animateBlast);
                        }
                    };
                    animateBlast();

                    // Damage/destroy enemies within the blast radius
                    this.enemies = this.enemies.filter(enemy => {
                        if (Utils.distance(this.player.x, this.player.y, enemy.x, enemy.y) < maxBlastRadius) {
                            enemy.hp -= config.divineBlast.damage;
                            for (let i = 0; i < config.particles.count * 2; i++) { // More particles for blast
                                this.particles.push(new Particle(enemy.x, enemy.y));
                            }
                            if (enemy.hp <= 0) {
                                this.score += 100 * this.scoreMultiplier; // Get score for destroyed enemies
                                return false; // Remove enemy
                            }
                        }
                        return true; // Enemy remains
                    });
                }
            }
            updateDivineBlastUI() {
                divineBlastBtn.textContent = `Divine Blast (${this.divineBlastCharges})`;
                if (this.divineBlastCharges === 0) {
                    divineBlastBtn.classList.add('disabled');
                } else {
                    divineBlastBtn.classList.remove('disabled');
                }
            }
        }

        const game = new Game();
        let lastTime = 0;
        let keysPressed = {};

        // Event Listeners for Keyboard Controls (Desktop)
        window.addEventListener("keydown", (e) => {
            keysPressed[e.key] = true;
            if (e.key === "p" || e.key === "P") {
                game.togglePause();
            }
            if (e.key === "q" || e.key === "Q") { // 'Q' key for Divine Blast
                game.activateDivineBlast();
            }
        });

        window.addEventListener("keyup", (e) => {
            keysPressed[e.key] = false;
        });

        // Mouse movement for aiming (Desktop)
        let mouseX = 0;
        let mouseY = 0;
        canvas.addEventListener("mousemove", (e) => {
            // Adjust mouse coordinates relative to the canvas
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        // Mouse click for shop interaction (Desktop)
        canvas.addEventListener("click", (e) => {
            // Adjust click coordinates relative to the canvas
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            if (game.shopOpen) {
                game.processShopClick(clickX, clickY);
            } else if (!game.running && game.lives <= 0) {
                // Handle "Continue?" button click
                if (game.continueButton && clickX >= game.continueButton.x && clickX <= game.continueButton.x + game.continueButton.width &&
                    clickY >= game.continueButton.y && clickY <= game.continueButton.y + game.continueButton.height) {
                    if (game.score >= config.continueCost) {
                        game.score -= config.continueCost;
                        game.lives = 1; // Give one life to continue
                        game.running = true;
                        game.paused = false;
                        mainUiOverlay.style.display = 'none'; // Hide overlay
                        divineBlastBtn.style.display = 'block'; // Show divine blast button
                        pauseBtn.style.display = 'block'; // Show pause button
                        game.updateDivineBlastUI();
                        if (game.isSoundOn) { // Only start music if sound is enabled
                            backgroundMusic.startContinuous();
                            backgroundMusic.setVolume(0.3);
                        }
                        lastTime = performance.now();
                        requestAnimationFrame(game.gameLoop.bind(game));
                    }
                }
                // Handle "Restart" button click
                if (game.restartButton && clickX >= game.restartButton.x && clickX <= game.restartButton.x + game.restartButton.width &&
                    clickY >= game.restartButton.y && clickY <= game.restartButton.y + game.restartButton.height) {
                    game.start(); // Restart the game
                    mainUiOverlay.style.display = 'none'; // Hide overlay
                }
            }
        });

        // Touch events for mobile
        canvas.addEventListener("touchstart", (e) => {
            e.preventDefault(); // Prevent default browser touch behavior (like scrolling/zooming)

            // Adjust touch coordinates relative to the canvas
            const rect = canvas.getBoundingClientRect();

            if (tutorialVisible) {
                // If tutorial is visible, only allow closing it
                if (e.touches[0].target.id === 'closeTutorialBtn') {
                    tutorialOverlay.style.display = 'none';
                    tutorialVisible = false;
                    mainUiOverlay.style.display = 'flex'; // Show main UI overlay with start button
                }
                return;
            }

            if (!game.running) {
                // Handle "Start" button click on the overlay
                // Check if the touch is within the bounds of the startBtn element
                const startBtnRect = startBtn.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                const touchY = e.touches[0].clientY - rect.top;

                if (touchX >= (startBtnRect.left - rect.left) && touchX <= (startBtnRect.right - rect.left) &&
                    touchY >= (startBtnRect.top - rect.top) && touchY <= (startBtnRect.bottom - rect.top)) {
                    game.start();
                    mainUiOverlay.style.display = 'none'; // Hide overlay after starting
                    return;
                }
                // Handle "Sound Toggle" button click on the overlay
                const soundToggleBtnRect = soundToggleBtn.getBoundingClientRect();
                if (touchX >= (soundToggleBtnRect.left - rect.left) && touchX <= (soundToggleBtnRect.right - rect.left) &&
                    touchY >= (soundToggleBtnRect.top - rect.top) && touchY <= (soundToggleBtnRect.bottom - rect.top)) {
                    soundToggleBtn.click(); // Simulate a click on the sound toggle button
                    return;
                }

                // Handle game over screen buttons (drawn on canvas, so use canvas-relative touchX/Y)
                if (game.lives <= 0) {
                    if (game.continueButton && touchX >= game.continueButton.x && touchX <= game.continueButton.x + game.continueButton.width &&
                        touchY >= game.continueButton.y && touchY <= game.continueButton.y + game.continueButton.height) {
                        if (game.score >= config.continueCost) {
                            game.score -= config.continueCost;
                            game.lives = 1;
                            game.running = true;
                            game.paused = false;
                            mainUiOverlay.style.display = 'none'; // Hide overlay
                            divineBlastBtn.style.display = 'block'; // Show divine blast button
                            pauseBtn.style.display = 'block'; // Show pause button
                            game.updateDivineBlastUI();
                            if (game.isSoundOn) { // Only start music if sound is enabled
                                backgroundMusic.startContinuous();
                                backgroundMusic.setVolume(0.3);
                            }
                            lastTime = performance.now();
                            requestAnimationFrame(game.gameLoop.bind(game));
                        }
                    }
                    if (game.restartButton && touchX >= game.restartButton.x && touchX <= game.restartButton.x + game.restartButton.width &&
                        touchY >= game.restartButton.y && touchY <= game.restartButton.y + game.restartButton.height) {
                        game.start();
                        mainUiOverlay.style.display = 'none'; // Hide overlay
                    }
                }
                return;
            }

            if (game.shopOpen) {
                const touchX = e.touches[0].clientX - rect.left;
                const touchY = e.touches[0].clientY - rect.top;
                game.processShopClick(touchX, touchY);
                return;
            }

            // Divine Blast with two-finger tap
            if (e.touches.length === 2) {
                game.activateDivineBlast();
                return; // Consume the touch event for divine blast
            }

            // Assign touches to joysticks
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                if (touchX < config.canvas.width / 2) { // Left half for movement joystick
                    if (!movementJoystick.active) {
                        movementJoystick.active = true;
                        movementJoystick.touchId = touch.identifier;
                        movementJoystick.startX = touchX;
                        movementJoystick.startY = touchY;
                        movementJoystick.currentX = touchX;
                        movementJoystick.currentY = touchY;
                        movementJoystick.dx = 0;
                        movementJoystick.dy = 0;
                    }
                } else { // Right half for shooting joystick
                    if (!shootingJoystick.active) {
                        shootingJoystick.active = true;
                        shootingJoystick.touchId = touch.identifier;
                        shootingJoystick.startX = touchX;
                        shootingJoystick.startY = touchY;
                        shootingJoystick.currentX = touchX;
                        shootingJoystick.currentY = touchY;
                        shootingJoystick.dx = 0;
                        shootingJoystick.dy = 0;
                    }
                }
            }
        }, { passive: false }); // Set to false to allow preventDefault

        canvas.addEventListener("touchmove", (e) => {
            e.preventDefault();
            // Adjust touch coordinates relative to the canvas
            const rect = canvas.getBoundingClientRect();

            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const currentTouchX = touch.clientX - rect.left;
                const currentTouchY = touch.clientY - rect.top;

                if (movementJoystick.active && touch.identifier === movementJoystick.touchId) {
                    movementJoystick.currentX = currentTouchX;
                    movementJoystick.currentY = currentTouchY;
                    movementJoystick.dx = movementJoystick.currentX - movementJoystick.startX;
                    movementJoystick.dy = movementJoystick.currentY - movementJoystick.startY;
                } else if (shootingJoystick.active && touch.identifier === shootingJoystick.touchId) {
                    shootingJoystick.currentX = currentTouchX;
                    shootingJoystick.currentY = currentTouchY;
                    shootingJoystick.dx = shootingJoystick.currentX - shootingJoystick.startX;
                    shootingJoystick.dy = shootingJoystick.currentY - shootingJoystick.startY;
                }
            }
        }, { passive: false });

        canvas.addEventListener("touchend", (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (movementJoystick.active && touch.identifier === movementJoystick.touchId) {
                    movementJoystick.active = false;
                    movementJoystick.touchId = null;
                    movementJoystick.dx = 0;
                    movementJoystick.dy = 0;
                } else if (shootingJoystick.active && touch.identifier === shootingJoystick.touchId) {
                    shootingJoystick.active = false;
                    shootingJoystick.touchId = null;
                    shootingJoystick.dx = 0;
                    shootingJoystick.dy = 0;
                }
            }
        });

        // Divine Blast button listener (for both desktop click and mobile touch)
        divineBlastBtn.addEventListener("click", () => {
            game.activateDivineBlast();
        });
        divineBlastBtn.addEventListener("touchend", (e) => {
            e.preventDefault(); // Prevent default touch behavior
            game.activateDivineBlast();
        });

        // Pause button listener
        pauseBtn.addEventListener("click", () => {
            game.togglePause();
        });
        pauseBtn.addEventListener("touchend", (e) => {
            e.preventDefault(); // Prevent default touch behavior
            game.togglePause();
        });


        // Initial setup and event listeners
        closeTutorialBtn.addEventListener("click", () => {
            tutorialOverlay.style.display = 'none';
            tutorialVisible = false;
            mainUiOverlay.style.display = 'flex'; // Show main UI overlay with start button
        });

        startBtn.addEventListener("click", () => {
            game.start();
            mainUiOverlay.style.display = "none"; // Hide main UI overlay after starting
        });

        // Sound Toggle Button Listener
        soundToggleBtn.addEventListener("click", () => {
            if (game.isSoundOn) {
                backgroundMusic.stopContinuous(); // Stop continuous sound
                backgroundMusic.setVolume(0);
                shootSound.setVolume(0);
                enemyHitSound.setVolume(0);
                playerHitSound.setVolume(0);
                game.isSoundOn = false;
                soundToggleBtn.textContent = "Start Sound";
            } else {
                backgroundMusic.startContinuous(); // Start continuous sound
                backgroundMusic.setVolume(0.3); // Restore desired volume
                shootSound.setVolume(0.5); // Restore original volumes
                enemyHitSound.setVolume(0.5);
                playerHitSound.setVolume(0.6);
                game.isSoundOn = true;
                soundToggleBtn.textContent = "Mute Sound";
            }
        });


        // Show tutorial on first load
        if (tutorialVisible) {
            tutorialOverlay.style.display = 'flex';
            mainUiOverlay.style.display = 'none'; // Hide main UI overlay until tutorial is closed
        } else {
            tutorialOverlay.style.display = 'none';
            mainUiOverlay.style.display = 'flex'; // Show main UI overlay with start button
        }

        // Initial leaderboard draw
        game.drawLeaderboard();

        // Start the game loop only after the tutorial is closed or if it's not visible
        window.onload = function () {
            // This onload is mainly for initial setup. Game loop starts via start button click.
        }
    </script>
</body>
</html>
