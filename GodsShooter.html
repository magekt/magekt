<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Divine Shooter: GANESH v4.0 – Mobile Ultimate Edition</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            justify-content: flex-start; /* Align content to the top */
            align-items: center; /* Center horizontally */
            min-height: 100vh; /* Ensure body takes full viewport height */
            font-family: 'Inter', sans-serif; /* Using Inter font */
        }
        canvas {
            display: block;
            background: #1a1a1a;
            touch-action: none; /* Prevents default browser touch gestures */
            border-radius: 10px; /* Rounded corners for the canvas */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* Glowing border */
            width: 340px; /* Fixed width */
            height: 340px; /* Fixed height as requested */
            margin-top: 20px; /* Small margin from the top */
        }

        /* Overlay for Start Button and Full Leaderboard */
        #main-ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10; /* Above canvas, below tutorial */
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent background */
            display: none; /* Hidden by default */
        }
        #main-ui-overlay button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.4);
            transition: background-color 0.3s ease, transform 0.2s ease;
            position: relative;
            overflow: hidden;
            margin-bottom: 10px; /* Space between button and leaderboard */
        }
        #main-ui-overlay button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #main-ui-overlay button:active {
            transform: translateY(1px);
        }
        /* Bubble effect for buttons */
        #main-ui-overlay button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: width 0.4s ease-out, height 0.4s ease-out, opacity 0.4s ease-out;
        }
        #main-ui-overlay button:active::before {
            width: 200%;
            height: 200%;
            opacity: 1;
        }

        #main-ui-overlay ul {
            list-style: none;
            padding: 0;
            margin: 0;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 10px 20px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            color: #fff;
            font-family: 'Inter', sans-serif;
            font-size: 16px;
        }
        #main-ui-overlay ul li {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        #main-ui-overlay ul li:last-child {
            border-bottom: none;
        }

        /* Tutorial overlay styling */
        #tutorialOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-family: 'Inter', sans-serif;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        #tutorialOverlay h2 {
            font-size: 1.3em; /* Adjusted for smaller screen */
            margin-bottom: 13px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        #tutorialOverlay p {
            font-size: 0.8em; /* Adjusted for smaller screen */
            margin-bottom: 10px;
            line-height: 1.2; /* Adjusted for smaller screen */
            max-width: 300px; /* Constrain width for smaller screen */
        }
        #tutorialOverlay button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px; /* Adjusted for smaller screen */
            font-size: 16px; /* Adjusted for smaller screen */
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px; /* Adjusted for smaller screen */
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.4);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        #tutorialOverlay button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #tutorialOverlay button:active {
            transform: translateY(1px);
        }
    </style>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="tutorialOverlay">
        <h2>Welcome to Divine Shooter: GANESH v4.0!</h2>
        <p>Protect the universe from rogue divinities!</p>
        <p><strong>Desktop Controls:</strong></p>
        <p>Use <strong>WASD</strong> or <strong>Arrow Keys</strong> to move.</p>
        <p>Click anywhere on the screen or press <strong>Spacebar</strong> to shoot.</p>
        <p>Press <strong>P</strong> to pause/unpause the game.</p>
        <p><strong>Mobile Controls:</strong></p>
        <p><strong>Drag your finger on the left side of the screen</strong> to move.</p>
        <p><strong>Tap anywhere on the right side of the screen</strong> to shoot.</p>
        <button id="closeTutorialBtn">Got It! Start Game</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="main-ui-overlay">
        <button id="startBtn">Start Game</button>
        <ul id="lbListEl"></ul>
    </div>

    <script>
        // Consolidated utility functions.
        const Utils = {
            distance: (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1),
            angleBetween: (x1, y1, x2, y2) => Math.atan2(y2 - y1, x2 - x1),
            pointToLineDistance: (px, py, x1, y1, x2, y2) => {
                const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                let param = len_sq !== 0 ? dot / len_sq : -1;
                let xx, yy;
                if (param < 0) { xx = x1; yy = y1; }
                else if (param > 1) { xx = x2; yy = y2; }
                else { xx = x1 + param * C; yy = y1 + param * D; }
                return Utils.distance(px, py, xx, yy);
            }
        };

        // Configuration for game constants.
        const config = {
            canvas: { width: 340, height: 340 }, // Fixed size as requested
            player: { size: 15, acceleration: 600, friction: 0.9, maxSpeed: 200, color: "#00ff00", name: "GANESH", level: 1 }, // Adjusted player size/speed for smaller canvas
            bullet: { size: 3, speed: 350, lifetime: 1000, color: "#ffffff" }, // Adjusted bullet size/speed
            divine: {
                types: ["Loki", "Thor", "Buddha", "Sun", "Hermes", "Zeus", "Odin", "Ra", "Anubis"],
                boss: "Boss",
                baseSize: 20, // Adjusted base enemy size
                vanishInterval: 2000,
                vanishDuration: 500,
                lightningDelay: 1200,
                circleGrowth: 20, // Adjusted circle growth
                sunHits: 3
            },
            enemy: { spawnInterval: 2000, baseSpeed: 60, speedIncrease: 2, maxSpeed: 100 }, // Adjusted enemy speed
            boss: { color: "#ff00ff", size: 35, health: 5, speed: 35 }, // Adjusted boss size/speed
            particles: { count: 15, size: 2, lifetime: 500, colors: ["#ff4444", "#ffcc00", "#00aaff"] }, // Adjusted particle size/count
            levelUpScore: 750, // Adjusted level up score
            continueCost: 350, // Adjusted continue cost
            powerUpSpawnInterval: 7000 // Adjusted power-up spawn interval
        };

        // Canvas setup.
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        function resizeCanvas() {
            // Set canvas dimensions explicitly to the fixed size
            canvas.width = config.canvas.width;
            canvas.height = config.canvas.height;
        }
        resizeCanvas();
        // No need to listen for window resize if fixed size
        // window.addEventListener("resize", resizeCanvas);

        // Function to generate a simple audio buffer (sine wave)
        function createAudioBuffer(frequency, duration, sampleRate = 44100) {
            const context = new (window.AudioContext || window.webkitAudioContext)();
            const numSamples = sampleRate * duration;
            const buffer = context.createBuffer(1, numSamples, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < numSamples; i++) {
                data[i] = Math.sin(2 * Math.PI * frequency * (i / sampleRate));
            }

            // Encode to WAV data URI
            const wavHeader = new ArrayBuffer(44);
            const view = new DataView(wavHeader);

            // RIFF chunk
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + numSamples * 2, true); // ChunkSize
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
            view.setUint16(20, 1, true); // AudioFormat (1 for PCM)
            view.setUint32(24, sampleRate, true); // NumChannels
            view.setUint32(28, sampleRate * 2, true); // SampleRate
            view.setUint16(32, 2, true); // ByteRate (SampleRate * NumChannels * BitsPerSample/8)
            view.setUint16(34, 16, true); // BlockAlign (NumChannels * BitsPerSample/8)

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, numSamples * 2, true); // Subchunk2Size

            const pcmData = new Int16Array(numSamples);
            for (let i = 0; i < numSamples; i++) {
                pcmData[i] = Math.max(-1, Math.min(1, data[i])) * 0x7FFF; // Convert to 16-bit PCM
            }

            const blob = new Blob([wavHeader, pcmData], { type: 'audio/wav' });
            return URL.createObjectURL(blob);
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Audio assets using generated sounds
        const shootSound = new Audio(createAudioBuffer(880, 0.05)); // High frequency, short duration
        const enemyHitSound = new Audio(createAudioBuffer(440, 0.1)); // Mid frequency, short duration
        const playerHitSound = new Audio(createAudioBuffer(220, 0.2)); // Low frequency, slightly longer duration
        const backgroundMusic = new Audio(createAudioBuffer(110, 5)); // Very low frequency, longer duration for background
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0; // Start at 0 volume to comply with autoplay policies

        // Global joystick for mobile.
        let joystick = { active: false, touchId: null, startX: 0, startY: 0, currentX: 0, currentY: 0, dx: 0, dy: 0 };
        let tutorialVisible = true; // Set to true to show tutorial on first load

        // UI elements.
        const startBtn = document.getElementById("startBtn");
        const lbListEl = document.getElementById("lbListEl");
        const tutorialOverlay = document.getElementById("tutorialOverlay");
        const closeTutorialBtn = document.getElementById("closeTutorialBtn");
        const mainUiOverlay = document.getElementById("main-ui-overlay"); // Get the new overlay div

        // Starfield background.
        class Star {
            constructor() {
                this.x = Math.random() * config.canvas.width;
                this.y = Math.random() * config.canvas.height;
                this.radius = Math.random() * 1.5 + 0.5;
                this.speed = Math.random() * 0.5 + 0.2;
            }
            update(dt) {
                this.y += this.speed * dt * 20; // Adjusted speed for smaller canvas
                if (this.y > config.canvas.height) {
                    this.y = 0;
                    this.x = Math.random() * config.canvas.width;
                }
            }
            draw(ctx) {
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Particle class for explosion effects.
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * 2 * Math.PI;
                const speed = Math.random() * 50 + 25; // Adjusted speed for smaller canvas
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.size = config.particles.size;
                this.lifetime = config.particles.lifetime;
                this.created = performance.now();
                this.color = config.particles.colors[Math.floor(Math.random() * config.particles.colors.length)];
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
            draw(ctx) {
                const lifeProgress = (performance.now() - this.created) / this.lifetime;
                ctx.globalAlpha = Math.max(1 - lifeProgress, 0);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // PowerUp class.
        class PowerUp {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.size = 8; // Adjusted size
            }
            update(dt) { }
            draw(ctx) {
                ctx.font = "8px Arial"; // Adjusted font size
                ctx.textAlign = "center";
                let label = "";
                if (this.type === "extraLife") {
                    ctx.fillStyle = "#00ff00";
                    label = "❤️"; // Heart emoji for extra life
                } else if (this.type === "timeSlow") {
                    ctx.fillStyle = "#00ccff";
                    label = "⏳"; // Hourglass emoji for time slow
                } else if (this.type === "speedBoost") {
                    ctx.fillStyle = "#ff00ff";
                    label = "⚡"; // Lightning emoji for speed boost
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#fff";
                ctx.fillText(label, this.x, this.y + 3); // Adjusted text position
            }
        }

        // Player class.
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
            }
            update(dt, keys) {
                let effectiveAccel = config.player.acceleration;
                if (game.speedBoostActive) { effectiveAccel *= 1.5; }
                if (keys["ArrowUp"] || keys["w"]) this.vy -= effectiveAccel * dt;
                if (keys["ArrowDown"] || keys["s"]) this.vy += effectiveAccel * dt;
                if (keys["ArrowLeft"] || keys["a"]) this.vx -= effectiveAccel * dt;
                if (keys["ArrowRight"] || keys["d"]) this.vx += effectiveAccel * dt;

                // Joystick input
                if (joystick.active) {
                    let mag = Math.hypot(joystick.dx, joystick.dy);
                    if (mag > 5) { // Dead zone for joystick, adjusted
                        let normX = joystick.dx / mag;
                        let normY = joystick.dy / mag;
                        // Scale joystick input to player acceleration
                        this.vx += normX * effectiveAccel * dt * 0.5;
                        this.vy += normY * effectiveAccel * dt * 0.5;
                    }
                }

                this.vx *= config.player.friction;
                this.vy *= config.player.friction;

                const speed = Math.hypot(this.vx, this.vy);
                if (speed > config.player.maxSpeed) {
                    const factor = config.player.maxSpeed / speed;
                    this.vx *= factor;
                    this.vy *= factor;
                }

                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Keep player within canvas bounds
                this.x = Math.max(config.player.size, Math.min(config.canvas.width - config.player.size, this.x));
                this.y = Math.max(config.player.size, Math.min(config.canvas.height - config.player.size, this.y));
            }
            draw(ctx) {
                if (game.playerPerks.invisibility) { ctx.globalAlpha = 0.3; }
                ctx.fillStyle = config.player.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, config.player.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#fff";
                ctx.textAlign = "center";
                ctx.font = "8px Arial"; // Adjusted font size
                ctx.fillText(config.player.name, this.x, this.y - config.player.size - 3); // Adjusted text position

                // Draw shield if active
                if (game.playerPerks.shield && game.playerPerks.shieldDurability > 0) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, config.player.size + 3, 0, Math.PI * 2); // Adjusted shield size
                    ctx.strokeStyle = `rgba(0, 200, 255, ${game.playerPerks.shieldDurability / game.playerPerks.initialShieldDurability})`;
                    ctx.lineWidth = 2; // Adjusted line width
                    ctx.stroke();
                    ctx.fillStyle = `rgba(0, 200, 255, ${game.playerPerks.shieldDurability / game.playerPerks.initialShieldDurability * 0.2})`;
                    ctx.fill();
                }

                ctx.globalAlpha = 1;
            }
        }

        // Bullet class.
        class Bullet {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = config.bullet.speed;
                this.size = config.bullet.size;
                this.lifetime = config.bullet.lifetime;
                this.created = performance.now();
            }
            update(dt) {
                this.x += Math.cos(this.angle) * this.speed * dt;
                this.y += Math.sin(this.angle) * this.speed * dt;
            }
            draw(ctx) {
                ctx.fillStyle = config.bullet.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // MagicBullet class (homing bullet).
        class MagicBullet extends Bullet {
            constructor(x, y, angle, target) {
                super(x, y, angle);
                this.homing = true;
                this.target = target;
                this.size = config.bullet.size * 1.5; // Larger size for magic bullet
                this.color = "#ff00ff"; // Distinct color
            }
            update(dt) {
                // If target exists and is alive, home in on it
                if (this.target && this.target.hp > 0) {
                    let desiredAngle = Utils.angleBetween(this.x, this.y, this.target.x, this.target.y);
                    let angleDiff = desiredAngle - this.angle;
                    // Normalize angle difference to be between -PI and PI
                    angleDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                    this.angle += angleDiff * dt * 3; // Homing speed
                } else {
                    // If target is gone or no target, find the nearest enemy
                    let nearest = null;
                    let nearestDist = Infinity;
                    for (let enemy of game.enemies) {
                        let d = Utils.distance(this.x, this.y, enemy.x, enemy.y);
                        if (d < nearestDist) { nearestDist = d; nearest = enemy; }
                    }
                    this.target = nearest; // Set new target
                }
                super.update(dt); // Move bullet
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                // Add a small trail effect
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(this.x - Math.cos(this.angle) * this.size, this.y - Math.sin(this.angle) * this.size, this.size * 0.7, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Enemy class with behavior determined by type.
        class Enemy {
            constructor(type, game) {
                this.game = game;
                this.type = type;
                this.size = config.divine.baseSize;
                this.visible = true;
                this.state = {};

                // Set defaults for health and speed based on type and level.
                if (game.level % 10 === 0 || type === config.divine.boss) {
                    this.type = config.divine.boss;
                    this.hp = config.boss.health + Math.floor(game.level / 5); // Boss health scales with level
                    this.maxHp = this.hp;
                    this.size = config.boss.size;
                    this.speed = config.boss.speed + Math.floor(game.level / 10); // Boss speed scales
                } else {
                    let computedSpeed = config.enemy.baseSpeed + game.level * config.enemy.speedIncrease;
                    this.speed = Math.min(computedSpeed, config.enemy.maxSpeed);
                    let baseHealth = (type === "Sun") ? config.divine.sunHits : 1;
                    this.hp = Math.ceil(baseHealth * (1 + game.level / 5)); // Enemy health scales with level
                    this.maxHp = this.hp;
                }

                // Add baseHit property – by default it is 1 but scales with level;
                // for "Sun" type enemies, the scaling factor is config.divine.sunHits.
                let baseHitFactor = (this.type === "Sun") ? config.divine.sunHits : 1;
                this.baseHit = Math.ceil(baseHitFactor * (1 + game.level / 5));
                this.spawn();
            }
            spawn() {
                // Spawn logic for different enemy types
                if (this.type === "Buddha") {
                    // Buddha spawns near player, but not too close
                    const minDistance = 75; // Adjusted min distance
                    let angle = Math.random() * Math.PI * 2;
                    let dist = minDistance + Math.random() * (Math.min(config.canvas.width, config.canvas.height) / 3);
                    this.x = game.player.x + Math.cos(angle) * dist;
                    this.y = game.player.y + Math.sin(angle) * dist;
                } else if (["Loki", "Thor", config.divine.boss, "Anubis"].includes(this.type)) {
                    // These types spawn from edges
                    const pos = getRandomSpawn();
                    this.x = pos.x;
                    this.y = pos.y;
                } else {
                    // Default random spawn anywhere
                    this.x = Math.random() * config.canvas.width;
                    this.y = Math.random() * config.canvas.height;
                }

                // Initialize type-specific states.
                if (this.type === "Loki") {
                    this.state.lastVanish = performance.now();
                    this.state.vanishInterval = (game.level >= 10) ? 1500 : config.divine.vanishInterval; // Faster vanish at higher levels
                    this.state.vanishDuration = (game.level >= 10) ? 200 : config.divine.vanishDuration; // Shorter vanish duration
                } else if (this.type === "Thor") {
                    this.state.attackDelay = config.divine.lightningDelay;
                    this.state.attacking = false;
                } else if (this.type === "Buddha") {
                    this.state.circleRadius = 0;
                    this.state.circleGrowth = config.divine.circleGrowth * (1 + game.level / 10); // Faster growth at higher levels
                } else if (this.type === "Hermes") {
                    this.speed *= 1.5; // Hermes is naturally faster
                } else if (this.type === "Zeus") {
                    this.state.attacking = false;
                    this.state.attackInterval = 3000 - (game.level * 50); // Zeus attacks faster at higher levels
                    if (this.state.attackInterval < 1000) this.state.attackInterval = 1000;
                    this.state.lastAttack = performance.now();
                } else if (this.type === "Odin") {
                    this.baseX = this.x;
                    this.state.shieldActive = false;
                    this.state.lastShield = performance.now() - 3000; // Allow shield from start
                    this.state.shieldDuration = 2000 - (game.level * 20); // Shorter shield duration at higher levels
                    if (this.state.shieldDuration < 500) this.state.shieldDuration = 500;
                } else if (this.type === "Ra") {
                    this.state.circleRadius = 0;
                    this.state.circleGrowth = config.divine.circleGrowth * (1 + game.level / 10);
                    this.state.lastFlare = performance.now();
                    this.state.flareActive = false;
                    this.state.flareInterval = 3000 - (game.level * 50);
                    if (this.state.flareInterval < 1000) this.state.flareInterval = 1000;
                } else if (this.type === "Anubis") {
                    this.state.lastTeleport = performance.now();
                    this.state.teleportInterval = 1600 - (game.level * 30); // Anubis teleports faster
                    if (this.state.teleportInterval < 500) this.state.teleportInterval = 500;
                }
            }
            update(dt) {
                const now = performance.now();
                let effectiveDt = dt;
                if (game.slowTimeActive) { effectiveDt = dt * 0.5; } // Enemies are affected by slow time

                switch (this.type) {
                    case "Loki": this.updateLoki(effectiveDt); break;
                    case "Thor": this.updateThor(effectiveDt); break;
                    case "Buddha": this.updateBuddha(effectiveDt); break;
                    case "Sun": this.updateSun(effectiveDt); break;
                    case "Hermes": this.moveTowardsPlayer(effectiveDt); break;
                    case "Zeus": this.updateZeus(effectiveDt); break;
                    case "Odin": this.updateOdin(effectiveDt); break;
                    case "Ra": this.updateRa(effectiveDt); break;
                    case "Anubis": this.updateAnubis(effectiveDt); break;
                    case config.divine.boss: this.updateBoss(effectiveDt); break;
                    default: this.moveTowardsPlayer(effectiveDt);
                }
            }
            updateLoki(dt) {
                if (performance.now() - this.state.lastVanish > this.state.vanishInterval) {
                    this.visible = false;
                    setTimeout(() => {
                        this.visible = true;
                        // Teleport to a random edge
                        const side = Math.floor(Math.random() * 4);
                        if (side === 0) { this.x = 0; this.y = Math.random() * config.canvas.height; }
                        else if (side === 1) { this.x = config.canvas.width; this.y = Math.random() * config.canvas.height; }
                        else if (side === 2) { this.x = Math.random() * config.canvas.width; this.y = 0; }
                        else { this.x = Math.random() * config.canvas.width; this.y = config.canvas.height; }
                        this.state.lastVanish = performance.now();
                    }, this.state.vanishDuration);
                }
                if (this.visible) { this.moveTowardsPlayer(dt); }
            }
            updateThor(dt) {
                const desiredDistance = 100; // Adjusted desired distance
                const d = Utils.distance(this.x, this.y, game.player.x, game.player.y);
                if (d > desiredDistance) { this.moveTowardsPlayer(dt); }
                else if (!this.state.attacking) {
                    this.state.attacking = true;
                    this.state.chargeStart = performance.now();
                    setTimeout(() => {
                        const angle = Utils.angleBetween(this.x, this.y, game.player.x, game.player.y);
                        // Lightning strikes in a line towards the player's last known position
                        const lightningEndX = this.x + Math.cos(angle) * 150; // Adjusted lightning length
                        const lightningEndY = this.y + Math.sin(angle) * 150;
                        const lineDist = Utils.pointToLineDistance(game.player.x, game.player.y, this.x, this.y, lightningEndX, lightningEndY);
                        if (lineDist < 15) { // Adjusted hit detection radius
                            playerHitSound.currentTime = 0;
                            playerHitSound.play();
                            game.loseLife(this.baseHit);
                        }
                        this.state.attacking = false;
                    }, this.state.attackDelay);
                }
            }
            updateBuddha(dt) {
                this.state.circleRadius += this.state.circleGrowth * dt;
                // If the circle radius exceeds a certain size, reset it
                if (this.state.circleRadius > Math.max(config.canvas.width, config.canvas.height) * 0.7) {
                    this.state.circleRadius = 0;
                }
                // Check if player is on the circle's edge
                const diff = Math.abs(Utils.distance(this.x, this.y, game.player.x, game.player.y) - this.state.circleRadius);
                if (diff < 10) { // Player takes damage if close to the circle's edge, adjusted
                    playerHitSound.currentTime = 0;
                    playerHitSound.play();
                    game.loseLife(this.baseHit);
                    this.state.circleRadius = 0; // Reset circle after hit
                }
            }
            updateSun(dt) {
                // Sun glows less as it takes damage
                this.glow = 1 - ((config.divine.sunHits - this.hp) / config.divine.sunHits);
            }
            updateZeus(dt) {
                const desiredDistance = 100; // Adjusted desired distance
                let d = Utils.distance(this.x, this.y, game.player.x, game.player.y);
                if (d > desiredDistance) { this.moveTowardsPlayer(dt); }
                else if (!this.state.attacking && performance.now() - this.state.lastAttack >= this.state.attackInterval) {
                    this.state.attacking = true;
                    this.state.chargeStart = performance.now();
                    this.state.attackX = game.player.x; // Target player's current X position
                    setTimeout(() => {
                        // Zeus strikes vertically at the targeted X position
                        if (Math.abs(game.player.x - this.state.attackX) < 25) { // Adjusted hit radius
                            playerHitSound.currentTime = 0;
                            playerHitSound.play();
                            game.loseLife(this.baseHit);
                        }
                        this.state.attacking = false;
                        this.state.lastAttack = performance.now();
                    }, 750); // Adjusted charge time for Zeus's attack
                }
            }
            updateOdin(dt) {
                if (!this.state.shieldActive && (performance.now() - this.state.lastShield >= 3000)) {
                    this.state.shieldActive = true;
                    this.state.shieldStart = performance.now();
                }
                if (this.state.shieldActive) {
                    if (performance.now() - this.state.shieldStart >= this.state.shieldDuration) {
                        this.state.shieldActive = false;
                        this.state.lastShield = performance.now();
                    }
                }
                // Odin moves in a small sine wave pattern
                if (!this.baseX) { this.baseX = this.x; }
                this.x = this.baseX + 10 * Math.sin(performance.now() / 1000 * (1 + game.level / 20)); // Adjusted oscillation amplitude
                this.moveTowardsPlayer(dt); // Still moves towards player
            }
            updateRa(dt) {
                this.state.circleRadius = (this.state.circleRadius || 0) + (this.state.circleGrowth || config.divine.circleGrowth) * dt;
                if (this.state.circleRadius > this.size * 3) { // Reset circle after it gets too big, adjusted
                    this.state.circleRadius = 0;
                }

                if (performance.now() - this.state.lastFlare >= this.state.flareInterval && !this.state.flareActive) {
                    this.state.flareActive = true;
                    this.state.flareStart = performance.now();
                }
                if (this.state.flareActive) {
                    if (performance.now() - this.state.flareStart < 250) { // Flare duration, adjusted
                        if (Utils.distance(this.x, this.y, game.player.x, game.player.y) < this.size + 10) { // If player is close during flare, adjusted
                            playerHitSound.currentTime = 0;
                            playerHitSound.play();
                            game.loseLife(this.baseHit);
                        }
                    } else {
                        this.state.flareActive = false;
                        this.state.lastFlare = performance.now();
                    }
                }
                this.moveTowardsPlayer(dt); // Ra still moves towards player
            }
            updateAnubis(dt) {
                if (!this.state.lastTeleport) { this.state.lastTeleport = performance.now(); }
                if (performance.now() - this.state.lastTeleport >= this.state.teleportInterval) {
                    // Teleport to a random edge
                    let edge = Math.floor(Math.random() * 4);
                    if (edge === 0) { this.x = 0; this.y = Math.random() * config.canvas.height; }
                    else if (edge === 1) { this.x = config.canvas.width; this.y = Math.random() * config.canvas.height; }
                    else if (edge === 2) { this.x = Math.random() * config.canvas.width; this.y = 0; }
                    else { this.x = Math.random() * config.canvas.width; this.y = config.canvas.height; }
                    this.state.lastTeleport = performance.now();
                }
                this.moveTowardsPlayer(dt); // Anubis still moves towards player when not teleporting
            }
            updateBoss(dt) {
                this.moveWithBounce(dt); // Boss moves and bounces off walls
                if (!this.state.attacking && Math.random() < 0.05 * dt * 60) { // Boss attacks randomly
                    this.state.attacking = true;
                    setTimeout(() => {
                        const angle = Utils.angleBetween(this.x, this.y, game.player.x, game.player.y);
                        const lightningEndX = this.x + Math.cos(angle) * 100; // Adjusted lightning length
                        const lightningEndY = this.y + Math.sin(angle) * 100;
                        const lineDist = Utils.pointToLineDistance(game.player.x, game.player.y, this.x, this.y, lightningEndX, lightningEndY);
                        if (lineDist < 15) { // Adjusted hit detection radius
                            playerHitSound.currentTime = 0;
                            playerHitSound.play();
                            game.loseLife(this.baseHit);
                        }
                        this.state.attacking = false;
                    }, 400); // Adjusted boss attack delay
                }
            }
            moveTowardsPlayer(dt) {
                const angle = Utils.angleBetween(this.x, this.y, game.player.x, game.player.y);
                this.x += Math.cos(angle) * this.speed * dt;
                this.y += Math.sin(angle) * this.speed * dt;
            }
            moveWithBounce(dt) {
                // Initial velocity for boss if not set
                if (this.vx === undefined) {
                    const angle = Math.random() * Math.PI * 2;
                    this.vx = Math.cos(angle) * this.speed;
                    this.vy = Math.sin(angle) * this.speed;
                }

                let newX = this.x + this.vx * dt;
                let newY = this.y + this.vy * dt;

                // Bounce off horizontal walls
                if (newX < this.size || newX > config.canvas.width - this.size) {
                    this.vx *= -1;
                    newX = this.x + this.vx * dt; // Re-calculate to prevent sticking
                }
                // Bounce off vertical walls
                if (newY < this.size || newY > config.canvas.height - this.size) {
                    this.vy *= -1;
                    newY = this.y + this.vy * dt; // Re-calculate to prevent sticking
                }
                this.x = newX;
                this.y = newY;
            }
            draw(ctx) {
                // Odin's shield
                if (this.type === "Odin" && this.state.shieldActive) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2); // Adjusted shield size
                    ctx.strokeStyle = "rgba(0,0,255,0.5)";
                    ctx.lineWidth = 2; // Adjusted line width
                    ctx.stroke();
                }
                // Ra's flare aura
                if (this.type === "Ra" && this.state.flareActive) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 10, 0, Math.PI * 2); // Adjusted flare size
                    ctx.strokeStyle = "rgba(255,165,0,0.7)";
                    ctx.lineWidth = 2; // Adjusted line width
                    ctx.stroke();
                }
                // Zeus charging indicator
                if (this.type === "Zeus" && this.state.attacking) {
                    ctx.fillStyle = "#ffff00";
                    ctx.font = "bold 8px Arial"; // Adjusted font size
                    ctx.textAlign = "center";
                    ctx.fillText("Charging...", this.x, this.y - this.size - 15); // Adjusted text position
                    // Draw target line for Zeus's attack
                    ctx.strokeStyle = "rgba(255,255,0,0.5)";
                    ctx.lineWidth = 1; // Adjusted line width
                    ctx.beginPath();
                    ctx.moveTo(this.state.attackX, 0);
                    ctx.lineTo(this.state.attackX, config.canvas.height);
                    ctx.stroke();
                }

                // Sun's glow effect
                if (this.type === "Sun") {
                    const glow = this.glow || 1;
                    ctx.fillStyle = `rgba(255,165,0,${glow})`;
                } else {
                    ctx.fillStyle = "#ff0000"; // Default enemy color
                }

                // Loki's invisibility
                if (!this.visible) ctx.globalAlpha = 0.5;

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Thor's attack countdown
                if (this.type === "Thor" && this.state.attacking) {
                    const remaining = Math.max(0, ((this.state.attackDelay || config.divine.lightningDelay) - (performance.now() - this.state.chargeStart)) / 1000).toFixed(1);
                    ctx.fillStyle = "#ffff00";
                    ctx.font = "bold 8px Arial"; // Adjusted font size
                    ctx.fillText("⚡ " + remaining + "s", this.x, this.y - this.size - 10); // Adjusted text position
                }
                // Buddha's expanding circle
                if (this.type === "Buddha") {
                    ctx.strokeStyle = "#ffcc00";
                    ctx.lineWidth = 1.5; // Adjusted line width
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.state.circleRadius || 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // Enemy type label
                ctx.fillStyle = "#fff";
                ctx.font = "bold 8px Arial"; // Adjusted font size
                ctx.textAlign = "center";
                ctx.fillText(this.type, this.x, this.y - this.size - 12); // Adjusted text position

                // Health bar for enemies with more than 1 HP
                if (this.maxHp > 1) {
                    const barWidth = this.size * 1.5; // Adjusted bar width
                    const barHeight = 2; // Adjusted bar height
                    const barX = this.x - barWidth / 2;
                    const barY = this.y - this.size - 7; // Adjusted bar position
                    ctx.fillStyle = "#555";
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    const healthWidth = (this.hp / this.maxHp) * barWidth;
                    ctx.fillStyle = "#0f0";
                    ctx.fillRect(barX, barY, healthWidth, barHeight);
                }
            }
        }

        // Helper function for random spawn from edges.
        function getRandomSpawn() {
            if (Math.random() < 0.5) { // Spawn from left/right edge
                return { x: (Math.random() < 0.5 ? 0 : config.canvas.width), y: Math.random() * config.canvas.height };
            } else { // Spawn from top/bottom edge
                return { x: Math.random() * config.canvas.width, y: (Math.random() < 0.5 ? 0 : config.canvas.height) };
            }
        }

        // Main Game class.
        class Game {
            constructor() {
                this.canvas = canvas;
                this.ctx = ctx;
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.scoreMultiplier = 1;
                this.player = new Player(config.canvas.width / 2, config.canvas.height / 2);
                this.bullets = [];
                this.enemies = [];
                this.powerUps = [];
                this.particles = [];
                this.stars = [];
                this.lastEnemySpawn = performance.now();
                this.lastPowerUpSpawn = performance.now();
                this.lastMagicBulletTime = performance.now();
                this.running = false;
                this.paused = false;
                this.lastKillTime = 0;
                this.comboCount = 0;
                this.playerPerks = {};
                this.shopOpen = false;
                this.upgradeOptions = [];
                this.slowTimeActive = false;
                this.slowTimeEnd = 0;
                this.speedBoostActive = false;
                this.speedBoostEnd = 0;
                // For shield perk, store initial durability to calculate alpha
                this.playerPerks.initialShieldDurability = 5;

                for (let i = 0; i < 75; i++) { this.stars.push(new Star()); } // Adjusted stars for new canvas size
            }
            start() {
                this.reset();
                this.running = true;
                this.paused = false;
                lastTime = performance.now();
                // Try playing music and set volume after successful play
                backgroundMusic.play().then(() => {
                    backgroundMusic.volume = 0.3;
                }).catch(e => console.log("Background music autoplay failed:", e));
                requestAnimationFrame(this.gameLoop.bind(this));
            }
            reset() {
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.scoreMultiplier = 1;
                this.player = new Player(config.canvas.width / 2, config.canvas.height / 2);
                this.bullets = [];
                this.enemies = [];
                this.powerUps = [];
                this.particles = [];
                this.lastEnemySpawn = performance.now();
                this.lastPowerUpSpawn = performance.now();
                this.lastMagicBulletTime = performance.now();
                this.comboCount = 0;
                this.lastKillTime = 0;
                this.playerPerks = {}; // Reset all perks
                this.playerPerks.initialShieldDurability = 5; // Reset initial shield durability
                this.shopOpen = false;
                this.slowTimeActive = false;
                this.speedBoostActive = false;
            }
            togglePause() { this.paused = !this.paused; }
            openShop() {
                this.shopOpen = true;
                this.paused = true; // Pause game when shop is open
                const possibleUpgrades = [
                    { name: "Increase Bullet Speed", cost: 50, effect: () => { config.bullet.speed *= 1.1; } },
                    { name: "Increase Player Speed", cost: 50, effect: () => { config.player.maxSpeed += 10; } },
                    {
                        name: "Improve Shield", cost: 75, effect: () => {
                            if (this.playerPerks.shield) { this.playerPerks.shieldDurability += 1; }
                            else { this.playerPerks.shield = true; this.playerPerks.shieldDurability = this.playerPerks.initialShieldDurability; }
                        }
                    },
                    { name: "Boost Score Multiplier", cost: 100, effect: () => { this.scoreMultiplier *= 1.1; } },
                    { name: "Extra Life", cost: 150, effect: () => { this.lives++; } },
                    { name: "Invisibility Perk", cost: 125, effect: () => { this.playerPerks.invisibility = true; this.playerPerks.invisibilityDuration = 3000; this.playerPerks.invisibilityStart = performance.now(); } },
                    { name: "Magic Bullets", cost: 200, effect: () => { this.playerPerks.magicBullets = true; } },
                    { name: "Magnetic Field", cost: 75, effect: () => { this.playerPerks.magnetic = true; } }
                ];
                this.upgradeOptions = [];
                // Select 3 random unique upgrades
                while (this.upgradeOptions.length < 3) {
                    let upgrade = possibleUpgrades[Math.floor(Math.random() * possibleUpgrades.length)];
                    // Ensure unique upgrades and don't offer upgrades for already maxed perks (if applicable)
                    if (!this.upgradeOptions.find(u => u.name === upgrade.name)) {
                        this.upgradeOptions.push(upgrade);
                    }
                }
            }
            processShopClick(x, y) {
                for (let option of this.upgradeOptions) {
                    // Check if click is within option bounds
                    if (x >= option.x && x <= option.x + option.width &&
                        y >= option.y && y <= option.y + option.height) {
                        if (this.score >= option.cost) {
                            option.effect();
                            this.score -= option.cost; // Deduct cost
                            this.shopOpen = false;
                            this.paused = false;
                            break;
                        } else {
                            console.log("Not enough score for this upgrade!"); // Visual feedback could be added here
                        }
                    }
                }
            }
            update(dt, timestamp) {
                if (!this.paused && !this.shopOpen) {
                    const now = performance.now();

                    // Update stars, player, bullets, enemies, power-ups, and particles.
                    this.stars.forEach(star => star.update(dt));
                    this.player.update(dt, keysPressed);

                    let effectiveDt = dt;
                    if (this.slowTimeActive) {
                        effectiveDt = dt * 0.5; // Game elements move slower
                        if (now > this.slowTimeEnd) { this.slowTimeActive = false; }
                    }

                    this.bullets = this.bullets.filter(bullet => {
                        bullet.update(effectiveDt);
                        // Remove bullets that are too old or off-screen
                        return (timestamp - bullet.created) < bullet.lifetime &&
                            bullet.x > -10 && bullet.x < config.canvas.width + 10 &&
                            bullet.y > -10 && bullet.y < config.canvas.height + 10;
                    });

                    this.enemies.forEach(enemy => enemy.update(effectiveDt));
                    this.powerUps.forEach(pu => {
                        pu.update(effectiveDt);
                        // Magnetic perk pulls power-ups towards player
                        if (this.playerPerks.magnetic) {
                            let dx = this.player.x - pu.x;
                            let dy = this.player.y - pu.y;
                            let mag = Utils.distance(0, 0, dx, dy);
                            if (mag > 0) {
                                const magnetSpeed = 70; // Adjusted magnet speed
                                pu.x += (dx / mag) * magnetSpeed * dt;
                                pu.y += (dy / mag) * magnetSpeed * dt;
                            }
                        }
                    });

                    this.particles.forEach(p => p.update(dt));
                    this.particles = this.particles.filter(p => (timestamp - p.created) < p.lifetime);

                    // Deactivate speed boost if time is up
                    if (this.speedBoostActive && now > this.speedBoostEnd) { this.speedBoostActive = false; }

                    // Deactivate invisibility if time is up
                    if (this.playerPerks.invisibility) {
                        if (now > this.playerPerks.invisibilityStart + this.playerPerks.invisibilityDuration) {
                            delete this.playerPerks.invisibility;
                            delete this.playerPerks.invisibilityStart;
                            delete this.playerPerks.invisibilityDuration;
                        }
                    }

                    // Magic Bullet perk logic: auto-fire homing bullets at nearest enemy
                    if (this.playerPerks.magicBullets) {
                        // Fire a magic bullet every 1.2 seconds (or config.divine.lightningDelay)
                        if (now - this.lastMagicBulletTime > config.divine.lightningDelay / 2 && this.enemies.length > 0) {
                            let nearest = this.enemies[0];
                            let nearestDist = Utils.distance(this.player.x, this.player.y, nearest.x, nearest.y);
                            for (let enemy of this.enemies) {
                                let d = Utils.distance(this.player.x, this.player.y, enemy.x, enemy.y);
                                if (d < nearestDist) { nearestDist = d; nearest = enemy; }
                            }
                            const angle = Utils.angleBetween(this.player.x, this.player.y, nearest.x, nearest.y);
                            const mb = new MagicBullet(this.player.x, this.player.y, angle, nearest);
                            this.bullets.push(mb);
                            this.lastMagicBulletTime = now;
                        }
                    }

                    this.checkCollisions();
                    this.updateLevel();

                    // Enemy spawning
                    if (timestamp - this.lastEnemySpawn > config.enemy.spawnInterval) {
                        this.spawnEnemy();
                        this.lastEnemySpawn = timestamp;
                    }

                    // Power-up spawning
                    if (timestamp - this.lastPowerUpSpawn > config.powerUpSpawnInterval) {
                        this.spawnPowerUp();
                        this.lastPowerUpSpawn = timestamp;
                    }
                }
            }
            draw() {
                // Clear and redraw canvas.
                this.ctx.clearRect(0, 0, config.canvas.width, config.canvas.height);
                this.stars.forEach(star => star.draw(ctx));

                // Draw game UI if not in shop or paused
                if (!this.shopOpen && !this.paused) {
                    let expProgress = (this.score % config.levelUpScore) / config.levelUpScore;
                    ctx.fillStyle = "#333";
                    ctx.fillRect(0, 0, config.canvas.width, 10); // Experience bar background, adjusted height
                    ctx.fillStyle = "#0f0";
                    ctx.fillRect(0, 0, config.canvas.width * expProgress, 10); // Experience bar fill, adjusted height

                    ctx.fillStyle = "#fff";
                    ctx.font = "10px 'Inter', sans-serif"; // Adjusted font size
                    ctx.textAlign = "center";
                    ctx.fillText(`Score: ${this.score}   Lives: ${this.lives}   Level: ${this.level}`, config.canvas.width / 2, 25); // Adjusted Y position

                    if (this.comboCount > 1) {
                        ctx.fillStyle = "#ffcc00"; // Combo text color
                        ctx.fillText(`Combo: ${this.comboCount}x`, config.canvas.width / 2, 35); // Adjusted Y position
                    }
                    if (this.slowTimeActive) {
                        ctx.fillStyle = "#00ccff";
                        ctx.fillText("Time Slow! ⏳", config.canvas.width / 2, 45); // Adjusted Y position
                    }
                    if (this.speedBoostActive) {
                        ctx.fillStyle = "#ff00ff";
                        ctx.fillText("Speed Boost! ⚡", config.canvas.width / 2, 55); // Adjusted Y position
                    }
                    if (this.playerPerks.magnetic) {
                        ctx.fillStyle = "#ff9900";
                        ctx.fillText("Magnetic Field Active!", config.canvas.width / 2, 65); // Adjusted Y position
                    }
                    if (this.playerPerks.magicBullets) {
                        ctx.fillStyle = "#ff00ff";
                        ctx.fillText("Magic Bullets Active! ✨", config.canvas.width / 2, 75); // Adjusted Y position
                    }
                }

                this.player.draw(this.ctx);
                this.bullets.forEach(bullet => bullet.draw(this.ctx));
                this.enemies.forEach(enemy => enemy.draw(this.ctx));
                this.powerUps.forEach(pu => pu.draw(this.ctx));
                this.particles.forEach(p => p.draw(this.ctx));

                // Draw joystick if active.
                if (joystick.active) {
                    ctx.beginPath();
                    // Joystick drawn relative to bottom-left of canvas
                    const joystickBaseX = config.canvas.width * 0.2;
                    const joystickBaseY = config.canvas.height * 0.8;
                    ctx.arc(joystickBaseX, joystickBaseY, 20, 0, Math.PI * 2); // Adjusted joystick size
                    ctx.fillStyle = "rgba(255,255,255,0.2)";
                    ctx.fill();
                    let dx = joystick.currentX - joystick.startX;
                    let dy = joystick.currentY - joystick.startY;
                    let dist = Math.hypot(dx, dy);
                    let maxDist = 20; // Adjusted maxDist
                    if (dist > maxDist) { dx = dx / dist * maxDist; dy = dy / dist * maxDist; }
                    ctx.beginPath();
                    ctx.arc(joystickBaseX + dx, joystickBaseY + dy, 10, 0, Math.PI * 2); // Adjusted joystick knob size
                    ctx.fillStyle = "rgba(255,255,255,0.5)";
                    ctx.fill();
                }

                // Draw Top 2 High Scores at bottom right
                let leaderboard = JSON.parse(localStorage.getItem("divineShooterLeaderboard")) || [];
                if (leaderboard.length > 0) {
                    ctx.fillStyle = "#fff";
                    ctx.font = "10px 'Inter', sans-serif";
                    ctx.textAlign = "right";
                    ctx.fillText("High Scores:", config.canvas.width - 10, config.canvas.height - 30);
                    for (let i = 0; i < Math.min(2, leaderboard.length); i++) { // Limit to top 2
                        const entry = leaderboard[i];
                        ctx.fillText(`${i + 1}. ${entry.name}: ${entry.score}`, config.canvas.width - 10, config.canvas.height - 15 + (i * 10));
                    }
                }


                // Draw shop overlay
                if (this.shopOpen) {
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
                    this.ctx.fillRect(0, 0, config.canvas.width, config.canvas.height);
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "bold 1.2em 'Inter', sans-serif";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("Upgrade Shop", config.canvas.width / 2, config.canvas.height / 2 - 40);
                    this.ctx.font = "0.8em 'Inter', sans-serif";
                    this.ctx.fillText(`Your Score: ${this.score}`, config.canvas.width / 2, config.canvas.height / 2 - 20);

                    const optionWidth = Math.min(150, config.canvas.width * 0.7);
                    const optionHeight = 30;
                    const startY = config.canvas.height / 2 - 5;
                    const padding = 10;

                    this.upgradeOptions.forEach((option, index) => {
                        const x = config.canvas.width / 2 - optionWidth / 2;
                        const y = startY + index * (optionHeight + padding);
                        option.x = x;
                        option.y = y;
                        option.width = optionWidth;
                        option.height = optionHeight;

                        ctx.fillStyle = this.score >= option.cost ? "#007bff" : "#888";
                        ctx.beginPath();
                        ctx.roundRect(x, y, optionWidth, optionHeight, 5);
                        ctx.fill();
                        ctx.strokeStyle = "#fff";
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        ctx.fillStyle = "#fff";
                        ctx.font = "bold 0.7em 'Inter', sans-serif";
                        ctx.fillText(option.name, x + optionWidth / 2, y + optionHeight / 2 - 5);
                        ctx.font = "0.6em 'Inter', sans-serif";
                        ctx.fillText(`Cost: ${option.cost} Score`, x + optionWidth / 2, y + optionHeight / 2 + 8);
                    });
                }

                // Game Over and Continue options
                if (!this.running && this.lives <= 0) {
                    this.ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
                    this.ctx.fillRect(0, 0, config.canvas.width, config.canvas.height);
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "bold 1.5em 'Inter', sans-serif";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText("GAME OVER", config.canvas.width / 2, config.canvas.height / 2 - 30);
                    this.ctx.font = "bold 0.8em 'Inter', sans-serif";
                    this.ctx.fillText(`Final Score: ${this.score}`, config.canvas.width / 2, config.canvas.height / 2 - 5);

                    // "Continue?" button
                    const continueButtonWidth = Math.min(120, config.canvas.width * 0.6);
                    const continueButtonHeight = 30;
                    const continueButtonX = config.canvas.width / 2 - continueButtonWidth / 2;
                    const continueButtonY = config.canvas.height / 2 + 15;

                    ctx.fillStyle = this.score >= config.continueCost ? "#00ff00" : "#ff0000";
                    ctx.beginPath();
                    ctx.roundRect(continueButtonX, continueButtonY, continueButtonWidth, continueButtonHeight, 5);
                    ctx.fill();
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.fillStyle = "#000";
                    ctx.font = "bold 0.7em 'Inter', sans-serif";
                    ctx.fillText(`Continue? (${config.continueCost} Score)`, config.canvas.width / 2, continueButtonY + 18);
                    game.continueButton = { x: continueButtonX, y: continueButtonY, width: continueButtonWidth, height: continueButtonHeight };

                    // "Restart" button
                    const restartButtonWidth = Math.min(120, config.canvas.width * 0.6);
                    const restartButtonHeight = 30;
                    const restartButtonX = config.canvas.width / 2 - restartButtonWidth / 2;
                    const restartButtonY = config.canvas.height / 2 + 55;

                    ctx.fillStyle = "#007bff";
                    ctx.beginPath();
                    ctx.roundRect(restartButtonX, restartButtonY, restartButtonWidth, restartButtonHeight, 5);
                    ctx.fill();
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.fillStyle = "#000";
                    ctx.font = "bold 0.7em 'Inter', sans-serif";
                    ctx.fillText("Restart Game", config.canvas.width / 2, restartButtonY + 18);
                    game.restartButton = { x: restartButtonX, y: restartButtonY, width: restartButtonWidth, height: restartButtonHeight };
                }
            }
            gameLoop(timestamp) {
                const dt = (timestamp - lastTime) / 1000;
                lastTime = timestamp;

                this.update(dt, timestamp);
                this.draw();

                if (this.running) {
                    requestAnimationFrame(this.gameLoop.bind(this));
                } else {
                    // Only draw leaderboard if game is over and not continuing/restarting
                    if (this.lives <= 0) {
                        this.drawLeaderboard();
                    }
                }
            }
            checkCollisions() {
                // Bullet-Enemy collisions
                this.bullets = this.bullets.filter(bullet => {
                    let hitEnemy = false;
                    this.enemies = this.enemies.filter(enemy => {
                        if (enemy.visible && Utils.distance(bullet.x, bullet.y, enemy.x, enemy.y) < enemy.size + bullet.size) {
                            if (enemy.type === "Odin" && enemy.state.shieldActive) {
                                // Odin's shield blocks the bullet
                                hitEnemy = true; // Bullet is consumed
                                return true; // Enemy remains
                            }
                            // Play sound on hit, with error handling
                            try {
                                shootSound.currentTime = 0;
                                shootSound.play();
                            } catch (e) {
                                console.error("Error playing shoot sound:", e);
                            }
                            enemy.hp--;
                            for (let i = 0; i < config.particles.count; i++) {
                                this.particles.push(new Particle(enemy.x, enemy.y));
                            }
                            hitEnemy = true; // Mark bullet for removal

                            if (enemy.hp <= 0) {
                                this.score += 100 * this.scoreMultiplier;
                                const now = performance.now();
                                if (now - this.lastKillTime < 1000) { this.comboCount++; } // Combo within 1 second
                                else { this.comboCount = 1; }
                                this.lastKillTime = now;
                                return false; // Remove enemy
                            }
                            return true; // Enemy remains
                        }
                        return true; // Enemy remains
                    });
                    return !hitEnemy; // Remove bullet if it hit an enemy
                });

                // Player-Enemy collisions
                this.enemies = this.enemies.filter(enemy => {
                    if (enemy.visible && Utils.distance(this.player.x, this.player.y, enemy.x, enemy.y) < config.player.size + enemy.size) {
                        if (!this.playerPerks.invisibility) { // Player cannot be hit if invisible
                            // Play sound on hit, with error handling
                            try {
                                playerHitSound.currentTime = 0;
                                playerHitSound.play();
                            } catch (e) {
                                console.error("Error playing player hit sound:", e);
                            }
                            this.loseLife(enemy.baseHit);
                            return false; // Remove enemy on collision
                        }
                    }
                    return true; // Enemy remains
                });

                // Player-PowerUp collisions
                this.powerUps = this.powerUps.filter(pu => {
                    if (Utils.distance(this.player.x, this.player.y, pu.x, pu.y) < config.player.size + pu.size) {
                        if (pu.type === "extraLife") {
                            this.lives++;
                        } else if (pu.type === "timeSlow") {
                            this.slowTimeActive = true;
                            this.slowTimeEnd = performance.now() + 5000; // 5 seconds slow time
                        } else if (pu.type === "speedBoost") {
                            this.speedBoostActive = true;
                            this.speedBoostEnd = performance.now() + 7000; // 7 seconds speed boost
                        }
                        return false; // Remove power-up
                    }
                    return true; // Power-up remains
                });
            }
            loseLife(damage = 1) {
                if (this.playerPerks.shield && this.playerPerks.shieldDurability > 0) {
                    this.playerPerks.shieldDurability -= damage;
                    console.log("Shield hit! Durability left: " + this.playerPerks.shieldDurability);
                } else {
                    this.lives -= damage;
                    if (this.lives <= 0) {
                        this.gameOver();
                    }
                }
            }
            gameOver() {
                this.running = false;
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0; // Reset music
                this.updateLeaderboard(config.player.name, this.score);
                mainUiOverlay.style.display = 'flex'; // Show the overlay for game over
            }
            updateLevel() {
                // Level up when score reaches the threshold
                if (this.score >= this.level * config.levelUpScore) {
                    this.level++;
                    config.player.level = this.level; // Update player level in config for enemy scaling
                    this.openShop(); // Open shop on level up
                }
            }
            spawnEnemy() {
                const types = config.divine.types;
                let chosenType = types[Math.floor(Math.random() * types.length)];

                // Ensure a boss spawns at certain levels
                if (this.level % 5 === 0 && this.enemies.length === 0) { // Spawn boss every 5 levels if no enemies are present
                    chosenType = config.divine.boss;
                } else if (this.level % 2 === 0 && Math.random() < 0.3) { // Higher chance for specific enemies at higher levels
                    chosenType = types[Math.floor(Math.random() * types.length)]; // Pick any type for variety
                }

                this.enemies.push(new Enemy(chosenType, this));
            }
            spawnPowerUp() {
                const powerUpTypes = ["extraLife", "timeSlow", "speedBoost"];
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                const x = Math.random() * config.canvas.width;
                const y = Math.random() * config.canvas.height;
                this.powerUps.push(new PowerUp(type, x, y));
            }
            updateLeaderboard(name, score) {
                let leaderboard = JSON.parse(localStorage.getItem("divineShooterLeaderboard")) || [];
                leaderboard.push({ name: name, score: score });
                leaderboard.sort((a, b) => b.score - a.score); // Sort descending
                leaderboard = leaderboard.slice(0, 5); // Keep top 5
                localStorage.setItem("divineShooterLeaderboard", JSON.stringify(leaderboard));
                this.drawLeaderboard(); // Update the full leaderboard on the overlay
            }
            drawLeaderboard() {
                lbListEl.innerHTML = "";
                let leaderboard = JSON.parse(localStorage.getItem("divineShooterLeaderboard")) || [];
                // Add a title to the leaderboard
                const titleLi = document.createElement("li");
                titleLi.innerHTML = "<strong>Leaderboard</strong>";
                lbListEl.appendChild(titleLi);

                if (leaderboard.length === 0) {
                    const noEntryLi = document.createElement("li");
                    noEntryLi.textContent = "No scores yet!";
                    lbListEl.appendChild(noEntryLi);
                } else {
                    leaderboard.forEach((entry, index) => {
                        const li = document.createElement("li");
                        li.textContent = `${index + 1}. ${entry.name}: ${entry.score}`;
                        lbListEl.appendChild(li);
                    });
                }
            }
        }

        const game = new Game();
        let lastTime = 0;
        let keysPressed = {};

        // Event Listeners for Keyboard Controls (Desktop)
        window.addEventListener("keydown", (e) => {
            keysPressed[e.key] = true;
            if (e.key === " ") { // Spacebar for shooting
                e.preventDefault(); // Prevent scrolling
                if (!game.paused && !game.shopOpen && game.running) {
                    const angle = Utils.angleBetween(game.player.x, game.player.y, mouseX, mouseY);
                    game.bullets.push(new Bullet(game.player.x, game.player.y, angle));
                    try {
                        shootSound.currentTime = 0;
                        shootSound.play();
                    } catch (e) {
                        console.error("Error playing shoot sound:", e);
                    }
                }
            }
            if (e.key === "p" || e.key === "P") {
                game.togglePause();
            }
        });

        window.addEventListener("keyup", (e) => {
            keysPressed[e.key] = false;
        });

        // Mouse movement for aiming (Desktop)
        let mouseX = 0;
        let mouseY = 0;
        canvas.addEventListener("mousemove", (e) => {
            // Adjust mouse coordinates relative to the canvas
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        // Mouse click for shooting or shop interaction (Desktop)
        canvas.addEventListener("click", (e) => {
            // Adjust click coordinates relative to the canvas
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            if (game.shopOpen) {
                game.processShopClick(clickX, clickY);
            } else if (!game.running && game.lives <= 0) {
                // Handle "Continue?" button click
                if (game.continueButton && clickX >= game.continueButton.x && clickX <= game.continueButton.x + game.continueButton.width &&
                    clickY >= game.continueButton.y && clickY <= game.continueButton.y + game.continueButton.height) {
                    if (game.score >= config.continueCost) {
                        game.score -= config.continueCost;
                        game.lives = 1; // Give one life to continue
                        game.running = true;
                        game.paused = false;
                        mainUiOverlay.style.display = 'none'; // Hide overlay
                        backgroundMusic.play().then(() => {
                            backgroundMusic.volume = 0.3;
                        }).catch(e => console.log("Background music autoplay failed:", e));
                        lastTime = performance.now();
                        requestAnimationFrame(game.gameLoop.bind(game));
                    }
                }
                // Handle "Restart" button click
                if (game.restartButton && clickX >= game.restartButton.x && clickX <= game.restartButton.x + game.restartButton.width &&
                    clickY >= game.restartButton.y && clickY <= game.restartButton.y + game.restartButton.height) {
                    game.start(); // Restart the game
                    mainUiOverlay.style.display = 'none'; // Hide overlay
                }
            } else if (!game.paused && game.running) {
                // Normal shooting
                const angle = Utils.angleBetween(game.player.x, game.player.y, clickX, clickY);
                game.bullets.push(new Bullet(game.player.x, game.player.y, angle));
                try {
                    shootSound.currentTime = 0;
                    shootSound.play();
                } catch (e) {
                    console.error("Error playing shoot sound:", e);
                }
            }
        });

        // Touch events for mobile
        canvas.addEventListener("touchstart", (e) => {
            e.preventDefault(); // Prevent default browser touch behavior (like scrolling/zooming)

            // Adjust touch coordinates relative to the canvas
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            const touchY = e.touches[0].clientY - rect.top;

            if (tutorialVisible) {
                // If tutorial is visible, only allow closing it
                if (e.touches[0].target.id === 'closeTutorialBtn') {
                    tutorialOverlay.style.display = 'none';
                    tutorialVisible = false;
                    mainUiOverlay.style.display = 'flex'; // Show main UI overlay with start button
                }
                return;
            }

            if (!game.running) {
                // Handle "Start" button click on the overlay
                // Check if the touch is within the bounds of the startBtn element
                if (startBtn.offsetParent === mainUiOverlay && // Ensure startBtn is currently visible in the overlay
                    touchX >= startBtn.offsetLeft && touchX <= startBtn.offsetLeft + startBtn.offsetWidth &&
                    touchY >= startBtn.offsetTop && touchY <= startBtn.offsetTop + startBtn.offsetHeight) {
                    game.start();
                    mainUiOverlay.style.display = 'none'; // Hide overlay after starting
                    return;
                }
                // Handle game over screen buttons (drawn on canvas, so use canvas-relative touchX/Y)
                if (game.lives <= 0) {
                    if (game.continueButton && touchX >= game.continueButton.x && touchX <= game.continueButton.x + game.continueButton.width &&
                        touchY >= game.continueButton.y && touchY <= game.continueButton.y + game.continueButton.height) {
                        if (game.score >= config.continueCost) {
                            game.score -= config.continueCost;
                            game.lives = 1;
                            game.running = true;
                            game.paused = false;
                            mainUiOverlay.style.display = 'none'; // Hide overlay
                            backgroundMusic.play().then(() => {
                                backgroundMusic.volume = 0.3;
                            }).catch(e => console.log("Background music autoplay failed:", e));
                            lastTime = performance.now();
                            requestAnimationFrame(game.gameLoop.bind(game));
                        }
                    }
                    if (game.restartButton && touchX >= game.restartButton.x && touchX <= game.restartButton.x + game.restartButton.width &&
                        touchY >= game.restartButton.y && touchY <= game.restartButton.y + game.restartButton.height) {
                        game.start();
                        mainUiOverlay.style.display = 'none'; // Hide overlay
                    }
                }
                return;
            }

            if (game.shopOpen) {
                game.processShopClick(touchX, touchY);
                return;
            }

            // Determine if it's a movement touch (left half) or shooting touch (right half)
            if (touchX < config.canvas.width / 2) { // Left half for joystick
                if (!joystick.active) {
                    joystick.active = true;
                    joystick.touchId = e.touches[0].identifier;
                    joystick.startX = touchX;
                    joystick.startY = touchY;
                    joystick.currentX = touchX;
                    joystick.currentY = touchY;
                    joystick.dx = 0;
                    joystick.dy = 0;
                }
            } else { // Right half for shooting
                if (!game.paused && game.running) {
                    const angle = Utils.angleBetween(game.player.x, game.player.y, touchX, touchY);
                    game.bullets.push(new Bullet(game.player.x, game.player.y, angle));
                    try {
                        shootSound.currentTime = 0;
                        shootSound.play();
                    } catch (e) {
                        console.error("Error playing shoot sound:", e);
                    }
                }
            }
        }, { passive: false }); // Set to false to allow preventDefault

        canvas.addEventListener("touchmove", (e) => {
            e.preventDefault();
            // Adjust touch coordinates relative to the canvas
            const rect = canvas.getBoundingClientRect();
            const currentTouchX = e.touches[0].clientX - rect.left;
            const currentTouchY = e.touches[0].clientY - rect.top;

            for (let i = 0; i < e.touches.length; i++) {
                if (joystick.active && e.touches[i].identifier === joystick.touchId) {
                    joystick.currentX = currentTouchX;
                    joystick.currentY = currentTouchY;
                    joystick.dx = joystick.currentX - joystick.startX;
                    joystick.dy = joystick.currentY - joystick.startY;
                    break;
                }
            }
        }, { passive: false });

        canvas.addEventListener("touchend", (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (joystick.active && e.changedTouches[i].identifier === joystick.touchId) {
                    joystick.active = false;
                    joystick.touchId = null;
                    joystick.dx = 0;
                    joystick.dy = 0;
                    break;
                }
            }
        });

        // Initial setup and event listeners
        closeTutorialBtn.addEventListener("click", () => {
            tutorialOverlay.style.display = 'none';
            tutorialVisible = false;
            mainUiOverlay.style.display = 'flex'; // Show main UI overlay with start button
        });

        startBtn.addEventListener("click", () => {
            game.start();
            mainUiOverlay.style.display = "none"; // Hide main UI overlay after starting
        });

        // Show tutorial on first load
        if (tutorialVisible) {
            tutorialOverlay.style.display = 'flex';
            mainUiOverlay.style.display = 'none'; // Hide main UI overlay until tutorial is closed
        } else {
            tutorialOverlay.style.display = 'none';
            mainUiOverlay.style.display = 'flex'; // Show main UI overlay with start button
        }

        // Initial leaderboard draw
        game.drawLeaderboard();

        // Start the game loop only after the tutorial is closed or if it's not visible
        window.onload = function () {
            // This onload is mainly for initial setup. Game loop starts via start button click.
        }
    </script>
</body>
</html>
