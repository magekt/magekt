<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Last Light - Text RPG</title>
    <style>
        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }
        
        .title {
            text-align: center;
            font-size: 2.5em;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        .game-text {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-left: 4px solid #ffd700;
            min-height: 300px; /* Increased height */
            max-height: 500px; /* Max height for scrolling */
            overflow-y: auto; /* Enable scrolling */
            font-size: 1.1em;
            line-height: 1.6;
            white-space: pre-wrap; /* Preserves whitespace and wraps text */
            word-wrap: break-word; /* Breaks long words */
            scrollbar-width: thin;
            scrollbar-color: #ffd700 #1a1a2e;
            margin-bottom: 20px; /* Added margin-bottom */
            border-radius: 5px; /* Added border-radius */
        }

        .game-text::-webkit-scrollbar {
            width: 8px;
        }

        .game-text::-webkit-scrollbar-track {
            background: #1a1a2e;
            border-radius: 10px;
        }

        .game-text::-webkit-scrollbar-thumb {
            background-color: #ffd700;
            border-radius: 10px;
            border: 2px solid #1a1a2e;
        }

        .stats {
            background: rgba(0, 50, 100, 0.3);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px; /* Added margin-bottom */
            border: 1px solid #4a90e2;
            font-size: 0.9em;
        }
        
        .input-section {
            margin-bottom: 20px; /* Added margin-bottom */
            display: flex;
            gap: 10px;
        }
        
        .input-section input[type="text"] {
            flex-grow: 1;
            padding: 12px;
            font-size: 1.1em;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffd700;
            color: #e0e0e0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }
        
        .input-section button {
            padding: 12px 20px;
            font-size: 1.1em;
            background: #ffd700;
            color: #1a1a2e;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: background 0.2s ease;
        }
        
        .input-section button:hover {
            background: #ffed4a;
        }
        
        .commands {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px; /* Added margin-bottom */
        }
        
        .commands button {
            padding: 8px 16px;
            background: rgba(74, 144, 226, 0.3);
            color: #e0e0e0;
            border: 1px solid #4a90e2;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: background 0.2s ease;
        }
        
        .commands button:hover {
            background: rgba(74, 144, 226, 0.5);
        }
        
        .memory {
            color: #ffd700;
            font-style: italic;
        }
        
        .hope-positive {
            color: #4ade80;
        }
        
        .hope-negative {
            color: #f87171;
        }

        .achievement {
            color: #ff9800; /* Orange color for achievements */
            font-weight: bold;
        }

        .error {
            color: #f44336; /* Red color for errors */
            font-weight: bold;
        }
        
        .hidden {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            .title {
                font-size: 2em;
            }
            .input-section {
                flex-direction: column;
                align-items: stretch;
            }
            .input-section button {
                margin-left: 0;
                margin-top: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title">THE LAST LIGHT</div>
        
        <div class="stats" id="stats">
            <div id="player-stats"></div>
        </div>
        
        <div class="game-text" id="game-text">
            <div id="story-text">The world ended not with fire, but with the slow death of hope.<br>
            You are one of the few who still remember what it means to be human.<br>
            In this broken world, every choice matters.<br>
            Every life you touch changes the fate of what remains.</div>
        </div>
        
        <div class="input-section" id="name-input">
            <input type="text" id="player-name" placeholder="What do they call you, wanderer?" autocomplete="off">
            <button onclick="startGame()">Begin Journey</button>
        </div>
        
        <div class="input-section hidden" id="game-input">
            <input type="text" id="command-input" placeholder="Enter your choice..." autocomplete="off">
            <button onclick="processCommand()">Execute</button>
        </div>
        
        <div class="commands hidden" id="commands">
            <button onclick="executeCommand('stats')">Stats</button>
            <button onclick="executeCommand('wander')">Wander</button>
            <button onclick="executeCommand('rest')">Rest</button>
            <button onclick="executeCommand('remember')">Remember</button>
            <button onclick="executeCommand('inventory')">Inventory</button>
            <button onclick="executeCommand('meditate')">Meditate</button>
            <button onclick="SaveSystem.save()">Save Game</button>
            <button onclick="SaveSystem.load()">Load Game</button>
            <button onclick="executeCommand('quit')">Quit</button>
        </div>
        <div class="input-section hidden" id="restart-game-section">
            <button onclick="resetGame()">Play Again</button>
        </div>
    </div>

    <script>
        // --- Game Data and Constants ---
        const ITEM_DATA = {
            "bread": { name: "Bread", desc: "A stale piece of bread. Might offer some sustenance.", consumed: true, effects: { hp: 15, sanity: 5 } },
            "water": { name: "Water", desc: "A bottle of murky water. Better than nothing.", consumed: true, effects: { hp: 10 } },
            "faded photo": { name: "Faded Photo", desc: "A picture of a smiling family, long faded. A reminder of what was lost.", consumed: false, effects: { sanity: 10, karma: 2 } },
            "bitter memory": { name: "Bitter Memory", desc: "A fragment of past suffering. Heavy to carry.", consumed: false, effects: { sanity: -10, karma: -5 } },
            "shelter": { name: "Shelter", desc: "A makeshift shelter, offering some protection from the elements.", consumed: false, special: "rest_bonus" },
            "lucky charm": { name: "Lucky Charm", desc: "A small, smooth stone. It feels warm in your hand.", consumed: false, effects: { hope: 5, sanity: 5 } },
            "ancient tome": { name: "Ancient Tome", desc: "A brittle book filled with forgotten wisdom.", consumed: false, effects: { karma: 5, sanity: 10 } },
            "mysterious seed": { name: "Mysterious Seed", desc: "A tiny seed, pulsating with faint light. What will it grow?", consumed: true, effects: { hope: 15, hp: 10 } }
        };

        const HOPE_TIERS_REWARDS = [
            { threshold: 55, reward: { item: "Lucky Charm", sanity: 5, message: "You feel a renewed sense of purpose. Sanity +5." } },
            { threshold: 89, reward: { max_hp: 10, memory: "Witnessed a glimmer of true hope in the wasteland.", message: "Your spirit hardens. Max HP +10. You feel truly alive." } }
        ];

        const SANITY_TIERS_REWARDS = [
            { threshold: 55, reward: { gold: 20, message: "You find some forgotten valuables. Gold +20." } },
            { threshold: 89, reward: { karma: 10, item: "Ancient Tome", message: "Your understanding of the world deepens. Karma +10. You feel more connected." } }
        ];

        const KARMA_TIERS_REWARDS = [
            { threshold: 55, reward: { hope: 10, message: "Your good deeds inspire others. Hope +10." } },
            { threshold: 89, reward: { item: "Mysterious Seed", hp: 25, message: "Your compassion heals your body and soul. HP +25." } },
            { threshold: 144, reward: { max_hp: 20, sanity: 20, memory: "Became a beacon of humanity in the darkness.", message: "You transcend your limitations, becoming a true legend. Max HP +20, Sanity +20." } }
        ];

        const LOCATIONS = [
            { id: "abandoned_school", desc: "You find an abandoned school, children's drawings still on the walls...", choices: ["Search the school", "Leave respectfully"] },
            { id: "broken_bridge", desc: "A bridge spans a chasm. Someone is calling for help from below...", choices: ["Try to help", "Keep walking"] },
            { id: "dying_tree", desc: "An ancient tree withers. A small girl sits beneath it, crying...", choices: ["Approach the girl", "Observe from distance"] },
            { id: "refugee_camp", desc: "Desperate people huddle around dying fires...", choices: ["Share your gold", "Keep walking"] },
            { id: "memory_shrine", desc: "A shrine to the lost. Fresh flowers suggest someone still cares...", choices: ["Add a name", "Leave an offering"] }
        ];

        const NPCS = [
            { name: "Elena", desc: "A doctor who still treats the wounded, though medicine is scarce", choices: ["Offer to help", "Ask for healing"] },
            { name: "Marcus", desc: "A father searching for his lost daughter", choices: ["Promise to look", "Offer comfort"] },
            { name: "The Chronicler", desc: "An old man who records the stories of the lost", choices: ["Share your story", "Listen to his"] },
            { name: "Anna", desc: "A young woman who maintains the last garden in the wasteland", choices: ["Help with the garden", "Ask about the past"] }
        ];

        const ENEMIES = [
            { name: "Hollow Survivor", desc: "A person who lost everything, now consumed by rage", base_hp: 30 },
            { name: "Shadow of Regret", desc: "Your past mistakes given form", base_hp: 40 },
            { name: "Despair Wraith", desc: "The embodiment of hopelessness", base_hp: 50 },
            { name: "Corrupted Guardian", desc: "A protector who failed and turned dark", base_hp: 60 }
        ];

        // Battle System Constants
        const BATTLE_STATES = {
            INIT: 'init',
            PLAYER_TURN: 'player_turn',
            ENEMY_TURN: 'enemy_turn',
            END: 'end'
        };
        const BATTLE_ACTIONS = {
            ATTACK: 'fight', // Renamed to match existing command
            DEFEND: 'defend', // Not fully implemented in current battle, but kept for future
            FLEE: 'flee',
            USE_ITEM: 'use_item' // Not implemented in current battle, but kept for future
        };

        const WEATHER_TYPES = {
            CLEAR: {
                name: 'Clear',
                description: 'The ash has settled, revealing a stark sky.',
                effects: { sanity: 1, hope: 1 }
            },
            ACID_RAIN: {
                name: 'Acid Rain',
                description: 'Corrosive droplets fall from the poisoned sky.',
                effects: { hp: -5, sanity: -2 }
            },
            DUST_STORM: {
                name: 'Dust Storm',
                description: 'A swirling dust storm reduces visibility and chokes the air.',
                effects: { hp: -2, sanity: -3 }
            },
            FOG: {
                name: 'Dense Fog',
                description: 'A thick fog rolls in, making it hard to see.',
                effects: { sanity: -1 }
            }
        };

        const ACHIEVEMENTS = {
            SURVIVOR: { id: 'survivor', name: 'Survivor', desc: 'Survive 30 days', condition: player => player.days_survived >= 30 },
            HOPE_BEARER: { id: 'hope_bearer', name: 'Hope Bearer', desc: 'Reach 80 hope', condition: player => player.hope >= 80 },
            KARMA_MASTER: { id: 'karma_master', name: 'Karma Master', desc: 'Reach 100 karma', condition: player => player.karma >= 100 },
            FIRST_KILL: { id: 'first_kill', name: 'First Kill', desc: 'Defeat an enemy', condition: player => player.total_enemies_defeated >= 1 },
            PEACE_MAKER: { id: 'peace_maker', name: 'Peace Maker', desc: 'Show mercy in battle', condition: player => player.mercies_shown >= 1 },
            SCHOLAR: { id: 'scholar', name: 'Scholar', desc: 'Find the Ancient Tome', condition: player => player.inventory.some(item => item.name === ITEM_DATA["ancient tome"].name) },
            DAY_100_SURVIVOR: { id: 'day_100_survivor', name: 'Centennial Survivor', desc: 'Survive 100 days', condition: player => player.days_survived >= 100 }
        };


        // --- Player Class ---
        class Player {
            constructor(name) {
                this.name = name;
                this.hp = 100;
                this.max_hp = 100;
                this.level = 1;
                this.exp = 0;
                this.gold = 10;
                this.inventory = [
                    { name: "Bread", desc: ITEM_DATA["bread"].desc },
                    { name: "Water", desc: ITEM_DATA["water"].desc },
                    { name: "Faded Photo", desc: ITEM_DATA["faded photo"].desc }
                ];
                this.karma = 0;
                this.relationships = {};
                this.memories = ["Left the safety of the vault"];
                this.sanity = 100;
                this.hope = 50;
                this.days_survived = 0;
                this.awarded_tiers = {
                    hope: [],
                    sanity: [],
                    karma: []
                };
                this.total_enemies_defeated = 0; // For achievements
                this.mercies_shown = 0; // For achievements
            }
            
            stats() {
                let inventoryList = this.inventory.map(item => item.name).join(', ') || 'Empty';
                return `${this.name} | HP:${this.hp}/${this.max_hp} | Level:${this.level} | ` +
                       `EXP:${this.exp} | Gold:${this.gold} | Karma:${this.karma} | ` +
                       `Sanity:${this.sanity} | Hope:${this.hope} | Days:${this.days_survived}<br>` +
                       `Inventory: ${inventoryList}`;
            }
            
            addMemory(memory) {
                this.memories.push(memory);
                addToStoryDebounced(`<span class="memory">[Memory added: ${memory}]</span>`);
            }
            
            changeHope(amount) {
                this.hope = Math.max(0, Math.min(100, this.hope + amount));
                if (amount > 0) {
                    addToStoryDebounced(`<span class="hope-positive">The world feels a little brighter... (Hope +${amount})</span>`);
                } else {
                    addToStoryDebounced(`<span class="hope-negative">Darkness spreads... (Hope ${amount})</span>`);
                }
                checkStatRewards(); 
            }
            
            addLoot(item_id, item_desc) {
                const itemData = ITEM_DATA[item_id.toLowerCase()];
                if (!itemData) {
                    console.error("Attempted to add unknown item:", item_id);
                    return;
                }

                // Check if item already exists if it's a non-consumable like Shelter
                if (!itemData.consumed && this.inventory.some(item => item.name === itemData.name)) {
                    addToStoryDebounced(`You already have a ${itemData.name}.`);
                    return;
                }
                this.inventory.push({ name: itemData.name, desc: item_desc || itemData.desc });
                addToStoryDebounced(`You found: ${itemData.name}`);
            }
        }
        
        // --- Game State Variables ---
        let player = null;
        let gameState = "init"; // init, playing, choosing, battle, game_over, using_inventory
        let currentChoiceContext = null; // Stores context for choices (e.g., location, NPC name, critical choice type)
        let enemy = null; // Stores current enemy in battle
        let battleState = BATTLE_STATES.END; // Initialize battle state
        let storyBuffer = []; // Buffer for debounced story updates
        let achievementSystem = null;
        let weatherSystem = null;

        // --- DOM Elements (using DOMCache) ---
        class DOMCache {
            static elements = {};
            
            static get(id) {
                if (!this.elements[id]) {
                    this.elements[id] = document.getElementById(id);
                }
                return this.elements[id];
            }
        }

        const gameTextPanel = DOMCache.get('game-text');
        const storyTextContent = DOMCache.get('story-text');
        const commandInput = DOMCache.get('command-input');
        const nameInputSection = DOMCache.get('name-input');
        const gameInputSection = DOMCache.get('game-input');
        const commandsSection = DOMCache.get('commands');
        const restartGameSection = DOMCache.get('restart-game-section');

        // --- Performance Optimizations ---
        // Debounce function for performance-heavy operations
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Optimize story text updates
        const addToStoryDebounced = debounce((text) => {
            storyBuffer.push(text);
            storyTextContent.innerHTML = storyBuffer.join('<br>');
            gameTextPanel.scrollTop = gameTextPanel.scrollHeight;
            updateStats(); // Update stats immediately after story text is rendered
        }, 50); // Adjust debounce time as needed


        // --- Enhanced Error Handling ---
        class GameError extends Error {
            constructor(message, type = 'GAME_ERROR') {
                super(message);
                this.name = 'GameError'; // Set error name
                this.type = type;
                this.timestamp = new Date().toISOString();
            }
        }

        function handleGameError(error) {
            console.error(`[${error.timestamp}] ${error.type || 'UNKNOWN_ERROR'}: ${error.message}`);
            addToStoryDebounced(`<span class="error">An error occurred: ${error.message}</span>`);
            // Potentially transition to a safe state or show a more prominent error UI
            if (gameState !== "game_over") { // Prevent endless loops if game is already over
                gameState = "playing"; // Attempt to return to a playable state
                displayOptions();
            }
        }

        // --- Core Game Functions ---

        function addToStory(text) { // Non-debounced version for immediate critical messages
            storyTextContent.innerHTML += (storyTextContent.innerHTML ? '<br>' : '') + text;
            gameTextPanel.scrollTop = gameTextPanel.scrollHeight;
            updateStats();
        }
        
        function clearStory() {
            storyTextContent.innerHTML = '';
            storyBuffer = []; // Clear the buffer as well
        }
        
        function updateStats() {
            if (player) {
                DOMCache.get('player-stats').innerHTML = player.stats();
            }
        }
        
        function startGame() {
            try {
                const playerNameInput = DOMCache.get('player-name');
                const name = playerNameInput.value.trim();
                
                if (!name) {
                    displayMessage("Please enter your name, wanderer.");
                    return;
                }
                
                player = new Player(name);
                achievementSystem = new AchievementSystem();
                weatherSystem = new WeatherSystem();

                nameInputSection.classList.add('hidden');
                gameInputSection.classList.remove('hidden');
                commandsSection.classList.remove('hidden');
                restartGameSection.classList.add('hidden'); // Hide restart button on new game
                
                clearStory();
                addToStoryDebounced(`Welcome to the wasteland, ${player.name}.`);
                addToStoryDebounced('Your choices will determine not just your fate, but the fate of hope itself.');
                
                gameState = "playing";
                startDay();
                
                commandInput.focus();
            } catch (error) {
                handleGameError(new GameError('Failed to start game', 'START_GAME_ERROR'));
            }
        }

        function resetGame() {
            try {
                // Clear all game state variables
                player = null;
                gameState = "init";
                currentChoiceContext = null;
                enemy = null;
                battleState = BATTLE_STATES.END;
                storyBuffer = [];
                achievementSystem = null;
                weatherSystem = null;

                // Reset UI elements
                clearStory();
                DOMCache.get('player-name').value = ''; // Clear name input
                nameInputSection.classList.remove('hidden');
                gameInputSection.classList.add('hidden');
                commandsSection.classList.add('hidden');
                restartGameSection.classList.add('hidden');
                DOMCache.get('game-input').querySelector('button').disabled = false; // Re-enable execute button
                commandsSection.querySelectorAll('button').forEach(btn => btn.disabled = false); // Re-enable command buttons

                addToStory("The world ended not with fire, but with the slow death of hope.<br>" +
                           "You are one of the few who still remember what it means to be human.<br>" +
                           "In this broken world, every choice matters.<br>" +
                           "Every life you touch changes the fate of what remains.");
                DOMCache.get('player-name').focus(); // Focus on name input for new game
            } catch (error) {
                handleGameError(new GameError('Failed to reset game', 'RESET_GAME_ERROR'));
            }
        }
        
        function processCommand() {
            try {
                const command = commandInput.value.trim().toLowerCase();
                commandInput.value = '';
                
                if (command) {
                    executeCommand(command);
                }
            } catch (error) {
                handleGameError(new GameError('Failed to process command input', 'INPUT_PROCESSING_ERROR'));
            }
        }
        
        function executeCommand(cmd) {
            try {
                if (gameState === "game_over") return;

                if (gameState === "choosing" || gameState === "using_inventory") {
                    handleChoice(cmd);
                    return;
                }
                
                if (gameState === "battle") {
                    handleBattle(cmd);
                    return;
                }
                
                let shouldDisplayGeneralOptions = true; // Flag to control general options display

                switch (cmd) {
                    case 'stats':
                        addToStoryDebounced(player.stats());
                        shouldDisplayGeneralOptions = false; // Don't re-display general options
                        break;
                    case 'wander':
                        wander(); // This will eventually call displayOptions() for new choices or new day
                        shouldDisplayGeneralOptions = false;
                        break;
                    case 'rest':
                        rest(); // Calls endDay() -> startDay() -> displayOptions()
                        shouldDisplayGeneralOptions = false;
                        break;
                    case 'remember':
                        addToStoryDebounced('You remember...');
                        player.memories.forEach(memory => {
                            addToStoryDebounced(`- ${memory}`);
                        });
                        player.sanity = Math.min(100, player.sanity + 5);
                        checkStatRewards();
                        shouldDisplayGeneralOptions = false; // Don't re-display general options
                        break;
                    case 'inventory':
                        if (player.inventory.length > 0) {
                            addToStoryDebounced('You carry:');
                            player.inventory.forEach((item, index) => {
                                addToStoryDebounced(`${index + 1}. ${item.name}: ${item.desc}`);
                            });
                            const inventoryChoices = player.inventory.map(item => item.name);
                            inventoryChoices.push("Cancel");
                            currentChoiceContext = { type: "using_inventory", choices: inventoryChoices };
                            gameState = "using_inventory";
                            displayOptions(); // Call here to show the specific inventory prompt
                        } else {
                            addToStoryDebounced('You carry: Nothing but hope');
                            currentChoiceContext = null;
                            gameState = "playing"; // Revert to playing if inventory is empty
                            // No need for displayOptions() here, as it will be handled by the outer check if shouldDisplayGeneralOptions is true
                        }
                        shouldDisplayGeneralOptions = false; // Inventory handled its own prompt or is empty
                        break;
                    case 'meditate':
                        meditate(); // Calls endDay() -> startDay() -> displayOptions()
                        shouldDisplayGeneralOptions = false;
                        break;
                    case 'quit':
                        addToStoryDebounced('Even in quitting, you make a choice.');
                        addToStoryDebounced('The world will remember what you did here.');
                        gameOver();
                        shouldDisplayGeneralOptions = false; // Game over, no more options
                        return;
                    default:
                        addToStoryDebounced('In confusion, you hesitate. Time passes.');
                        // shouldDisplayGeneralOptions remains true, so displayOptions() will be called below
                        break;
                }

                // Only display general options if no specific state (like choosing, battle, inventory)
                // or day-advancing action has already handled the prompt.
                if (shouldDisplayGeneralOptions && gameState === "playing") {
                    displayOptions();
                }
                // Ensure command input is focused after any action
                commandInput.focus();
            } catch (error) {
                handleGameError(new GameError(`Failed to execute command '${cmd}'`, 'COMMAND_EXECUTION_ERROR'));
            }
        }

        function endDay() {
            try {
                if (Math.random() < 0.1) {
                    player.sanity = Math.max(0, player.sanity - 1);
                    player.changeHope(-1);
                }
                weatherSystem.update(); // Apply weather effects for the new day
                checkStatRewards();
                achievementSystem.check(); // Check achievements at end of day
                checkGameOver();

                if (gameState === "game_over") return;

                const randomEvent = Math.random();
                if (randomEvent < 0.2) { 
                    meetNPC();
                } else if (randomEvent < 0.3) {
                    criticalChoice();
                } else {
                    startDay(); 
                }
            } catch (error) {
                handleGameError(new GameError('Error ending day', 'END_DAY_ERROR'));
            }
        }

        function startDay() {
            try {
                player.days_survived += 1;
                addToStoryDebounced('<br>' + '='.repeat(50));
                addToStoryDebounced(`Day ${player.days_survived}`);
                addToStoryDebounced('='.repeat(50));
                displayOptions();
            } catch (error) {
                handleGameError(new GameError('Error starting new day', 'START_DAY_ERROR'));
            }
        }
        
        function wander() {
            try {
                const randomEncounter = Math.random();
                if (randomEncounter < 0.4) { 
                    explore();
                } else {
                    battle();
                }
            } catch (error) {
                handleGameError(new GameError('Error during wander action', 'WANDER_ERROR'));
            }
        }
        
        function rest() {
            try {
                const hasShelter = player.inventory.some(item => item.name === ITEM_DATA["shelter"].name);
                if (hasShelter) {
                    player.hp = Math.min(player.max_hp, player.hp + 20);
                    player.sanity = Math.min(100, player.sanity + 10);
                    addToStoryDebounced('You rest safely. Tomorrow brings new challenges.');
                } else {
                    player.hp = Math.min(player.max_hp, player.hp + 10);
                    player.sanity -= 5;
                    addToStoryDebounced('You rest fitfully in the open. The cold seeps into your bones.');
                }
                checkStatRewards();
                endDay();
            } catch (error) {
                handleGameError(new GameError('Error during rest action', 'REST_ERROR'));
            }
        }
        
        function meditate() {
            try {
                addToStoryDebounced('You sit in silence, remembering who you were before the world ended.');
                player.sanity = Math.min(100, player.sanity + 10);
                player.hp = Math.min(player.max_hp, player.hp + 5);
                checkStatRewards();
                endDay();
            } catch (error) {
                handleGameError(new GameError('Error during meditate action', 'MEDITATE_ERROR'));
            }
        }
        
        function checkGameOver() {
            try {
                if (player.hp <= 0) {
                    addToStoryDebounced("\nDarkness consumes you...");
                    gameOver();
                } else if (player.sanity <= 0) {
                    addToStoryDebounced("You lose yourself to madness...");
                    gameOver();
                } else if (player.days_survived >= 100) {
                    addToStoryDebounced("You've survived 100 days. The world is changing because of you.");
                    gameOver();
                }
            } catch (error) {
                handleGameError(new GameError('Error checking game over conditions', 'GAME_OVER_CHECK_ERROR'));
            }
        }

        function gameOver() {
            try {
                gameState = "game_over";
                addToStoryDebounced('<br>' + '='.repeat(50));
                addToStoryDebounced('YOUR JOURNEY ENDS');
                addToStoryDebounced('='.repeat(50));
                
                addToStoryDebounced(`You survived ${player.days_survived} days in this broken world.`);
                addToStoryDebounced(`Your final karma: ${player.karma}`);
                addToStoryDebounced(`The world's hope when you left: ${player.hope}`);
                
                if (player.karma > 50) {
                    addToStoryDebounced('\nYou died as you lived - with compassion.');
                    addToStoryDebounced('The people you helped remember your name.');
                    addToStoryDebounced('In the darkness, you were a light.');
                } else if (player.karma > 0) {
                    addToStoryDebounced('\nYou tried to do good in an impossible world.');
                    addToStoryDebounced('It wasn\'t always enough, but you tried.');
                } else {
                    addToStoryDebounced('\nThe world broke you, as it broke so many others.');
                    addToStoryDebounced('In trying to survive, you lost what made you human.');
                }
                
                addToStoryDebounced('\nYour memories:');
                if (player.memories.length > 0) {
                    player.memories.forEach(memory => {
                        addToStoryDebounced(`- ${memory}`);
                    });
                } else {
                    addToStoryDebounced('- None');
                }
                
                addToStoryDebounced(`\nFinal Hope Level: ${player.hope}/100`);
                if (player.hope > 70) {
                    addToStoryDebounced('Against all odds, hope survived. The world might heal.');
                } else if (player.hope > 30) {
                    addToStoryDebounced('A flicker of hope remains. Perhaps it\'s enough.');
                } else {
                    addToStoryDebounced('Hope is nearly dead. The world grows darker.');
                }

                commandInput.disabled = true;
                DOMCache.get('game-input').querySelector('button').disabled = true;
                commandsSection.classList.add('hidden'); // Hide command buttons
                restartGameSection.classList.remove('hidden'); // Show restart button
            } catch (error) {
                handleGameError(new GameError('Error during game over sequence', 'GAME_OVER_ERROR'));
            }
        }

        function levelUp() {
            try {
                const required_exp = player.level * 30;
                if (player.exp >= required_exp) {
                    player.level += 1;
                    player.max_hp += 15;
                    player.hp = player.max_hp;
                    player.exp = 0;
                    addToStoryDebounced(`\nYou've grown stronger... Level ${player.level}`);
                    addToStoryDebounced(`Max HP increased to ${player.max_hp}.`);
                    addToStoryDebounced("But strength alone won't save this world.");
                }
            } catch (error) {
                handleGameError(new GameError('Error during level up', 'LEVEL_UP_ERROR'));
            }
        }

        function explore() {
            try {
                const randomLocation = LOCATIONS[Math.floor(Math.random() * LOCATIONS.length)];
                currentChoiceContext = { type: "explore", location: randomLocation.id, choices: randomLocation.choices };
                gameState = "choosing";
                addToStoryDebounced(`\n${randomLocation.desc}`);
                if (randomLocation.id === "refugee_camp" && player.gold < 20) {
                    addToStoryDebounced("You have nothing to give. Your empty hands feel like betrayal.");
                    player.sanity -= 10;
                    checkStatRewards();
                    gameState = "playing";
                    endDay();
                } else {
                    displayOptions();
                }
            } catch (error) {
                handleGameError(new GameError('Error during exploration', 'EXPLORE_ERROR'));
            }
        }

        // --- Choice Handling Functions ---

        /**
         * Converts a user command (which might be a number) into the actual choice string.
         * @param {string} cmd - The raw user input command.
         * @param {string[]} choices - An array of available choice strings.
         * @returns {string|null} The actual choice string (lowercase) or null if invalid.
         */
        function getActualChoiceFromInput(cmd, choices) {
            const isNumeric = /^\d+$/.test(cmd);
            if (isNumeric) {
                const choiceIndex = parseInt(cmd, 10) - 1;
                if (choiceIndex >= 0 && choiceIndex < choices.length) {
                    return choices[choiceIndex].toLowerCase();
                }
            }
            // If not numeric or out of range, return the original command (lowercase)
            // This allows for direct keyword input as well.
            return cmd.toLowerCase();
        }

        function handleChoice(cmd) {
            try {
                let choiceHandled = false;
                let actualCmd = getActualChoiceFromInput(cmd, currentChoiceContext.choices);

                if (actualCmd === null) { // Invalid numeric input
                    addToStoryDebounced("Invalid choice number. Please enter a valid number.");
                    displayOptions();
                    return;
                }

                switch (currentChoiceContext.type) {
                    case "explore":
                        choiceHandled = handleExploreChoice(currentChoiceContext.location, actualCmd);
                        break;
                    case "explore_dying_tree_comfort":
                        // Note: The original code had 'actualChoiceFromInput' here, which was a typo.
                        // It should be 'actualCmd' to use the parsed command. Corrected.
                        choiceHandled = handleDyingTreeComfortChoice(actualCmd);
                        break;
                    case "explore_memory_shrine_add_name":
                        // This is a direct text input, not a numbered choice from a list
                        addToStoryDebounced(`You carve '${actualCmd}' into the stone. They will not be forgotten.`);
                        player.addMemory(`Honored ${actualCmd} at the shrine`);
                        player.changeHope(5);
                        choiceHandled = true;
                        break;
                    case "meet_npc_elena":
                    case "meet_npc_marcus":
                    case "meet_npc_chronicler":
                    case "meet_npc_anna":
                        choiceHandled = handleNpcChoice(currentChoiceContext.type, actualCmd);
                        break;
                    case "critical_choice":
                        choiceHandled = handleCriticalChoice(actualCmd);
                        break;
                    case "using_inventory":
                        choiceHandled = handleInventoryUse(actualCmd);
                        break;
                    default:
                        addToStoryDebounced("Invalid choice. Please choose one of the available options.");
                        displayOptions();
                        return;
                }

                if (choiceHandled) {
                    currentChoiceContext = null;
                    gameState = "playing";
                    endDay();
                } else {
                    addToStoryDebounced("Invalid choice. Please choose one of the available options.");
                    displayOptions();
                }
            } catch (error) {
                handleGameError(new GameError('Error handling choice', 'CHOICE_HANDLING_ERROR'));
            }
        }

        function handleExploreChoice(locationId, cmd) {
            try {
                switch (locationId) {
                    case "abandoned_school":
                        if (cmd === "search the school" || cmd === "search") {
                            if (Math.random() < 0.5) {
                                addToStoryDebounced("You find a child's diary. The last entry: 'I hope someone remembers us.'");
                                player.addMemory("Found a child's final hope");
                                player.changeHope(10);
                            } else {
                                addToStoryDebounced("You find nothing but echoes of laughter that will never return.");
                                player.sanity -= 10;
                                checkStatRewards();
                            }
                            if (Math.random() < 0.2 && !player.inventory.some(item => item.name === ITEM_DATA["shelter"].name)) {
                                player.addLoot("shelter");
                            }
                            return true;
                        } else if (cmd === "leave respectfully" || cmd === "leave") {
                            addToStoryDebounced("You whisper a prayer and move on. Some places deserve peace.");
                            player.karma += 5;
                            checkStatRewards();
                            return true;
                        }
                        return false;
                    case "broken_bridge":
                        if (cmd === "try to help" || cmd === "help") {
                            if (Math.random() < 0.6) {
                                addToStoryDebounced("You risk everything to save them. They're just a child, lost and alone.");
                                addToStoryDebounced("'Thank you,' they whisper. 'I thought no one cared anymore.'");
                                player.addMemory("Saved a child from the chasm");
                                player.changeHope(15);
                                player.karma += 15;
                                player.sanity += 10;
                            } else {
                                addToStoryDebounced("You try to help, but the rope breaks. You watch them fall...");
                                addToStoryDebounced("Their final scream echoes in your mind forever.");
                                player.sanity -= 25;
                                player.karma -= 10;
                                player.addMemory("Failed to save someone");
                            }
                            checkStatRewards();
                            return true;
                        } else if (cmd === "keep walking" || cmd === "walk") {
                            addToStoryDebounced("You walk away. Their cries follow you into the night.");
                            player.sanity -= 15;
                            player.karma -= 5;
                            checkStatRewards();
                            return true;
                        }
                        return false;
                    case "dying_tree":
                        if (cmd === "approach the girl" || cmd === "approach") {
                            addToStoryDebounced("'My grandmother planted this tree,' she says without looking up.");
                            addToStoryDebounced("'She said it would outlive us all. She was wrong.'");
                            currentChoiceContext = { type: "explore_dying_tree_comfort", choices: ["Comfort her", "Share your food"] };
                            displayOptions();
                            return false; // Wait for next choice
                        } else if (cmd === "observe from distance" || cmd === "observe") {
                            addToStoryDebounced("You watch her for a moment, then move on. Some pains are too deep to touch.");
                            player.sanity -= 2;
                            checkStatRewards();
                            return true;
                        }
                        return false;
                    case "refugee_camp":
                        if (cmd === "share your gold" || cmd === "share") {
                            if (player.gold >= 20) {
                                player.gold -= 20;
                                addToStoryDebounced("Your gold feeds them for one more day. It's not much, but it's hope.");
                                player.changeHope(10);
                                player.karma += 10;
                            } else {
                                addToStoryDebounced("You don't have enough gold to share.");
                            }
                            checkStatRewards();
                            return true;
                        } else if (cmd === "keep walking" || cmd === "walk") {
                            addToStoryDebounced("You walk away. Their desperate eyes burn into your memory.");
                            player.sanity -= 5;
                            checkStatRewards();
                            return true;
                        }
                        return false;
                    case "memory_shrine":
                        if (cmd === "add a name" || cmd === "add") {
                            currentChoiceContext = { type: "explore_memory_shrine_add_name" };
                            addToStoryDebounced("Whose name do you carve? (Type the name)");
                            return false; // Wait for name input
                        } else if (cmd === "leave an offering" || cmd === "leave" || cmd === "offering") {
                            if (player.inventory.length > 0) {
                                const offerableItems = player.inventory.filter(item => item.name !== ITEM_DATA["shelter"].name && item.name !== ITEM_DATA["bitter memory"].name);
                                if (offerableItems.length > 0) {
                                    const itemToOffer = offerableItems[Math.floor(Math.random() * offerableItems.length)];
                                    const itemIndex = player.inventory.indexOf(itemToOffer);
                                    player.inventory.splice(itemIndex, 1);
                                    addToStoryDebounced(`You leave your ${itemToOffer.name}. The dead deserve remembrance.`);
                                    player.karma += 5;
                                    checkStatRewards();
                                } else {
                                    addToStoryDebounced("You have nothing suitable to offer.");
                                }
                            } else {
                                addToStoryDebounced("You have nothing to offer.");
                            }
                            return true;
                        }
                        return false;
                    default:
                        return false;
                }
            } catch (error) {
                handleGameError(new GameError(`Error in explore choice for ${locationId}`, 'EXPLORE_CHOICE_ERROR'));
                return false;
            }
        }

        function handleDyingTreeComfortChoice(cmd) {
            try {
                if (cmd === "comfort her" || cmd === "comfort") {
                    addToStoryDebounced("You sit beside her. Sometimes presence is enough.");
                    player.sanity += 5;
                    player.karma += 5;
                    checkStatRewards();
                    return true;
                } else if (cmd === "share your food" || cmd === "share" || cmd === "food") {
                    const breadItem = player.inventory.find(item => item.name === ITEM_DATA["bread"].name);
                    if (breadItem) {
                        const breadIndex = player.inventory.indexOf(breadItem);
                        player.inventory.splice(breadIndex, 1);
                        addToStoryDebounced("You share your bread. She smiles for the first time in months.");
                        player.changeHope(10);
                        player.karma += 10;
                    } else {
                        addToStoryDebounced("You have no food to share. The guilt cuts deep.");
                        player.sanity -= 5;
                    }
                    checkStatRewards();
                    return true;
                }
                return false;
            } catch (error) {
                handleGameError(new GameError('Error in dying tree comfort choice', 'DYING_TREE_CHOICE_ERROR'));
                return false;
            }
        }

        function handleNpcChoice(npcType, cmd) {
            try {
                let npcName;
                switch(npcType) {
                    case "meet_npc_elena": npcName = "Elena"; break;
                    case "meet_npc_marcus": npcName = "Marcus"; break;
                    case "meet_npc_chronicler": npcName = "The Chronicler"; break;
                    case "meet_npc_anna": npcName = "Anna"; break;
                    default: return false;
                }

                if (!player.relationships[npcName]) {
                    player.relationships[npcName] = 0;
                }

                // Use the full lowercased command string for comparison
                if (npcName === "Elena") {
                    if (cmd === "offer to help" || cmd === "help") {
                        addToStoryDebounced("You spend the day helping her tend to the wounded.");
                        player.relationships.Elena += 10;
                        player.karma += 10;
                        player.changeHope(5);
                        addToStoryDebounced("Elena smiles sadly. 'Thank you. I'd forgotten what kindness looked like.'");
                        checkStatRewards(); // Moved inside successful branch
                        return true;
                    } else if (cmd === "ask for healing" || cmd === "healing") {
                        if (player.hp < player.max_hp) {
                            player.hp = Math.min(player.max_hp, player.hp + 20);
                            addToStoryDebounced("Elena tends to your wounds without asking for payment.");
                            player.relationships.Elena += 5;
                        } else {
                            addToStoryDebounced("You are already at full health.");
                        }
                        checkStatRewards(); // Moved inside successful branch
                        return true;
                    }
                } else if (npcName === "Marcus") {
                    if (cmd === "promise to look" || cmd === "promise") {
                        addToStoryDebounced("'Thank you,' he weeps. 'I won't give up. I can't give up.'");
                        player.addMemory("Promised to help Marcus find his daughter");
                        player.relationships.Marcus += 15;
                        player.karma += 10;
                        checkStatRewards(); // Moved inside successful branch
                        return true;
                    } else if (cmd === "offer comfort" || cmd === "comfort") {
                        addToStoryDebounced("You offer words of solace. He nods, tears in his eyes.");
                        player.sanity += 5;
                        player.relationships.Marcus += 5;
                        checkStatRewards(); // Moved inside successful branch
                        return true;
                    }
                } else if (npcName === "The Chronicler") {
                    // Modified to only match full lowercased strings from NPCS data
                    if (cmd === "share your story") {
                        addToStoryDebounced("You tell him of your journey. He writes it down with shaking hands.");
                        player.addMemory("Shared your story with the Chronicler");
                        player.sanity += 10;
                        player.relationships["The Chronicler"] += 10;
                        checkStatRewards();
                        return true;
                    } else if (cmd === "listen to his") {
                        addToStoryDebounced("He recounts tales of a forgotten world, of heroes and villains long turned to dust.");
                        player.sanity += 5;
                        player.relationships["The Chronicler"] += 5;
                        checkStatRewards();
                        return true;
                    }
                } else if (npcName === "Anna") {
                    if (cmd === "help with the garden" || cmd === "help") {
                        addToStoryDebounced("You work together in silence. New shoots push through the ash.");
                        player.changeHope(10);
                        player.relationships.Anna += 10;
                        player.sanity += 5;
                        checkStatRewards(); // Moved inside successful branch
                        return true;
                    } else if (cmd === "ask about the past" || cmd === "ask") {
                        addToStoryDebounced("She speaks of vibrant colors and bustling cities, a world that exists only in memory.");
                        player.sanity += 5;
                        player.relationships.Anna += 5;
                        checkStatRewards(); // Moved inside successful branch
                        return true;
                    }
                }
                return false; // If no valid command was matched
            } catch (error) {
                handleGameError(new GameError(`Error in NPC choice for ${npcType}`, 'NPC_CHOICE_ERROR'));
                return false;
            }
        }

        function handleCriticalChoice(cmd) {
            try {
                if (cmd === "take the food" || cmd === "take") {
                    addToStoryDebounced("You take the food. The children scatter like frightened birds.");
                    addToStoryDebounced("You eat well tonight, but their faces haunt your dreams.");
                    player.gold += 10;
                    player.sanity -= 30;
                    player.karma -= 25;
                    player.changeHope(-15);
                    player.addMemory("Took food from starving children");
                    checkStatRewards(); // Moved inside successful branch
                    return true;
                } else if (cmd === "share your supplies" || cmd === "share") {
                    addToStoryDebounced("You empty your pack, sharing everything you have.");
                    addToStoryDebounced("The children stare in disbelief. 'Why?' one asks.");
                    addToStoryDebounced("'Because someone has to care,' you reply.");
                    player.inventory = [];
                    player.gold = Math.max(0, player.gold - 10);
                    player.karma += 25;
                    player.changeHope(20);
                    player.sanity += 15;
                    player.addMemory("Shared everything with starving children");
                    checkStatRewards(); // Moved inside successful branch
                    return true;
                } else if (cmd === "walk away" || cmd === "walk") {
                    addToStoryDebounced("You walk away. Sometimes the right choice is the hardest.");
                    player.sanity -= 10;
                    player.karma += 5;
                    checkStatRewards(); // Moved inside successful branch
                    return true;
                }
                return false; // If no valid command was matched
            } catch (error) {
                handleGameError(new GameError('Error handling critical choice', 'CRITICAL_CHOICE_ERROR'));
                return false;
            }
        }

        function handleInventoryUse(cmd) {
            try {
                if (cmd === "cancel") {
                    addToStoryDebounced("You decide not to use an item.");
                    return true; // Handled, return to playing state
                } else {
                    // The cmd is already the item name (lowercase) from getActualChoiceFromInput
                    useItem(cmd);
                    return true; // useItem will handle state transition and options
                }
            } catch (error) {
                handleGameError(new GameError('Error handling inventory use', 'INVENTORY_USE_ERROR'));
                return false;
            }
        }

        function useItem(item_name_lower) {
            try {
                const itemData = ITEM_DATA[item_name_lower];
                if (!itemData) {
                    addToStoryDebounced(`You don't have '${item_name_lower}' in your inventory.`);
                    gameState = "playing";
                    displayOptions();
                    return;
                }

                const itemInInventoryIndex = player.inventory.findIndex(item => item.name.toLowerCase() === item_name_lower);
                if (itemInInventoryIndex === -1) {
                    addToStoryDebounced(`You don't have '${item_name_lower}' in your inventory.`);
                    gameState = "playing";
                    displayOptions();
                    return;
                }

                addToStoryDebounced(`You use the ${itemData.name}.`);
                
                if (itemData.effects) {
                    if (itemData.effects.hp) player.hp = Math.min(player.max_hp, player.hp + itemData.effects.hp);
                    if (itemData.effects.sanity) player.sanity = Math.min(100, player.sanity + itemData.effects.sanity);
                    if (itemData.effects.karma) player.karma += itemData.effects.karma;
                    if (itemData.effects.hope) player.changeHope(itemData.effects.hope);
                }

                if (itemData.consumed) {
                    player.inventory.splice(itemInInventoryIndex, 1);
                } else if (itemData.special === "rest_bonus") {
                    addToStoryDebounced("This item provides a bonus when you 'rest'.");
                } else {
                    addToStoryDebounced(`It seems using the ${itemData.name} had an effect.`);
                }
                
                checkStatRewards();
                gameState = "playing";
                displayOptions();
            } catch (error) {
                handleGameError(new GameError(`Error using item ${item_name_lower}`, 'USE_ITEM_ERROR'));
            }
        }

        // --- Battle Functions ---
        function battle() {
            try {
                initializeBattle(); // Initialize enemy and battle state
                displayOptions(); // Display battle options (Fight, Mercy, Flee)
            } catch (error) {
                handleGameError(new GameError('Error starting battle', 'BATTLE_START_ERROR'));
            }
        }

        function initializeBattle() {
            const selectedEnemy = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
            enemy = {
                ...selectedEnemy,
                hp: selectedEnemy.base_hp + (player.level * 5), // Scale enemy HP with player level
                status: [] // For future status effects
            };
            battleState = BATTLE_STATES.PLAYER_TURN; // Set to player turn initially
            gameState = "battle";
            addToStoryDebounced(`\nA ${enemy.name} appears!\n${enemy.desc}`);
            addToStoryDebounced(`The ${enemy.name} emerges from the shadows... HP: ${enemy.hp}`);
            currentChoiceContext = { type: "battle", choices: ["Fight", "Mercy", "Flee"] }; // Set choices for displayOptions
        }

        function handleBattle(cmd) {
            try {
                if (battleState === BATTLE_STATES.END) return; 

                // Use getActualChoiceFromInput to parse numeric commands for battle
                let actualCmd = getActualChoiceFromInput(cmd, currentChoiceContext.choices); // Use choices from context

                if (actualCmd === null) {
                    addToStoryDebounced("Invalid battle command. Please enter a valid number or command.");
                    displayOptions();
                    return;
                }

                let enemy_hp = enemy.hp;
                const enemy_name = enemy.name;
                
                addToStoryDebounced(`\nYour HP: ${player.hp} | Enemy HP: ${enemy_hp}`);
                
                let actionTaken = false;

                if (actualCmd === BATTLE_ACTIONS.ATTACK) { // Using BATTLE_ACTIONS constant
                    const dmg = Math.floor(Math.random() * (25 - 15 + 1)) + 15;
                    enemy_hp -= dmg;
                    addToStoryDebounced(`You strike with desperate fury! ${dmg} damage!`);
                    actionTaken = true;
                } else if (actualCmd === BATTLE_ACTIONS.DEFEND) { // Placeholder for defend
                    addToStoryDebounced("You brace for impact, but it's not very effective yet.");
                    actionTaken = true;
                } else if (actualCmd === BATTLE_ACTIONS.FLEE) { // Using BATTLE_ACTIONS constant
                    addToStoryDebounced("You escape into the darkness...");
                    player.sanity -= 5;
                    battleState = BATTLE_STATES.END; 
                    enemy = null;
                    gameState = "playing"; 
                    endDay(); 
                    return;
                } else {
                    addToStoryDebounced("Invalid battle command. Options: fight, mercy, flee.");
                    displayOptions();
                    return;
                }

                enemy.hp = enemy_hp;

                if (enemy.hp <= 0) {
                    addToStoryDebounced(`The ${enemy_name} falls... but victory feels hollow.`);
                    const gainedExp = Math.floor(Math.random() * (20 - 10 + 1)) + 10;
                    player.exp += gainedExp;
                    player.gold += Math.floor(Math.random() * (8 - 3 + 1)) + 3;
                    player.karma -= 2;
                    player.total_enemies_defeated += 1; // Increment for achievement
                    addToStoryDebounced(`Gained ${gainedExp} EXP. Your soul feels heavier.`);
                    
                    if (Math.random() < 0.4) {
                        player.addLoot("bitter memory");
                    }
                    
                    levelUp();
                    battleState = BATTLE_STATES.END; 
                    enemy = null;
                    gameState = "playing"; 
                    endDay(); 
                } else {
                    // Enemy's turn after player's action
                    const enemy_dmg = Math.floor(Math.random() * (20 - 10 + 1)) + 10;
                    player.hp -= enemy_dmg;
                    player.sanity -= 2;
                    addToStoryDebounced(`The ${enemy_name} claws at your soul! ${enemy_dmg} damage!`);

                    if (player.hp <= 0) {
                        addToStoryDebounced("\nDarkness consumes you...");
                        gameOver();
                        return;
                    }
                    displayOptions(); // Display options for next player turn
                }
                checkStatRewards();
                achievementSystem.check(); // Check achievements after battle actions
            } catch (error) {
                handleGameError(new GameError('Error during battle action', 'BATTLE_ACTION_ERROR'));
            }
        }


        // --- NPC and Event Functions ---
        function meetNPC() {
            try {
                const randomNPC = NPCS[Math.floor(Math.random() * NPCS.length)];
                const npcName = randomNPC.name;
                
                if (!player.relationships[npcName]) {
                    player.relationships[npcName] = 0;
                }
                
                addToStoryDebounced(`\nYou meet ${npcName}.`);
                addToStoryDebounced(randomNPC.desc);
                
                currentChoiceContext = { type: `meet_npc_${npcName.toLowerCase().replace(/ /g, '_')}`, choices: randomNPC.choices };
                gameState = "choosing";
                displayOptions();
            } catch (error) {
                handleGameError(new GameError('Error meeting NPC', 'NPC_ENCOUNTER_ERROR'));
            }
        }

        function criticalChoice() {
            try {
                addToStoryDebounced("\n" + '='.repeat(50));
                addToStoryDebounced("A MOMENT OF TRUTH");
                addToStoryDebounced('='.repeat(50));
                
                addToStoryDebounced("You find a group of starving children guarding a cache of food.");
                addToStoryDebounced("They're armed with broken glass and desperation.");
                addToStoryDebounced("You could easily take the food... but they would starve.");
                
                addToStoryDebounced("\nWhat defines you in this moment?");
                currentChoiceContext = { type: "critical_choice", choices: ["Take the food", "Share your supplies", "Walk away"] };
                gameState = "choosing";
                displayOptions();
            } catch (error) {
                handleGameError(new GameError('Error during critical choice event', 'CRITICAL_EVENT_ERROR'));
            }
        }

        // --- Display and Utility Functions ---
        function displayOptions() {
            let optionsText = '';
            if (gameState === "playing") {
                optionsText = "What do you do? Options: stats, wander, rest, remember, inventory, meditate, quit";
            } else if (gameState === "choosing" && currentChoiceContext && currentChoiceContext.choices) {
                optionsText = "Enter the number of your choice:";
                currentChoiceContext.choices.forEach((choice, index) => {
                    optionsText += `<br>${index + 1}. ${choice}`;
                });
            } else if (gameState === "battle" && currentChoiceContext && currentChoiceContext.choices) { 
                optionsText = "Your turn. Enter the number of your choice:";
                currentChoiceContext.choices.forEach((choice, index) => {
                    optionsText += `<br>${index + 1}. ${choice}`;
                });
            } else if (gameState === "using_inventory") {
                optionsText = "Type the number of the item to use it, or 'cancel' to go back.";
            } else if (gameState === "choosing" && currentChoiceContext && currentChoiceContext.type === "explore_memory_shrine_add_name") {
                optionsText = "Whose name do you carve? (Type the name)";
            }

            if (optionsText) {
                addToStoryDebounced(optionsText);
            }
            commandInput.focus();
        }

        function displayMessage(message) {
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                color: #ffd700;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
                z-index: 1000;
                text-align: center;
                font-family: 'Courier New', monospace;
                border: 2px solid #ffd700;
            `;
            messageBox.innerHTML = `
                <p>${message}</p>
                <button style="
                    background: #ffd700;
                    color: #1a1a2e;
                    border: none;
                    padding: 8px 15px;
                    border-radius: 5px;
                    cursor: pointer;
                    margin-top: 15px;
                    font-weight: bold;
                ">OK</button>
            `;
            document.body.appendChild(messageBox);

            messageBox.querySelector('button').onclick = () => {
                document.body.removeChild(messageBox);
                commandInput.focus();
            };
        }

        function checkStatRewards() {
            if (!player) return;

            HOPE_TIERS_REWARDS.forEach(tier => {
                if (player.hope >= tier.threshold && !player.awarded_tiers.hope.includes(tier.threshold)) {
                    player.awarded_tiers.hope.push(tier.threshold);
                    addToStoryDebounced(`\n<span class="hope-positive">*** A surge of hope washes over you! (Hope Tier ${tier.threshold} Reached!) ***</span>`);
                    if (tier.reward.item) player.addLoot(tier.reward.item.toLowerCase(), ITEM_DATA[tier.reward.item.toLowerCase()].desc);
                    if (tier.reward.sanity) player.sanity = Math.min(100, player.sanity + tier.reward.sanity);
                    if (tier.reward.max_hp) { player.max_hp += tier.reward.max_hp; player.hp = player.max_hp; }
                    if (tier.reward.memory) player.addMemory(tier.reward.memory);
                    if (tier.reward.message) addToStoryDebounced(tier.reward.message);
                }
            });

            SANITY_TIERS_REWARDS.forEach(tier => {
                if (player.sanity >= tier.threshold && !player.awarded_tiers.sanity.includes(tier.threshold)) {
                    player.awarded_tiers.sanity.push(tier.threshold);
                    addToStoryDebounced(`\n<span style="color:#8b5cf6;">*** Your mind finds a moment of clarity! (Sanity Tier ${tier.threshold} Reached!) ***</span>`);
                    if (tier.reward.gold) player.gold += tier.reward.gold;
                    if (tier.reward.item) player.addLoot(tier.reward.item.toLowerCase(), ITEM_DATA[tier.reward.item.toLowerCase()].desc);
                    if (tier.reward.karma) player.karma += tier.reward.karma;
                    if (tier.reward.message) addToStoryDebounced(tier.reward.message);
                }
            });

            KARMA_TIERS_REWARDS.forEach(tier => {
                if (player.karma >= tier.threshold && !player.awarded_tiers.karma.includes(tier.threshold)) {
                    player.awarded_tiers.karma.push(tier.threshold);
                    addToStoryDebounced(`\n<span style="color:#facc15;">*** The universe acknowledges your deeds! (Karma Tier ${tier.threshold} Reached!) ***</span>`);
                    if (tier.reward.hope) player.changeHope(tier.reward.hope);
                    if (tier.reward.item) player.addLoot(tier.reward.item.toLowerCase(), ITEM_DATA[tier.reward.item.toLowerCase()].desc);
                    if (tier.reward.hp) player.hp = Math.min(player.max_hp, player.hp + tier.reward.hp);
                    if (tier.reward.max_hp) { player.max_hp += tier.reward.max_hp; player.hp = player.max_hp; }
                    if (tier.reward.sanity) player.sanity = Math.min(100, player.sanity + tier.reward.sanity);
                    if (tier.reward.memory) player.addMemory(tier.reward.memory);
                    if (tier.reward.message) addToStoryDebounced(tier.reward.message);
                }
            });
        }

        // --- Save/Load System ---
        const SaveSystem = {
            save() {
                try {
                    const gameData = {
                        player: { // Only save serializable player properties
                            name: player.name,
                            hp: player.hp,
                            max_hp: player.max_hp,
                            level: player.level,
                            exp: player.exp,
                            gold: player.gold,
                            inventory: player.inventory,
                            karma: player.karma,
                            relationships: player.relationships,
                            memories: player.memories,
                            sanity: player.sanity,
                            hope: player.hope,
                            days_survived: player.days_survived,
                            awarded_tiers: player.awarded_tiers,
                            total_enemies_defeated: player.total_enemies_defeated,
                            mercies_shown: player.mercies_shown
                        },
                        gameState: gameState,
                        currentChoiceContext: currentChoiceContext,
                        battleState: battleState,
                        enemy: enemy, // Enemy object is already plain data
                        weatherSystem: {
                            current: weatherSystem.current
                        },
                        achievementSystem: {
                            unlocked: Array.from(achievementSystem.unlocked) // Convert Set to Array for serialization
                        },
                        version: '1.0' // For future compatibility
                    };
                    
                    localStorage.setItem('lastLight_save', JSON.stringify(gameData));
                    addToStoryDebounced('Game saved successfully.');
                } catch (error) {
                    handleGameError(new GameError('Failed to save game to local storage', 'SAVE_ERROR'));
                }
            },

            load() {
                try {
                    const savedData = JSON.parse(localStorage.getItem('lastLight_save'));
                    if (savedData && savedData.version === '1.0') {
                        // Re-instantiate player and assign properties
                        player = new Player(savedData.player.name);
                        Object.assign(player, savedData.player);

                        gameState = savedData.gameState;
                        currentChoiceContext = savedData.currentChoiceContext;
                        battleState = savedData.battleState;
                        enemy = savedData.enemy;

                        // Re-instantiate systems and assign saved data
                        achievementSystem = new AchievementSystem();
                        achievementSystem.unlocked = new Set(savedData.achievementSystem.unlocked);

                        weatherSystem = new WeatherSystem();
                        weatherSystem.current = savedData.weatherSystem.current;

                        addToStoryDebounced('Game loaded successfully.');
                        updateStats();
                        // If loaded into a choice or battle state, redisplay options
                        if (gameState === "choosing" || gameState === "battle" || gameState === "using_inventory") {
                            displayOptions();
                        } else {
                            // If loading into playing state, ensure general options are shown
                            addToStoryDebounced("What do you do? Options: stats, wander, rest, remember, inventory, meditate, quit");
                        }
                    } else {
                        addToStoryDebounced('No saved game found or save data is incompatible.');
                    }
                } catch (error) {
                    handleGameError(new GameError('Failed to load game from local storage', 'LOAD_ERROR'));
                }
            }
        };

        // --- Achievement System ---
        class AchievementSystem {
            constructor() {
                this.unlocked = new Set();
            }

            check() {
                Object.values(ACHIEVEMENTS).forEach(achievement => {
                    if (!this.unlocked.has(achievement.id) && achievement.condition(player)) {
                        this.unlock(achievement);
                    }
                });
            }

            unlock(achievement) {
                this.unlocked.add(achievement.id);
                addToStoryDebounced(`<span class="achievement">Achievement Unlocked: ${achievement.name} - ${achievement.desc}</span>`);
            }
        }

        // --- Weather System ---
        class WeatherSystem {
            constructor() {
                this.current = WEATHER_TYPES.CLEAR;
            }

            update() {
                const roll = Math.random();
                let newWeather = this.current; // Default to current if no change

                // Simple weather change logic
                if (roll < 0.2) {
                    newWeather = WEATHER_TYPES.ACID_RAIN;
                } else if (roll < 0.4) {
                    newWeather = WEATHER_TYPES.DUST_STORM;
                } else if (roll < 0.6) {
                    newWeather = WEATHER_TYPES.FOG;
                } else {
                    newWeather = WEATHER_TYPES.CLEAR;
                }

                if (newWeather !== this.current) {
                    this.current = newWeather;
                    addToStoryDebounced(`\nWeather changes: ${this.current.description}`);
                }
                this.applyWeatherEffects();
            }

            applyWeatherEffects() {
                const effects = this.current.effects;
                Object.entries(effects).forEach(([stat, value]) => {
                    if (player[stat] !== undefined) {
                        if (stat === 'hp') {
                            player.hp = Math.max(0, player.hp + value);
                        } else if (stat === 'sanity') {
                            player.sanity = Math.max(0, Math.min(100, player.sanity + value));
                        } else if (stat === 'hope') {
                            player.changeHope(value); // Use changeHope for hope effects
                        }
                    }
                });
            }

            determineWeather(roll) {
                // More sophisticated weather determination could go here
                if (roll < 0.1) return WEATHER_TYPES.ACID_RAIN;
                if (roll < 0.3) return WEATHER_TYPES.DUST_STORM;
                if (roll < 0.5) return WEATHER_TYPES.FOG;
                return WEATHER_TYPES.CLEAR;
            }
        }


        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            const playerNameInput = DOMCache.get('player-name');
            playerNameInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    startGame();
                }
            });
            playerNameInput.focus();
        });
    </script>
</body>
</html>
