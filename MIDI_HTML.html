<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Relax Looper</title>
    <style>
        /* Apply Inter font and basic styling to the body */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter as per instructions */
            display: flex;
            justify-content: center; /* Center content horizontally */
            align-items: flex-start; /* Align items to the top */
            min-height: 100vh; /* Ensure it takes full viewport height */
            background-color: #1a1a1a; /* Dark background for ambient feel */
            color: #e0e0e0; /* Light text color */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px; /* Space between the left panel and main content */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Main layout container for left panel and central content */
        .main-layout-container {
            display: flex;
            flex-direction: row; /* Controls on left, main content on right */
            gap: 20px;
            width: 100%;
            max-width: 1200px; /* Max width for the entire layout */
            justify-content: center; /* Center the layout within the body */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Left panel for knobs */
        .left-panel {
            flex: 0 0 250px; /* Fixed width for the left panel, no shrinking */
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Central content container (formerly 'container') */
        .central-content {
            flex: 1; /* Take remaining space */
            min-width: 300px; /* Minimum width for central content */
            background-color: #2a2a2a;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Styling for the main heading */
        h1 {
            color: #90ee90; /* Light green for "Weed" theme */
            margin-bottom: 10px; /* Reduced margin */
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(144, 238, 144, 0.6); /* Glow effect */
        }
        /* Styling for buttons */
        button {
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px; /* Rounded corners for buttons */
            cursor: pointer;
            font-size: 1.2em;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; /* Smooth transitions */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Button shadow */
            outline: none; /* Remove outline on focus */
        }
        /* Hover effects for buttons */
        button:hover {
            background-color: #45a049;
            transform: translateY(-2px); /* Slight lift effect */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        /* Active (click) effects for buttons */
        button:active {
            background-color: #3e8e41;
            transform: translateY(0); /* Return to original position */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        /* Styling for disabled buttons */
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        /* Styling for the custom message box */
        .message-box {
            background-color: #3a3a3a;
            color: #fff;
            padding: 15px;
            border-radius: 8px; /* Rounded corners */
            margin-top: 20px;
            font-size: 0.9em;
            display: none; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        /* Class to show the message box */
        .message-box.show {
            display: block;
            opacity: 1;
        }
        /* Styling for paragraph text */
        p {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        /* Styling for current section display */
        #currentSectionDisplay {
            margin-top: 10px;
            font-size: 1.3em;
            color: #a0ffa0;
            font-weight: bold;
            transition: color 0.3s ease; /* Smooth color transition for highlight */
        }
        /* Highlight for current section */
        #currentSectionDisplay.highlight {
            color: #ffcc00; /* Yellowish highlight */
            text-shadow: 0 0 8px rgba(255, 204, 0, 0.6); /* Subtle glow */
        }
        /* Flex container for control buttons */
        .controls {
            display: flex;
            gap: 15px; /* Space between buttons */
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Styling for knob sections */
        .knob-section {
            background-color: #3a3a3a;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Responsive grid for knobs */
            gap: 15px;
        }
        .knob-section h3 {
            color: #90ee90;
            margin-top: 0;
            margin-bottom: 10px;
            grid-column: 1 / -1; /* Span across all columns */
        }
        .knob-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .knob-group label {
            font-size: 0.9em;
            color: #ccc;
        }
        .knob-group input[type="range"] {
            width: 100px; /* Fixed width for sliders */
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #555;
            outline: none;
            border-radius: 5px;
            transition: background 0.2s;
        }
        .knob-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #90ee90;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(144, 238, 144, 0.5);
        }
        .knob-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #90ee90;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(144, 238, 144, 0.5);
        }
        .knob-value {
            font-size: 0.8em;
            color: #a0ffa0;
        }

        /* Audio Visualizer */
        #audioVisualizer {
            background-color: #000;
            border: 1px solid #4CAF50;
            border-radius: 8px;
            margin-top: 20px;
            width: 100%; /* Make it responsive */
            max-width: 400px; /* Max width for desktop */
            height: 100px; /* Fixed height */
        }

        /* Volume Meter */
        .volume-meter-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            gap: 10px;
        }
        .volume-meter-label {
            font-size: 0.9em;
            color: #ccc;
        }
        #volumeMeter {
            width: 150px;
            height: 15px;
            background-color: #555;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #4CAF50;
            position: relative; /* Added for peak positioning */
        }
        #volumeMeterFill {
            height: 100%;
            width: 0%; /* Starts empty */
            background-color: #90ee90;
            transition: width 0.05s ease-out; /* Smooth transition for volume changes */
        }
        #volumePeak {
            position: absolute;
            height: 100%;
            width: 2px; /* Thin line for peak */
            background-color: #ff0000; /* Red for peak */
            right: 0; /* Initially at the right, will move with peak */
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }

        /* Preset controls */
        .preset-controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        .preset-controls input[type="text"] {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            width: 80%;
            max-width: 200px;
        }
        .preset-controls button {
            padding: 10px 20px;
            font-size: 1em;
            width: 100%;
            max-width: 200px;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            color: #ccc;
            font-size: 0.9em;
        }

        /* Recording Meter Style */
        .recording-meter {
            background-color: #ff4d4d; /* Red for recording */
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.9em;
            display: none; /* Hidden by default */
            animation: pulse 1s infinite alternate; /* Pulsing animation */
        }

        .recording-meter.active {
            display: block;
        }

        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.7; }
        }

        /* Visualization Mode Controls */
        .visualization-controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .visualization-controls button {
            padding: 8px 15px;
            font-size: 0.9em;
            background-color: #555;
            border-radius: 8px;
        }
        .visualization-controls button.active {
            background-color: #90ee90;
            color: #1a1a1a;
            font-weight: bold;
        }

        /* Recording Format Dropdown */
        .recording-format-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-top: 10px;
        }
        .recording-format-control label {
            font-size: 0.9em;
            color: #ccc;
        }
        .recording-format-control select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            width: 150px;
            text-align: center;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-layout-container {
                flex-direction: column; /* Stack panels vertically on small screens */
                align-items: center;
            }
            .left-panel, .central-content {
                width: 95%; /* Make panels take more width */
                flex: none; /* Remove flex grow/shrink */
            }
            #audioVisualizer {
                width: 95%; /* Make visualizer wider on small screens */
            }
        }
    </style>
</head>
<body>
    <div class="main-layout-container">
        <div class="left-panel">
            <div class="knob-section">
                <h3>Master Controls</h3>
                <div class="knob-group">
                    <label for="masterVolume">Master Volume</label>
                    <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.55" title="Adjust overall volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="masterVolumeValue">0.55</span>
                </div>
                <div class="knob-group">
                    <label for="tempo">Tempo (ms)</label>
                    <input type="range" id="tempo" min="300" max="900" step="10" value="420" title="Adjust loop speed. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="tempoValue">420</span>
                </div>
            </div>

            <div class="knob-section">
                <h3>Instrument Gains</h3>
                <div class="knob-group">
                    <label for="bassVolume">Bass Volume</label>
                    <input type="range" id="bassVolume" min="0" max="0.5" step="0.01" value="0.13" title="Adjust bass instrument volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="bassVolumeValue">0.13</span>
                </div>
                <div class="knob-group">
                    <label for="synthVolume">Synth Volume</label>
                    <input type="range" id="synthVolume" min="0" max="0.5" step="0.01" value="0.08" title="Adjust synth instrument volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="synthVolumeValue">0.08</span>
                </div>
                <div class="knob-group">
                    <label for="kickVolume">Kick Volume</label>
                    <input type="range" id="kickVolume" min="0" max="1" step="0.01" value="0.89" title="Adjust kick drum volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="kickVolumeValue">0.89</span>
                </div>
                <div class="knob-group">
                    <label for="snareVolume">Snare Volume</label>
                    <input type="range" id="snareVolume" min="0" max="0.3" step="0.01" value="0.21" title="Adjust snare drum volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="snareVolumeValue">0.21</span>
                </div>
                <div class="knob-group">
                    <label for="hihatVolume">Hi-Hat Volume</label>
                    <input type="range" id="hihatVolume" min="0" max="0.3" step="0.01" value="0.21" title="Adjust hi-hat volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="hihatVolumeValue">0.21</span>
                </div>
            </div>

            <div class="knob-section">
                <h3>Effects</h3>
                <div class="knob-group">
                    <label for="delayTime">Delay Time (s)</label>
                    <input type="range" id="delayTime" min="0.01" max="2.0" step="0.01" value="0.3" title="Set delay time. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="delayTimeValue">0.30</span>
                </div>
                <div class="knob-group">
                    <label for="delayFeedback">Delay Feedback</label>
                    <input type="range" id="delayFeedback" min="0" max="0.95" step="0.01" value="0.4" title="Set delay feedback amount. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="delayFeedbackValue">0.40</span>
                </div>
                <div class="knob-group">
                    <label for="delaySendLevel">Delay Send</label>
                    <input type="range" id="delaySendLevel" min="0" max="1.0" step="0.01" value="0.5" title="Set amount of signal sent to delay. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="delaySendLevelValue">0.50</span>
                </div>
                <div class="knob-group">
                    <label for="chorusDepth">Chorus Depth</label>
                    <input type="range" id="chorusDepth" min="0" max="0.01" step="0.0001" value="0.002" title="Set chorus modulation depth. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="chorusDepthValue">0.002</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="chorusBypass" checked title="Bypass the Chorus effect (Hotkey: C)">
                    <label for="chorusBypass">Bypass Chorus (C)</label>
                </div>
            </div>

            <!-- New Compressor Controls -->
            <div class="knob-section">
                <h3>Compressor</h3>
                <div class="knob-group">
                    <label for="compThreshold">Threshold</label>
                    <input type="range" id="compThreshold" min="-60" max="0" step="1" value="-24" title="Set compressor threshold in dB. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="compThresholdValue">-24 dB</span>
                </div>
                <div class="knob-group">
                    <label for="compRatio">Ratio</label>
                    <input type="range" id="compRatio" min="1" max="20" step="0.1" value="12" title="Set compressor ratio. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="compRatioValue">12:1</span>
                </div>
            </div>

            <!-- New Reverb Controls -->
            <div class="knob-section">
                <h3>Reverb</h3>
                <div class="knob-group">
                    <label for="reverbMix">Mix</label>
                    <input type="range" id="reverbMix" min="0" max="1" step="0.01" value="0.5" title="Set wet/dry mix for reverb. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="reverbMixValue">50%</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="reverbBypass" checked title="Bypass the Reverb effect (Hotkey: R)">
                    <label for="reverbBypass">Bypass Reverb (R)</label>
                </div>
            </div>

        </div>

        <div class="central-content">
            <h1>Simple Relax Looper</h1>
            <p>Experience a subtly evolving ambient track designed for relaxation.</p>
            <div class="controls">
                <button id="startButton" title="Start the music loop (Hotkey: Space/Enter)">Start Looping</button>
                <button id="stopButton" disabled title="Stop the music loop (Hotkey: Space/Enter)">Stop Looping</button>
            </div>
            <div id="currentSectionDisplay">Current Section: --</div>
            <div id="messageBox" class="message-box"></div>

            <!-- Audio Visualization Canvas -->
            <canvas id="audioVisualizer" width="400" height="100"></canvas>

            <!-- Visualization Mode Controls -->
            <div class="visualization-controls">
                <button id="visModeSpectrum" class="active" title="Show frequency spectrum visualization">Spectrum</button>
                <button id="visModeWaveform" title="Show waveform visualization">Waveform</button>
                <button id="visModeBoth" title="Show both spectrum and waveform visualization">Both</button>
                <button id="visModeBands" title="Show bass, mid, and treble frequency bands">Bands</button>
            </div>

            <!-- Master Volume Meter -->
            <div class="volume-meter-container">
                <span class="volume-meter-label">Master Volume:</span>
                <div id="volumeMeter">
                    <div id="volumeMeterFill"></div>
                    <div id="volumePeak"></div>
                </div>
            </div>

            <!-- Preset Controls -->
            <div class="preset-controls knob-section">
                <h3>Presets</h3>
                <input type="text" id="presetNameInput" placeholder="Enter preset name" title="Enter a name for your preset">
                <button id="savePresetButton" title="Save current settings as a preset">Save Preset</button>
                <button id="loadPresetButton" title="Load a saved preset">Load Preset</button>
                <button id="exportPresetsButton" title="Export all saved presets to a JSON file">Export All Presets</button>
                <input type="file" id="importPresetsInput" accept=".json" style="display: none;" title="Select a JSON file to import presets">
                <button id="importPresetsButton" title="Import presets from a JSON file">Import Presets</button>
                <p>Quick Load: Press 1-9 to load "Preset 1" to "Preset 9"</p>
            </div>

            <!-- New Recording Controls -->
            <div class="controls recording-controls">
                <button id="recordButton" title="Start/Stop recording audio (Hotkey: Ctrl+R)">Start Recording</button>
                <div class="recording-format-control">
                    <label for="recordingFormat">Format:</label>
                    <select id="recordingFormat" title="Select recording output format">
                        <option value="wav">WAV (Supported)</option>
                        <option value="mp3">MP3 (Not Supported Natively)</option>
                    </select>
                </div>
                <div class="recording-meter"></div> <!-- Added for the recording meter -->
            </div>
        </div>
    </div>

    <script>
        // Global variables for the Web Audio API context and nodes
        let audioContext;
        let masterGainNode;
        let isPlaying = false; // Flag to track if audio is currently playing
        let nextNoteTime = 0; // The time when the next note should be scheduled
        let loopTimeoutId; // ID for the setTimeout that schedules the next audio event

        // Musical parameters controlled by knobs - initialized to default values
        let masterVolume = 0.55;
        let bassVolume = 0.13;
        let synthVolume = 0.08;
        let kickVolume = 0.89;
        let snareVolume = 0.21;
        let hihatVolume = 0.21;

        let currentTempo = 420;
        let currentDetune = 0;
        let currentFilterFrequency = 1000;
        let currentFilterQ = 1;
        let baseNoteDuration = 0.5;

        // Global variables for filter and detune drift (still apply subtle background changes)
        let filterDriftDirection = 1;
        let detuneDriftDirection = 1;
        let delayTimeDriftDirection = 1;
        let delayFeedbackDriftDirection = 1;

        // Fibonacci-influenced drift scale factors for dynamic parameters
        const fibonacciDriftScales = [0.1, 0.2, 0.3, 0.5, 0.8, 1.3, 2.1];
        let currentFibonacciDriftScaleIndex = 0;

        // Humanization intensity factor, also influenced by Fibonacci drift
        let humanizationFactor = 0.5;

        // Delay effect nodes and parameters
        let delayNode;
        let delayFeedbackGain;
        let delaySendGain;
        let delayTimeValue = 0.3;
        let delayFeedbackValue = 0.4;
        let delaySendLevel = 0.5;

        // Chorus effect nodes and parameters
        let chorusNode;
        let chorusLFO;
        let chorusLfoGain;
        let chorusDepth = 0.002; // Default chorus depth (delay time modulation amount)
        let isChorusBypassed = true; // Default to bypassed

        // New: Compressor nodes and parameters
        let compressorNode;
        let compThreshold = -24;
        let compRatio = 12;

        // New: Reverb nodes and parameters
        let convolverNode;
        let reverbGainNode;
        let dryGainNode;
        let reverbMix = 0.5;
        let isReverbBypassed = true;

        // New: Recording
        let looperRecorder;

        // Visualizer and Volume Meter elements
        let analyserNode;
        let audioVisualizerCanvas;
        let audioVisualizerCtx;
        let volumeMeterElement;
        let volumeMeterFillElement;
        let volumePeakElement; // For peak indicator
        let dataArray; // For analyser time domain data
        let frequencyDataArray; // For analyser frequency data
        let peakValue = 0; // Stores the highest volume peak (0-1 normalized)
        let visualizationMode = 'spectrum'; // 'spectrum', 'waveform', 'both', or 'bands'

        // For cycling through verse patterns (normal and Raga)
        const normalVerseOptions = {
            verse1: ['verse1_A', 'verse1_B', 'verse1_C', 'verse1_D'],
            verse2: ['verse2_A', 'verse2_B', 'verse2_C', 'verse2_D'],
            verse3: ['verse3_A', 'verse3_B', 'verse3_C']
        };
        // Updated: Added more Raga scales
        const ragaVerseOptions = ['ragaYamanPhrase', 'ragaBhairaviPhrase', 'ragaBhoopaliPhrase', 'ragaKhamajPhrase'];
        let availableRagas = [...ragaVerseOptions];
        let normalVerseIndex = 0;
        let verseIterationCount = 0;

        // Predefined frequencies for a simple musical scale
        const notes = {
            'A1': 55.00, 'A#1': 58.27, 'B1': 61.74,
            'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 97.99, 'G#2': 103.83,
            'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65,
            'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30,
            'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25
        };

        // Chromatic scale for transposition calculations
        const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const noteToSemitone = {};
        chromaticScale.forEach((note, index) => {
            noteToSemitone[note] = index;
        });

        // Circle of Fifths for key modulation
        const majorKeysCircleOfFifths = [
            'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'Db', 'Ab', 'Eb', 'Bb', 'F'
        ];
        const keyToSemitoneOffsetFromC = {
            'C': 0, 'G': 7, 'D': 2, 'A': 9, 'E': 4, 'B': 11, 'F#': 6,
            'Db': 1, 'Ab': 8, 'Eb': 3, 'Bb': 10, 'F': 5
        }; // Maps key name to semitone offset from C

        let currentKey = 'C'; // Initial key for the loop

        /**
         * Transposes an array of note strings by a given number of semitones.
         * @param {Array<string>} notesArray - An array of note strings (e.g., ['C4', 'G3']).
         * @param {number} semitones - The number of semitones to transpose by.
         * @returns {Array<string>} A new array with transposed note strings.
         */
        function transposeNotes(notesArray, semitones) {
            return notesArray.map(noteString => {
                const baseNote = noteString.slice(0, -1);
                const octave = parseInt(noteString.slice(-1));
                
                if (!noteToSemitone.hasOwnProperty(baseNote)) {
                    console.warn(`Unknown base note for transposition: ${baseNote}`);
                    return noteString; // Return original if unknown
                }

                let semitoneValue = noteToSemitone[baseNote] + semitones;
                let newOctave = octave + Math.floor(semitoneValue / 12);
                let newSemitoneIndex = (semitoneValue % 12 + 12) % 12; // Ensure positive modulo

                return chromaticScale[newSemitoneIndex] + newOctave;
            });
        }

        // New Raga scale definitions (using C as tonic for simplicity)
        const ragaScales = {
            yaman: ['C4', 'D4', 'E4', 'F#4', 'G4', 'A4', 'B4', 'C5'],
            bhairavi: ['C4', 'C#4', 'D#4', 'F4', 'G4', 'G#4', 'A#4', 'C5'],
            // New Raga scales
            bhoopali: ['C4', 'D4', 'E4', 'G4', 'A4', 'C5'], // Pentatonic scale
            khamaj: ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'A#4', 'C5'] // Natural minor with major 7th
        };

        // Raga Characteristics System
        const ragaCharacteristics = {
            time: {
                morning: ['yaman', 'bhairavi', 'bhoopali'], // Adjusted to use ragaScales keys
                afternoon: ['sarang', 'bhimpalasi'], // Placeholder, not implemented in ragaScales
                evening: ['yaman', 'purvi'], // Placeholder, not implemented in ragaScales
                night: ['malkauns', 'darbari'] // Placeholder, not implemented in ragaScales
            },
            moods: {
                peaceful: ['bhoopali', 'yaman'],
                energetic: ['sarang', 'bhairavi'],
                melancholic: ['todi', 'malkauns'],
                romantic: ['khamaj', 'bhimpalasi']
            }
        };

        /**
         * Selects a Raga appropriate for the current time of day.
         * @returns {string} The name of a time-appropriate Raga (e.g., 'yaman').
         */
        function selectTimeAppropriateRaga() {
            const hour = new Date().getHours();
            const timeOfDay = 
                hour >= 4 && hour < 8 ? 'morning' :
                hour >= 8 && hour < 16 ? 'afternoon' :
                hour >= 16 && hour < 20 ? 'evening' : 'night';
            
            const appropriateRagas = ragaCharacteristics.time[timeOfDay];
            // Filter to ensure we only pick ragas that are actually defined in ragaScales
            const availableAndDefinedRagas = appropriateRagas.filter(raga => ragaScales[raga]);

            if (availableAndDefinedRagas.length > 0) {
                return availableAndDefinedRagas[Math.floor(Math.random() * availableAndDefinedRagas.length)];
            } else {
                console.warn(`No defined Raga scales found for time of day: ${timeOfDay}. Falling back to 'yaman'.`);
                return 'yaman'; // Fallback to a default Raga if none are defined for the time
            }
        }


        /**
         * Generates a melodic phrase within a given Raga scale, with expressive variations.
         * @param {Array<string>} scale - Array of note names in the Raga scale (e.g., ['C4', 'D4', 'E4']).
         * @param {number} phraseLength - Number of steps in the phrase (e.g., 8).
         * @param {number} humanizationFactor - A factor influencing how "busy" or sparse the melody is (0-1).
         * @returns {Array<Object>} An array of phrase steps.
         */
        function generateRagaMelody(scale, phraseLength, humanizationFactor) {
            const generatedPhrase = [];
            let currentNoteIndex = Math.floor(Math.random() * scale.length);
            let lastDirection = Math.random() < 0.5 ? 1 : -1;

            // Ensure scale has enough elements before accessing specific indices
            const vadiNote = scale[0];
            const samvadiNote = scale.length > 4 ? scale[4] : scale[scale.length - 1]; // Fallback for scales with less than 5 notes

            for (let i = 0; i < phraseLength; i++) {
                const step = {
                    bass: [],
                    synth: [],
                    percussion: {},
                    delaySend: 0.3 + (Math.random() * 0.3)
                };

                // Bass Line Generation
                if (i % 4 === 0) {
                    step.bass.push(scale[0].replace('4', '2'));
                } else if (i % 2 === 0 && Math.random() < 0.6) {
                    const bassOptions = [scale[0].replace('4', '2'), (scale.length > 4 ? scale[4] : scale[scale.length -1]).replace('4', '2')];
                    if (scale.length > 5 && Math.random() < 0.3) {
                        bassOptions.push(scale[2].replace('4', '2'));
                    }
                    step.bass.push(bassOptions[Math.floor(Math.random() * bassOptions.length)]);
                }
                if (step.bass.length === 0) {
                    step.bass.push(scale[0].replace('4', '2'));
                }

                // Synth Melody Generation
                const numSynthNotes = 1 + Math.floor(Math.random() * (humanizationFactor * 2));
                
                for (let j = 0; j < numSynthNotes; j++) {
                    let nextNoteIndex = currentNoteIndex;

                    if (Math.random() < 0.3 + (humanizationFactor * 0.2)) {
                        lastDirection *= -1;
                    }

                    const moveType = Math.random();
                    let moveAmount = 0;

                    if (moveType < 0.7) {
                        moveAmount = 1;
                    } else if (moveType < 0.9) {
                        moveAmount = Math.random() < 0.5 ? 2 : 3;
                    } else {
                        moveAmount = Math.random() < 0.5 ? 4 : 5;
                    }

                    nextNoteIndex = (currentNoteIndex + lastDirection * moveAmount + scale.length * 2) % scale.length;
                    
                    const currentNoteFreq = notes[scale[currentNoteIndex]];
                    const vadiFreq = notes[vadiNote];
                    const samvadiFreq = notes[samvadiNote];

                    if (Math.abs(currentNoteFreq - vadiFreq) > 50 && Math.random() < 0.4) {
                        lastDirection = (currentNoteFreq < vadiFreq) ? 1 : -1;
                        nextNoteIndex = scale.indexOf(vadiNote);
                    } else if (samvadiNote && Math.abs(currentNoteFreq - samvadiFreq) > 50 && Math.random() < 0.2) {
                        lastDirection = (currentNoteFreq < samvadiNote) ? 1 : -1;
                        nextNoteIndex = scale.indexOf(samvadiNote);
                    }

                    currentNoteIndex = nextNoteIndex;

                    let synthNote = scale[currentNoteIndex];
                    const currentOctave = parseInt(synthNote.slice(-1));
                    if (Math.random() < 0.3 * humanizationFactor) {
                        if (Math.random() < 0.5 && currentOctave < 5) {
                            synthNote = synthNote.slice(0, -1) + (currentOctave + 1);
                        } else if (currentOctave > 3) {
                            synthNote = synthNote.slice(0, -1) + (currentOctave - 1);
                        }
                    }
                    step.synth.push(synthNote);
                }
                if (step.synth.length === 0) {
                    step.synth.push(scale[currentNoteIndex]);
                }

                // Percussion: Use fixed probabilities for percussion in generated Raga melodies
                if (i === 0 || i === 4) { // Kick on 1 and 5
                    if (Math.random() < 0.9) { // 90% probability for kick
                        step.percussion.kick = { active: true, velocity: 1.0 };
                    }
                }
                if (i === 2 || i === 6) { // Snare on 3 and 7
                    if (Math.random() < 0.8) { // 80% probability for snare
                        step.percussion.snare = { active: true, velocity: 1.0 };
                    }
                }
                if (i % 2 === 0) { // On every other beat, hi-hat
                    if (Math.random() < 1.0) { // 100% probability for hi-hat
                        step.percussion.hihat = { active: true, type: 'closed', velocity: 0.8 }; // Slightly lower velocity for closed hi-hat
                    }
                    }

                generatedPhrase.push(step);
            }
            return generatedPhrase;
        }


        // Define musical phrases for each section of the song
        // Percussion now includes 'active', 'probability', and 'velocity' for dynamic sequencing
        const musicalPhrases = {
            intro: [
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.8 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.7 },
                { bass: ['E2'], synth: ['E4'], percussion: {}, delaySend: 0.6 },
                { bass: ['E2'], synth: ['E4'], percussion: {}, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4'], percussion: {}, delaySend: 0.4 },
                { bass: ['C3'], synth: ['C4'], percussion: {}, delaySend: 0.3 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.2 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.1 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: {}, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: {}, delaySend: 0.0 },
                { bass: ['E2'], synth: ['E4', 'G4'], percussion: {}, delaySend: 0.0 },
                { bass: ['E2'], synth: ['E4', 'G4'], percussion: {}, delaySend: 0.0 },
                { bass: ['C3'], synth: ['C4', 'E4'], percussion: {}, delaySend: 0.0 },
                { bass: ['C3'], synth: ['C4', 'E4'], percussion: {}, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: {}, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: {}, delaySend: 0.0 }
            ],
            verse1_A: [
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3', 'C4', 'F4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_B: [
                { bass: ['C2'], synth: ['E4', 'G4', 'C5'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3', 'D4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4', 'E4', 'A4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3', 'C4', 'F4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_C: [
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_D: [
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } } },
                { bass: ['G2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 }
            ],
            verse2_A: [
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_B: [
                { bass: ['F2'], synth: ['C4', 'F4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['G3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['D4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['E4', 'A4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_C: [
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            ragaYamanPhrase: [],
            ragaBhairaviPhrase: [],
            ragaBhoopaliPhrase: [], // New Raga phrase placeholder
            ragaKhamajPhrase: [],   // New Raga phrase placeholder
            
            chorus: [
                { bass: ['A2'], synth: ['A4', 'C5', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['A2'], synth: ['C5'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['G2'], synth: ['G4', 'B4', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['G2'], synth: ['B4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['C3'], synth: ['C4', 'E4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['C3'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['F2'], synth: ['F4', 'A4', 'C5'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['F2'], synth: ['A4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 }
            ],
            bridge: [
                { bass: ['D2'], synth: ['D4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 },
                { bass: ['E2'], synth: ['E4', 'G4', 'B4'], percussion: {}, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3', 'D4', 'G4'], percussion: {}, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 },
                { bass: ['D2'], synth: ['D4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 },
                { bass: ['E2'], synth: ['E4', 'G4', 'B4'], percussion: {}, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3', 'D4', 'G4'], percussion: {}, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 }
            ],
            outro: [
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: {}, delaySend: 0.8 },
                { bass: ['A2'], synth: ['E4'], percussion: {}, delaySend: 0.7 },
                { bass: ['C3'], synth: ['C4', 'G3'], percussion: {}, delaySend: 0.6 },
                { bass: ['C3'], synth: ['G3'], percussion: {}, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.4 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.3 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.2 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.0 }
            ]
        };

        const songStructure = [
            { type: 'intro', durationMultiplier: 2, initialKey: 'A' }, // Added initialKey for intro
            { type: 'verse', baseName: 'verse1', durationMultiplier: 3, initialKey: 'C' }, // Initial key for verse1
            { type: 'chorus', durationMultiplier: 2, initialKey: 'A' },
            { type: 'verse', baseName: 'verse2', durationMultiplier: 3, initialKey: 'F' }, // Initial key for verse2
            { type: 'verse', baseName: 'verse3', durationMultiplier: 5, initialKey: 'G' }, // Initial key for verse3
            { type: 'bridge', durationMultiplier: 2, initialKey: 'D' },
            { type: 'chorus', durationMultiplier: 3, initialKey: 'A' },
            { type: 'verse', baseName: 'verse1', durationMultiplier: 2, initialKey: 'C' },
            { type: 'outro', durationMultiplier: 2, initialKey: 'A' }
        ];

        let currentSongSectionIndex = 0;
        let currentSectionType = '';
        let currentSectionName = '';
        let currentSectionPhrase = [];
        let currentPhraseIndex = 0;
        let stepsPlayedInCurrentSection = 0;
        let currentSectionTotalSteps = 0;

        /**
         * Shuffles an array in place (Fisher-Yates algorithm).
         * @param {Array} array - The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * Gets the next Raga phrase from the available pool, ensuring non-repetition until all are played.
         * @returns {string} The name of the next Raga phrase.
         */
        function getNextRagaPhrase() {
            if (availableRagas.length === 0) {
                availableRagas = [...ragaVerseOptions];
                shuffleArray(availableRagas);
                console.log("Raga pool reset and shuffled:", availableRagas);
            }
            const nextRaga = availableRagas.shift();
            console.log("Next Raga:", nextRaga, "Remaining Ragas:", availableRagas);
            return nextRaga;
        }

        /**
         * Selects a random variation for a given normal verse base name.
         * @param {string} baseName - The base name of the verse (e.g., 'verse1').
         * @returns {string} The name of the selected verse variation (e.g., 'verse1_A').
         */
        function getRandomNormalVerseVariation(baseName) {
            const variations = normalVerseOptions[baseName];
            if (!variations || variations.length === 0) {
                console.warn(`No variations found for normal verse: ${baseName}`);
                return baseName;
            }
            const randomIndex = Math.floor(Math.random() * variations.length);
            return variations[randomIndex];
        }

        /**
         * Updates the display with the current song section and applies a highlight.
         */
        function updateSectionDisplay() {
            const displayElement = document.getElementById('currentSectionDisplay');
            if (displayElement) {
                const newText = `Current Section: ${currentSectionName.toUpperCase()} in ${currentKey} Major`;
                if (displayElement.textContent !== newText) {
                     displayElement.classList.remove('highlight');
                }
                displayElement.textContent = newText;
                requestAnimationFrame(() => {
                    displayElement.classList.add('highlight');
                });
            }
        }

        /**
         * Displays a temporary message to the user in a dedicated message box.
         * @param {string} message - The text message to display.
         * @param {number} duration - How long the message should be visible in milliseconds.
         */
        function showMessage(message, duration = 3000) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }

        /**
         * Initializes the Web Audio API context and the master gain node.
         * This function needs to be called after a user gesture (e.e.g., button click)
         * to comply with browser autoplay policies.
         * @returns {boolean} True if audio context was successfully initialized or already exists, false otherwise.
         */
        function initAudio() {
            console.log("Attempting to initialize audio context...");
            if (!audioContext) {
                try {
                    showMessage("Loading Audio System...", 5000); // Show loading message
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = masterVolume;
                    
                    // Delay setup
                    delayNode = audioContext.createDelay(2.0);
                    delayFeedbackGain = audioContext.createGain();
                    delaySendGain = audioContext.createGain();

                    // Chorus setup
                    chorusNode = audioContext.createDelay(0.01); // Max delay for chorus, typically very small
                    chorusLFO = audioContext.createOscillator();
                    chorusLfoGain = audioContext.createGain();

                    chorusLFO.type = 'sine';
                    chorusLFO.frequency.value = 1.5; // LFO frequency for chorus modulation
                    chorusLfoGain.gain.value = chorusDepth; // Modulation depth
                    
                    chorusLFO.connect(chorusLFO.frequency); // Connect LFO to its own frequency to create vibrato effect
                    chorusLFO.connect(chorusLfoGain);
                    chorusLfoGain.connect(chorusNode.delayTime);
                    chorusLFO.start(audioContext.currentTime); // Start LFO immediately

                    // Compressor setup
                    compressorNode = audioContext.createDynamicsCompressor();
                    compressorNode.threshold.value = compThreshold;
                    compressorNode.knee.value = 30; // Default value, not exposed to UI
                    compressorNode.ratio.value = compRatio;
                    compressorNode.attack.value = 0.003; // Default value
                    compressorNode.release.value = 0.25; // Default value

                    // Reverb setup
                    convolverNode = audioContext.createConvolver();
                    reverbGainNode = audioContext.createGain();
                    dryGainNode = audioContext.createGain();

                    // Create a simple synthetic impulse response for reverb
                    const impulseLength = 2; // seconds
                    const sampleRate = audioContext.sampleRate;
                    const impulseBuffer = audioContext.createBuffer(2, sampleRate * impulseLength, sampleRate);
                    const leftChannel = impulseBuffer.getChannelData(0);
                    const rightChannel = impulseBuffer.getChannelData(1);

                    for (let i = 0; i < sampleRate * impulseLength; i++) {
                        // Simple decaying noise burst
                        leftChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / (sampleRate * impulseLength), 2);
                        rightChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / (sampleRate * impulseLength), 2);
                    }
                    convolverNode.buffer = impulseBuffer;
                    reverbGainNode.gain.value = reverbMix;
                    dryGainNode.gain.value = 1 - reverbMix; // Initial dry mix

                    // Analyser Node for Visualization and Volume Meter
                    analyserNode = audioContext.createAnalyser();
                    analyserNode.fftSize = 256; // For time domain data
                    analyserNode.smoothingTimeConstant = 0.8; // Smoother visualization
                    analyserNode.minDecibels = -90;
                    analyserNode.maxDecibels = -10;
                    
                    // Initialize data arrays with correct sizes
                    dataArray = new Uint8Array(analyserNode.frequencyBinCount); // For time domain visualization
                    frequencyDataArray = new Uint8Array(analyserNode.frequencyBinCount); // For frequency visualization and volume meter

                    // Connect nodes:
                    // Master -> Delay Send -> Delay -> Destination
                    // Master -> Compressor -> (Dry Signal / Reverb Wet Signal) -> Analyser -> Destination
                    
                    // Main audio path: Master -> Compressor
                    masterGainNode.connect(compressorNode);

                    // Delay path: Master -> Delay Send -> Delay -> Destination
                    masterGainNode.connect(delaySendGain);
                    delaySendGain.connect(delayNode);
                    delayNode.connect(audioContext.destination);

                    // Reverb path: Compressor -> (Dry Gain / Convolver + Reverb Gain) -> Analyser
                    // Disconnect analyser from masterGainNode if it was connected directly
                    try {
                        masterGainNode.disconnect(analyserNode);
                    } catch (e) { /* ignore */ }

                    // Connect compressor to dry and wet reverb paths
                    compressorNode.connect(dryGainNode);
                    dryGainNode.connect(analyserNode); // Dry signal to analyser

                    compressorNode.connect(convolverNode);
                    convolverNode.connect(reverbGainNode);
                    reverbGainNode.connect(analyserNode); // Wet signal to analyser

                    // Analyser always connects to destination
                    analyserNode.connect(audioContext.destination);

                    // Initialize UI elements for visualization and volume meter
                    audioVisualizerCanvas = document.getElementById('audioVisualizer');
                    audioVisualizerCtx = audioVisualizerCanvas.getContext('2d');
                    volumeMeterElement = document.getElementById('volumeMeter');
                    volumeMeterFillElement = document.getElementById('volumeMeterFill');
                    volumePeakElement = document.getElementById('volumePeak');

                    // Set initial values for delay
                    delayNode.delayTime.value = delayTimeValue;
                    delayFeedbackGain.gain.value = delayFeedbackValue;
                    delaySendGain.gain.value = delaySendLevel;

                    // Initialize recorder
                    looperRecorder = new EnhancedLooperRecorder(audioContext);
                    // The EnhancedLooperRecorder constructor now handles its own initialization
                    // looperRecorder.initializeRecorder(); 

                    showMessage(`Audio context initialized. Master Gain: ${masterVolume.toFixed(2)}`);
                    console.log("AudioContext initialized successfully. State:", audioContext.state);
                } catch (e) {
                    showMessage("Web Audio API is not supported in this browser or could not be initialized. Please try a different browser.", 5000);
                    console.error("Web Audio API error:", e);
                    return false;
                }
            } else {
                console.log("AudioContext already exists. State:", audioContext.state);
            }
            return true;
        }

        /**
         * Plays a single musical note using an oscillator and applies a simple ADSR envelope,
         * detune, and a low-pass filter.
         * @param {number} frequency - The frequency of the note in Hz.
         * @param {number} startTime - The AudioContext.currentTime when the note should start.
         * @param {number} duration - The duration of the note in seconds.
         * @param {number} detuneValue - The detune value in cents.
         * @param {number} filterFreq - The cutoff frequency for the low-pass filter.
         * @param {number} filterQ - The Q factor for the low-pass filter.
         * @param {string} instrumentType - 'bass' or 'synth' to determine timbre.
         */
        function playNote(frequency, startTime, duration, detuneValue = currentDetune, filterFreq = currentFilterFrequency, filterQ = currentFilterQ, instrumentType = 'synth') {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play note: AudioContext or masterGainNode not available.");
                return;
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();

            const timingOffset = (Math.random() - 0.5) * 0.08 * humanizationFactor;
            const dynamicFactor = 1 + (Math.random() - 0.5) * 0.6 * humanizationFactor;
            const durationFactor = 1 + (Math.random() - 0.5) * 0.3 * humanizationFactor;

            const actualStartTime = Math.max(0, startTime + timingOffset);
            const actualDuration = duration * durationFactor;

            let attackTime = 0.05;
            let decayTime = 0.2;
            let sustainLevel = 0.5;
            let releaseTime = 0.2;
            let initialGain = synthVolume;
            let oscType = 'sine';

            switch (instrumentType) {
                case 'bass':
                    oscType = 'triangle';
                    attackTime = 0.02;
                    decayTime = 0.3;
                    sustainLevel = 0.5;
                    releaseTime = 0.2;
                    initialGain = bassVolume;
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(400, actualStartTime);
                    filterNode.Q.setValueAtTime(0.8, actualStartTime);
                    break;
                case 'synth':
                default:
                    oscType = 'sine';
                    attackTime = 0.1;
                    decayTime = 0.5;
                    sustainLevel = 0.6;
                    releaseTime = 0.8;
                    initialGain = synthVolume;
                    filterNode.type = 'lowpass';
                    
                    const initialFilterFreq = filterFreq * (1 + (Math.random() - 0.5) * 0.2 * humanizationFactor);
                    const finalFilterFreq = filterFreq;
                    filterNode.frequency.setValueAtTime(initialFilterFreq, actualStartTime);
                    filterNode.frequency.linearRampToValueAtTime(finalFilterFreq, actualStartTime + 0.5);
                    
                    filterNode.Q.setValueAtTime(filterQ, actualStartTime);
                    break;
            }

            oscillator.type = oscType;
            oscillator.frequency.setValueAtTime(frequency, actualStartTime);
            oscillator.detune.setValueAtTime(detuneValue, actualStartTime);

            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(masterGainNode);

            gainNode.gain.setValueAtTime(0, actualStartTime);
            gainNode.gain.linearRampToValueAtTime(initialGain * dynamicFactor, actualStartTime + attackTime);
            gainNode.gain.linearRampToValueAtTime(initialGain * dynamicFactor * sustainLevel, actualStartTime + attackTime + decayTime);

            const releaseStartTime = Math.max(actualStartTime, actualStartTime + actualDuration - releaseTime);
            const finalReleaseTime = Math.max(actualStartTime + attackTime + decayTime, releaseStartTime);

            gainNode.gain.exponentialRampToValueAtTime(0.0001, finalReleaseTime);
            gainNode.gain.linearRampToValueAtTime(0, Math.max(actualStartTime, actualStartTime + actualDuration));

            oscillator.start(actualStartTime);
            oscillator.stop(Math.max(actualStartTime, actualStartTime + actualDuration));

            oscillator.onended = () => {
                oscillator.disconnect();
                gainNode.disconnect();
                filterNode.disconnect();
            };
        }

        /**
         * Plays a simple drum sound using a short, decaying sine wave.
         * @param {number} startTime - The AudioContext.currentTime when the drum sound should start.
         * @param {number} velocity - The velocity (0-1) of the drum hit.
         */
        function playDrum(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play drum: AudioContext or masterGainNode not available.");
                return;
            }

            const drumOscillator = audioContext.createOscillator();
            const drumGain = audioContext.createGain();
            const drumFilter = audioContext.createBiquadFilter();

            const actualStartTime = Math.max(0, startTime);

            drumOscillator.type = 'sine';
            drumOscillator.frequency.setValueAtTime(80, actualStartTime);
            drumOscillator.frequency.exponentialRampToValueAtTime(30, actualStartTime + 0.1);

            drumFilter.type = 'lowpass';
            drumFilter.frequency.setValueAtTime(500, actualStartTime);
            drumFilter.frequency.exponentialRampToValueAtTime(100, actualStartTime + 0.15);
            drumFilter.Q.setValueAtTime(1, actualStartTime);

            drumOscillator.connect(drumFilter);
            drumFilter.connect(drumGain);
            drumGain.connect(masterGainNode);

            drumGain.gain.setValueAtTime(kickVolume * velocity, actualStartTime); // Apply velocity
            drumGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.2);

            drumOscillator.start(actualStartTime);
            drumOscillator.stop(actualStartTime + 0.2);

            drumOscillator.onended = () => {
                drumOscillator.disconnect();
                drumGain.disconnect();
                drumFilter.disconnect();
            };
        }

        /**
         * Plays a snare drum sound using white noise and an oscillator.
         * @param {number} startTime - The AudioContext.currentTime when the snare sound should start.
         * @param {number} velocity - The velocity (0-1) of the snare hit.
         */
        function playSnare(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play snare: AudioContext or masterGainNode not available.");
                return;
            }

            const actualStartTime = Math.max(0, startTime);

            const noise = audioContext.createBufferSource();
            const bufferSize = audioContext.sampleRate * 0.2;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(snareVolume * 0.7 * velocity, actualStartTime); // Apply velocity
            noiseGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.15);
            noise.connect(noiseGain);

            const osc = audioContext.createOscillator();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, actualStartTime);
            osc.frequency.exponentialRampToValueAtTime(100, actualStartTime + 0.1);

            const oscGain = audioContext.createGain();
            oscGain.gain.setValueAtTime(snareVolume * 1.0 * velocity, actualStartTime); // Apply velocity
            oscGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.1);
            osc.connect(oscGain);

            const mixer = audioContext.createGain();
            noiseGain.connect(mixer);
            oscGain.connect(mixer);
            mixer.connect(masterGainNode);

            noise.start(actualStartTime);
            osc.start(actualStartTime);
            noise.stop(actualStartTime + 0.2);
            osc.stop(actualStartTime + 0.2);

            osc.onended = () => {
                noise.disconnect();
                osc.disconnect();
                noiseGain.disconnect();
                oscGain.disconnect();
                mixer.disconnect();
            };
        }

        /**
         * Plays a closed hi-hat sound.
         * @param {number} startTime - The AudioContext.currentTime when the hi-hat sound should start.
         * @param {number} velocity - The velocity (0-1) of the hi-hat hit.
         */
        function playHiHatClosed(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) return;

            const actualStartTime = Math.max(0, startTime);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(10000, actualStartTime);
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(7000, actualStartTime);
            filter.Q.setValueAtTime(0.5, actualStartTime);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGainNode);

            gain.gain.setValueAtTime(hihatVolume * 0.7 * velocity, actualStartTime); // Apply velocity
            gain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.05);

            osc.start(actualStartTime);
            osc.stop(actualStartTime + 0.05);

            osc.onended = () => {
                osc.disconnect(); 
                gain.disconnect();
                filter.disconnect();
            };
        }

        /**
         * Plays an open hi-hat sound.
         * @param {number} startTime - The AudioContext.currentTime when the hi-hat sound should start.
         * @param {number} velocity - The velocity (0-1) of the hi-hat hit.
         */
        function playHiHatOpen(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) return;

            const actualStartTime = Math.max(0, startTime);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(8000, actualStartTime);
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(5000, actualStartTime);
            filter.Q.setValueAtTime(0.5, actualStartTime);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGainNode);

            gain.gain.setValueAtTime(hihatVolume * 1.0 * velocity, actualStartTime); // Apply velocity
            gain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.2);

            osc.start(actualStartTime);
            osc.stop(actualStartTime + 0.2);

            osc.onended = () => {
                osc.disconnect(); 
                gain.disconnect();
                filter.disconnect();
            };
        }

        /**
         * Applies subtle, random changes to various musical parameters for the next musical step.
         * These changes are applied on top of the user-controlled knob values.
         */
        function applySubtleChanges() {
            const driftScale = fibonacciDriftScales[currentFibonacciDriftScaleIndex];

            currentDetune += detuneDriftDirection * (Math.random() * driftScale * 1.5 + (driftScale / 2));
            if (currentDetune > 12) {
                detuneDriftDirection = -1;
            } else if (currentDetune < -12) {
                detuneDriftDirection = 1;
            }
            currentDetune = Math.max(-12, Math.min(12, currentDetune));

            currentFilterFrequency += filterDriftDirection * (Math.random() * driftScale * 50 + 10);
            if (currentFilterFrequency > 3000) {
                filterDriftDirection = -1;
            } else if (currentFilterFrequency < 500) {
                filterDriftDirection = 1;
            }
            currentFilterFrequency = Math.max(500, Math.min(3000, currentFilterFrequency));

            currentFilterQ += (Math.random() - 0.5) * driftScale * 0.5;
            currentFilterQ = Math.max(0.5, Math.min(3, currentFilterQ));

            baseNoteDuration += (Math.random() - 0.5) * driftScale * 0.05;
            baseNoteDuration = Math.max(0.3, Math.min(0.7, baseNoteDuration));

            humanizationFactor += (Math.random() - 0.5) * driftScale * 0.1;
            humanizationFactor = Math.max(0.1, Math.min(1.0, humanizationFactor));

            delayTimeValue += delayTimeDriftDirection * (Math.random() - 0.5) * driftScale * 0.02;
            if (delayTimeValue > 1.0) {
                delayTimeDriftDirection = -1;
            } else if (delayTimeValue < 0.1) {
                delayTimeDriftDirection = 1;
            }
            delayTimeValue = Math.max(0.01, Math.min(2.0, delayTimeValue));
            if (audioContext && delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, audioContext.currentTime);

            delayFeedbackValue += delayFeedbackDriftDirection * (Math.random() - 0.5) * driftScale * 0.01;
            if (delayFeedbackValue > 0.8) {
                delayFeedbackDriftDirection = -1;
            } else if (delayFeedbackValue < 0.1) {
                delayFeedbackDriftDirection = 1;
            }
            delayFeedbackValue = Math.max(0, Math.min(0.95, delayFeedbackValue));
            if (audioContext && delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, audioContext.currentTime);
        }

        /**
         * The main audio scheduling loop. It continuously checks if there are events
         * to be played in the near future and schedules them using AudioContext.currentTime.
         * This method is more precise than setTimeout for timing musical events.
         */
        function scheduler() {
            if (!isPlaying || !audioContext) {
                console.log("Scheduler stopping: isPlaying=", isPlaying, " audioContext=", audioContext);
                return;
            }

            while (nextNoteTime < audioContext.currentTime + 0.1) {
                const currentStep = currentSectionPhrase[currentPhraseIndex];
                
                // Robust check for currentStep and its essential properties
                if (!currentStep || typeof currentStep !== 'object' || !Array.isArray(currentStep.synth) || !Array.isArray(currentStep.bass) || typeof currentStep.percussion !== 'object' || currentStep.percussion === null) {
                    console.error(`Invalid or malformed currentStep at index ${currentPhraseIndex}:`, currentStep);
                    // Attempt to recover by forcing a section transition
                    currentPhraseIndex = 0; // Reset index for the new section
                    stepsPlayedInCurrentSection = currentSectionTotalSteps; // Force transition
                    continue; // Skip to the next iteration of the while loop
                }

                const duration = baseNoteDuration;

                const effectiveDelaySend = (currentStep.delaySend !== undefined ? currentStep.delaySend : 0.5) * delaySendLevel;
                if (audioContext && delaySendGain) {
                    delaySendGain.gain.linearRampToValueAtTime(effectiveDelaySend, audioContext.currentTime + 0.05);
                }

                if (currentStep.synth && currentStep.synth.length > 0) {
                    currentStep.synth.forEach(noteName => {
                        const frequency = notes[noteName];
                        if (frequency) {
                            playNote(frequency, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, 'synth');
                        } else {
                            console.warn(`Synth note frequency not found for note: ${noteName}`);
                        }
                    });
                }

                if (currentStep.bass && currentStep.bass.length > 0) {
                    currentStep.bass.forEach(noteName => {
                        const frequency = notes[noteName];
                        if (frequency) {
                            playNote(frequency, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, 'bass');
                        } else {
                            console.warn(`Bass note frequency not found for note: ${noteName}`);
                        }
                    });
                }

                // Percussion logic updated to use probability and velocity
                if (currentStep.percussion) {
                    if (currentStep.percussion.kick && currentStep.percussion.kick.active && Math.random() < currentStep.percussion.kick.probability) {
                        playDrum(nextNoteTime, currentStep.percussion.kick.velocity);
                    }
                    if (currentStep.percussion.snare && currentStep.percussion.snare.active && Math.random() < currentStep.percussion.snare.probability) {
                        playSnare(nextNoteTime, currentStep.percussion.snare.velocity);
                    }
                    if (currentStep.percussion.hihat && currentStep.percussion.hihat.active && Math.random() < currentStep.percussion.hihat.probability) {
                        if (currentStep.percussion.hihat.type === 'closed') {
                            playHiHatClosed(nextNoteTime, currentStep.percussion.hihat.velocity);
                        } else if (currentStep.percussion.hihat.type === 'open') {
                            playHiHatOpen(nextNoteTime, currentStep.percussion.hihat.velocity);
                        }
                    }
                }

                nextNoteTime += (currentTempo / 1000);
                
                stepsPlayedInCurrentSection++;
                currentPhraseIndex++;
                applySubtleChanges();

                if (currentPhraseIndex >= currentSectionPhrase.length) {
                    currentPhraseIndex = 0;
                }

                if (stepsPlayedInCurrentSection >= currentSectionTotalSteps) {
                    console.log(`End of section '${currentSectionName}' reached.`);
                    currentPhraseIndex = 0;
                    stepsPlayedInCurrentSection = 0;
                    currentSongSectionIndex++;

                    currentFibonacciDriftScaleIndex = (currentFibonacciDriftScaleIndex + 1) % fibonacciDriftScales.length;

                    if (currentSongSectionIndex >= songStructure.length) {
                        currentSongSectionIndex = 0;
                        console.log("End of song structure reached. Looping back to Intro.");
                    }

                    const nextSectionDef = songStructure[currentSongSectionIndex];
                    currentSectionType = nextSectionDef.type;
                    let phraseToUse = []; // Temporary variable to hold the phrase before assignment
                    
                    // Determine the new key based on Circle of Fifths logic for verse sections
                    let previousKey = currentKey; // Store the key of the just-finished section
                    let newKey = previousKey; // Default to staying in the same key

                    if (currentSectionType === 'verse') {
                        verseIterationCount++;
                        if (verseIterationCount % 2 === 0) { // Introduce Ragas and potential key changes
                            const modulationChance = Math.random();
                            const currentKeyIndex = majorKeysCircleOfFifths.indexOf(previousKey);

                            if (modulationChance < 0.4 && currentKeyIndex !== -1) { // 40% chance to modulate to dominant
                                const dominantIndex = (currentKeyIndex + 1) % majorKeysCircleOfFifths.length;
                                newKey = majorKeysCircleOfFifths[dominantIndex];
                                showMessage(`Modulating to ${newKey} Major (Dominant)!`, 2500);
                            } else if (modulationChance < 0.8 && currentKeyIndex !== -1) { // 40% chance to modulate to subdominant
                                const subdominantIndex = (currentKeyIndex - 1 + majorKeysCircleOfFifths.length) % majorKeysCircleOfFifths.length;
                                newKey = majorKeysCircleOfFifths[subdominantIndex];
                                showMessage(`Modulating to ${newKey} Major (Subdominant)!`, 2500);
                            } else { // 20% chance to stay in the same key
                                showMessage(`Staying in ${newKey} Major.`, 2500);
                            }

                            // Use the new Raga selection system
                            const selectedRagaName = selectTimeAppropriateRaga();
                            currentSectionName = `raga${selectedRagaName.charAt(0).toUpperCase() + selectedRagaName.slice(1)}Phrase`; // Format for display
                            
                            const selectedRagaScale = ragaScales[selectedRagaName]; // Get the actual scale array

                            // Safeguard: Ensure selectedRagaScale is a valid, non-empty array
                            if (selectedRagaScale && Array.isArray(selectedRagaScale) && selectedRagaScale.length > 0) {
                                // Transpose the Raga scale from its base (C) to the new key
                                const semitonesToTranspose = keyToSemitoneOffsetFromC[newKey] - keyToSemitoneOffsetFromC['C'];
                                const transposedRagaScale = transposeNotes(selectedRagaScale, semitonesToTranspose);
                                phraseToUse = generateRagaMelody(transposedRagaScale, 8, humanizationFactor);
                            } else {
                                console.error(`Invalid or empty Raga scale found for name: ${selectedRagaName}. Falling back to a default verse.`);
                                currentSectionName = getRandomNormalVerseVariation('verse1'); // Fallback to a known good verse
                                // Transpose the fallback phrase to the new key
                                const semitonesToTranspose = keyToSemitoneOffsetFromC[newKey] - keyToSemitoneOffsetFromC['C']; // Assuming verse1_A is in C
                                phraseToUse = musicalPhrases[currentSectionName].map(step => ({
                                    ...step,
                                    bass: transposeNotes(step.bass, semitonesToTranspose),
                                    synth: transposeNotes(step.synth, semitonesToTranspose)
                                }));
                            }
                        } else { // Normal verse variations, also transposed
                            currentSectionName = getRandomNormalVerseVariation(nextSectionDef.baseName);
                            // Transpose the normal verse to the new key
                            const semitonesToTranspose = keyToSemitoneOffsetFromC[newKey] - keyToSemitoneOffsetFromC['C']; // Assuming base phrases are in C
                            phraseToUse = musicalPhrases[currentSectionName].map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                        }
                    } else { // Non-verse sections use their initialKey from songStructure
                        newKey = nextSectionDef.initialKey || 'C'; // Use initialKey or default to C
                        currentSectionName = nextSectionDef.name || nextSectionDef.type;
                        const semitonesToTranspose = keyToSemitoneOffsetFromC[newKey] - keyToSemitoneOffsetFromC['C'];
                        phraseToUse = musicalPhrases[currentSectionName].map(step => ({
                            ...step,
                            bass: transposeNotes(step.bass, semitonesToTranspose),
                            synth: transposeNotes(step.synth, semitonesToTranspose)
                        }));
                    }
                    
                    currentKey = newKey; // Update global currentKey
                    
                    // Assign the determined/generated phrase to currentSectionPhrase
                    currentSectionPhrase = phraseToUse;

                    // Safeguard: Ensure the phrase is not empty after selection/generation.
                    // If it is, fall back to a known good phrase.
                    if (!currentSectionPhrase || currentSectionPhrase.length === 0) {
                        console.warn(`Section '${currentSectionName}' resulted in an empty phrase. Falling back to intro.`);
                        currentSectionName = 'intro';
                        currentSectionPhrase = musicalPhrases.intro;
                        currentKey = songStructure[0].initialKey || 'A'; // Reset key to intro's key
                        currentSectionTotalSteps = currentSectionPhrase.length * nextSectionDef.durationMultiplier;
                    }

                    // Calculate total steps based on the *final* currentSectionPhrase length
                    currentSectionTotalSteps = currentSectionPhrase.length * nextSectionDef.durationMultiplier;

                    console.log(`Transitioning to section: ${currentSectionName} (type: ${currentSectionType}) in ${currentKey} Major for ${currentSectionTotalSteps} steps. Humanization Factor: ${humanizationFactor.toFixed(2)}`);
                    updateSectionDisplay();
                }
            }

            loopTimeoutId = setTimeout(scheduler, 50);
        }

        /**
         * Starts the music looping. Handles initial audio context setup and resumption.
         */
        function startLoop() {
            console.log("Start button clicked. Attempting to start loop.");
            if (!initAudio()) {
                console.error("Audio initialization failed. Cannot start loop.");
                return;
            }

            if (audioContext.state === 'suspended') {
                console.log("AudioContext is suspended. Attempting to resume...");
                showMessage("Resuming audio context...");
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully!');
                    startLoopInternal();
                }).catch(e => {
                    showMessage("Could not resume audio context. Please try again or check browser settings.", 3000);
                    console.error("AudioContext resume error:", e);
                });
            } else {
                console.log("AudioContext is already running or pending. Starting loop directly.");
                startLoopInternal();
            }
        }

        /**
         * Internal function to start the music loop after audio context is ready.
         */
        function startLoopInternal() {
            if (isPlaying) {
                console.log("Loop is already playing. Skipping start.");
                return;
            }

            isPlaying = true;
            nextNoteTime = audioContext.currentTime;
            
            currentSongSectionIndex = 0;
            const initialSectionDef = songStructure[currentSongSectionIndex];
            currentSectionType = initialSectionDef.type;
            currentKey = initialSectionDef.initialKey || 'C'; // Set initial key

            let initialPhraseToUse = [];

            if (currentSectionType === 'verse') {
                verseIterationCount = 1;
                currentSectionName = initialSectionDef.baseName + '_C'; // Start with a specific verse variation
                // Transpose the initial verse phrase to the initial key
                const semitonesToTranspose = keyToSemitoneOffsetFromC[currentKey] - keyToSemitoneOffsetFromC['C'];
                initialPhraseToUse = musicalPhrases[currentSectionName].map(step => ({
                    ...step,
                    bass: transposeNotes(step.bass, semitonesToTranspose),
                    synth: transposeNotes(step.synth, semitonesToTranspose)
                }));
                console.log(`Forcing initial verse to start with: ${currentSectionName} in ${currentKey} Major`);
            } else {
                currentSectionName = initialSectionDef.name || initialSectionDef.type;
                // Transpose the initial non-verse phrase to its initial key
                const semitonesToTranspose = keyToSemitoneOffsetFromC[currentKey] - keyToSemitoneOffsetFromC['C'];
                initialPhraseToUse = musicalPhrases[currentSectionName].map(step => ({
                    ...step,
                    bass: transposeNotes(step.bass, semitonesToTranspose),
                    synth: transposeNotes(step.synth, semitonesToTranspose)
                }));
            }

            currentSectionPhrase = initialPhraseToUse; // Assign the determined phrase

            shuffleArray(availableRagas);

            currentPhraseIndex = 0;
            stepsPlayedInCurrentSection = 0;
            
            // Calculate total steps based on the assigned currentSectionPhrase length
            currentSectionTotalSteps = currentSectionPhrase.length * initialSectionDef.durationMultiplier;

            // Safeguard for initial phrase if it somehow ends up empty (though unlikely for 'intro')
            if (!currentSectionPhrase || currentSectionPhrase.length === 0) {
                console.warn(`Initial section phrase for '${currentSectionName}' is empty. Falling back to intro.`);
                currentSectionName = 'intro';
                currentSectionPhrase = musicalPhrases.intro;
                currentKey = songStructure[0].initialKey || 'A'; // Reset key to intro's key
                currentSectionTotalSteps = currentSectionPhrase.length * initialSectionDef.durationMultiplier;
            }

            updateSectionDisplay();
            console.log(`Starting with section: ${currentSectionName} (type: ${currentSectionType}) in ${currentKey} Major for ${currentSectionTotalSteps} steps. Humanization Factor: ${humanizationFactor.toFixed(2)}`);

            masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
            masterGainNode.gain.linearRampToValueAtTime(masterVolume, audioContext.currentTime + 4);

            scheduler();
            initializeVisualization(); // Call the visualization function after audio context is running
            
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false; /* Corrected: Enable stop button */
            showMessage("Music started. Enjoy the evolving structured loop!");
            console.log("Music loop started.");
        }

        /**
         * Stops the music looping by clearing the scheduler timeout and suspending the audio context.
         */
        function stopLoop() {
            console.log("Stop button clicked. Attempting to stop loop.");
            isPlaying = false;
            clearTimeout(loopTimeoutId);

            if (audioContext && masterGainNode) {
                masterGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                masterGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
                setTimeout(() => {
                    if (audioContext && audioContext.state === 'running') {
                        audioContext.suspend().then(() => {
                            console.log('AudioContext suspended successfully!');
                            showMessage("Music stopped.");
                        }).catch(e => {
                            showMessage("Could not suspend audio context.", 3000);
                            console.error("AudioContext suspend error:", e);
                        });
                    } else {
                        console.log("AudioContext is not running or already suspended.");
                        showMessage("Music stopped.");
                    }
                }, 1000);
            } else {
                console.log("AudioContext or masterGainNode not available for smooth stop.");
                showMessage("Music stopped.");
            }
            
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            console.log("Music loop stopped.");
        }

        /**
         * The main drawing loop for audio visualization.
         * Draws waveform, frequency bars, and updates the volume meter.
         */
        function initializeVisualization() {
            if (!analyserNode || !audioVisualizerCtx) return;
            
            // Start the drawing loop
            drawVisualizationLoop();
        }

        /**
         * The main drawing loop for audio visualization.
         * Draws waveform, frequency bars, and updates the volume meter.
         */
        function drawVisualizationLoop() {
            if (!isPlaying || !analyserNode || !audioVisualizerCtx) {
                // Clear canvas and reset meters when not playing
                if (audioVisualizerCtx) {
                    audioVisualizerCtx.clearRect(0, 0, audioVisualizerCanvas.width, audioVisualizerCanvas.height);
                }
                if (volumeMeterFillElement) {
                    volumeMeterFillElement.style.width = '0%';
                }
                if (volumePeakElement) {
                    volumePeakElement.style.opacity = 0;
                }
                return;
            }

            requestAnimationFrame(drawVisualizationLoop);

            const width = audioVisualizerCanvas.width;
            const height = audioVisualizerCanvas.height;

            // Get both waveform and frequency data
            analyserNode.getByteTimeDomainData(dataArray);
            analyserNode.getByteFrequencyData(frequencyDataArray);
            
            // Clear canvas
            audioVisualizerCtx.fillStyle = '#000';
            audioVisualizerCtx.fillRect(0, 0, width, height);
            
            // Draw based on visualizationMode
            if (visualizationMode === 'spectrum') {
                // Draw frequency spectrum (bars) with gradient
                const gradient = audioVisualizerCtx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#ff0000'); // Red at the top (highest intensity)
                gradient.addColorStop(0.5, '#ffff00'); // Yellow in the middle
                gradient.addColorStop(1, '#00ff00'); // Green at the bottom (lowest intensity)
                audioVisualizerCtx.fillStyle = gradient;
                
                const barWidth = width / analyserNode.frequencyBinCount; // Adjusted for better distribution
                
                for(let i = 0; i < analyserNode.frequencyBinCount; i++) {
                    const barHeight = (frequencyDataArray[i] / 255) * height;
                    audioVisualizerCtx.fillRect(
                        i * barWidth,
                        height - barHeight,
                        barWidth - 1, // Small gap between bars
                        barHeight
                    );
                }
            } else if (visualizationMode === 'waveform') {
                // Draw waveform overlay
                audioVisualizerCtx.beginPath();
                audioVisualizerCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // Semi-transparent white for waveform
                audioVisualizerCtx.lineWidth = 2;
                
                const sliceWidth = width * 1.0 / dataArray.length;
                let x = 0;
                
                for(let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0; // Normalize to 0-2
                    const y = v * height/2;
                    
                    if(i === 0) {
                        audioVisualizerCtx.moveTo(x, y);
                    } else {
                        audioVisualizerCtx.lineTo(x, y);
                    }
                    x += sliceWidth;
                }
                
                audioVisualizerCtx.lineTo(width, height/2);
                audioVisualizerCtx.stroke();
            } else if (visualizationMode === 'both') {
                // Draw frequency spectrum (bars) with gradient
                const gradient = audioVisualizerCtx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#ff0000'); // Red at the top (highest intensity)
                gradient.addColorStop(0.5, '#ffff00'); // Yellow in the middle
                gradient.addColorStop(1, '#00ff00'); // Green at the bottom (lowest intensity)
                audioVisualizerCtx.fillStyle = gradient;
                
                const barWidth = width / analyserNode.frequencyBinCount;
                
                for(let i = 0; i < analyserNode.frequencyBinCount; i++) {
                    const barHeight = (frequencyDataArray[i] / 255) * height;
                    audioVisualizerCtx.fillRect(
                        i * barWidth,
                        height - barHeight,
                        barWidth - 1,
                        barHeight
                    );
                }

                // Draw waveform overlay
                audioVisualizerCtx.beginPath();
                audioVisualizerCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                audioVisualizerCtx.lineWidth = 2;
                
                const sliceWidth = width * 1.0 / dataArray.length;
                let x = 0;
                
                for(let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * height/2;
                    
                    if(i === 0) {
                        audioVisualizerCtx.moveTo(x, y);
                    } else {
                        audioVisualizerCtx.lineTo(x, y);
                    }
                    x += sliceWidth;
                }
                
                audioVisualizerCtx.lineTo(width, height/2);
                audioVisualizerCtx.stroke();
            } else if (visualizationMode === 'bands') {
                // Draw separate bands for bass, mid, treble
                const nyquist = audioContext.sampleRate / 2;
                const binWidth = nyquist / analyserNode.frequencyBinCount;

                // Define frequency ranges for bands (approximate)
                const bassMaxFreq = 250; // Hz
                const midMaxFreq = 2000; // Hz
                // Treble is everything above midMaxFreq

                // Calculate bin indices for each band
                const bassEndBin = Math.floor(bassMaxFreq / binWidth);
                const midEndBin = Math.floor(midMaxFreq / binWidth);

                let bassEnergy = 0;
                let midEnergy = 0;
                let trebleEnergy = 0;

                // Sum energy for each band
                for (let i = 0; i < analyserNode.frequencyBinCount; i++) {
                    const value = frequencyDataArray[i];
                    if (i <= bassEndBin) {
                        bassEnergy += value;
                    } else if (i <= midEndBin) {
                        midEnergy += value;
                    } else {
                        trebleEnergy += value;
                    }
                }

                // Normalize energy (average value per bin in that band)
                const bassAvg = bassEndBin > 0 ? bassEnergy / bassEndBin : 0;
                const midAvg = (midEndBin - bassEndBin) > 0 ? midEnergy / (midEndBin - bassEndBin) : 0;
                const trebleAvg = (analyserNode.frequencyBinCount - midEndBin) > 0 ? trebleEnergy / (analyserNode.frequencyBinCount - midEndBin) : 0;

                const maxEnergy = 255; // Max value for byte data

                const barWidth = (width / 3) - 5; // 3 bars with some spacing
                const spacing = 5;

                // Draw Bass Bar (Reddish)
                audioVisualizerCtx.fillStyle = `hsl(0, 100%, ${50 + (bassAvg / maxEnergy) * 40}%)`; // Adjust lightness based on intensity
                const bassHeight = (bassAvg / maxEnergy) * height;
                audioVisualizerCtx.fillRect(spacing, height - bassHeight, barWidth, bassHeight);
                audioVisualizerCtx.fillText('Bass', spacing + barWidth / 2 - 15, height - bassHeight - 5);


                // Draw Mid Bar (Greenish)
                audioVisualizerCtx.fillStyle = `hsl(120, 100%, ${50 + (midAvg / maxEnergy) * 40}%)`;
                const midHeight = (midAvg / maxEnergy) * height;
                audioVisualizerCtx.fillRect(spacing * 2 + barWidth, height - midHeight, barWidth, midHeight);
                audioVisualizerCtx.fillText('Mid', spacing * 2 + barWidth / 2 + barWidth - 10, height - midHeight - 5);

                // Draw Treble Bar (Blueish)
                audioVisualizerCtx.fillStyle = `hsl(240, 100%, ${50 + (trebleAvg / maxEnergy) * 40}%)`;
                const trebleHeight = (trebleAvg / maxEnergy) * height;
                audioVisualizerCtx.fillRect(spacing * 3 + barWidth * 2, height - trebleHeight, barWidth, trebleHeight);
                audioVisualizerCtx.fillText('Treble', spacing * 3 + barWidth * 2 + barWidth / 2 - 20, height - trebleHeight - 5);
                
                audioVisualizerCtx.fillStyle = '#e0e0e0'; // Reset text color
                audioVisualizerCtx.font = '10px Arial';
                audioVisualizerCtx.textAlign = 'center';
            }
            
            // Update volume meter
            updateVolumeMeter();
        }

        /**
         * Updates the master volume meter and peak indicator.
         */
        function updateVolumeMeter() {
            if (!analyserNode || !volumeMeterFillElement || !volumePeakElement) return;
            
            // frequencyDataArray is already updated in drawVisualizationLoop
            
            // Calculate RMS volume
            let sum = 0;
            for(let i = 0; i < frequencyDataArray.length; i++) {
                sum += frequencyDataArray[i] * frequencyDataArray[i];
            }
            const rms = Math.sqrt(sum / frequencyDataArray.length);
            const volume = rms / 255; // Normalize to 0-1
            
            // Update meter fill
            volumeMeterFillElement.style.width = `${volume * 100}%`;
            
            // Update peak indicator
            if (volume > peakValue) {
                peakValue = volume;
                volumePeakElement.style.right = `${(1 - peakValue) * 100}%`; // Position from right
                volumePeakElement.style.opacity = '1';
                
                // Clear previous fade-out timeout and set a new one
                clearTimeout(volumePeakElement.fadeTimeout);
                volumePeakElement.fadeTimeout = setTimeout(() => {
                    volumePeakElement.style.opacity = '0.5'; // Fade to 0.5 opacity
                    // Start a slower decay of the peak value itself
                    clearTimeout(volumePeakElement.decayTimeout);
                    volumePeakElement.decayTimeout = setTimeout(() => {
                        peakValue *= 0.95; // Decay peak value
                        if (peakValue < 0.01) peakValue = 0; // Reset if too low
                    }, 500); // Start decaying peak value after it fades slightly
                }, 1000); // Peak indicator fades after 1 second
            }
        }


        /**
         * Manages saving and loading presets to/from local storage.
         */
        class PresetManager {
            constructor() {
                this.storageKeyPrefix = 'simple_relax_preset_'; // Renamed prefix
                this.autoSaveKey = 'simple_relax_autosave_settings'; // Renamed key
            }

            /**
             * Saves the current settings as a preset.
             * @param {string} name - The name of the preset.
             * @param {Object} settings - The settings object to save.
             * @returns {boolean} True if saved successfully, false otherwise.
             */
            savePreset(name, settings) {
                try {
                    const preset = {
                        settings: settings,
                        timestamp: Date.now(),
                        metadata: {
                            author: 'User',
                            description: `Saved at ${new Date().toLocaleString()}`,
                            tags: []
                        }
                    };
                    localStorage.setItem(this.storageKeyPrefix + name, JSON.stringify(preset));
                    return true;
                } catch (e) {
                    console.error('Preset save failed:', e);
                    return false;
                }
            }

            /**
             * Loads a preset by name.
             * @param {string} name - The name of the preset to load.
             * @returns {Object|null} The loaded settings object, or null if not found.
             */
            loadPreset(name) {
                try {
                    const presetString = localStorage.getItem(this.storageKeyPrefix + name);
                    if (presetString) {
                        const preset = JSON.parse(presetString);
                        return preset.settings;
                    }
                    return null;
                } catch (e) {
                    console.error('Preset load failed:', e);
                    return null;
                }
            }

            /**
             * Auto-saves the current settings.
             */
            autoSaveSettings() {
                try {
                    const settings = getCurrentSettings();
                    localStorage.setItem(this.autoSaveKey, JSON.stringify(settings));
                    console.log("Settings auto-saved.");
                } catch (e) {
                    console.warn("Auto-save failed:", e);
                }
            }

            /**
             * Loads auto-saved settings.
             * @returns {Object|null} The auto-saved settings, or null if none exist.
             */
            loadAutoSavedSettings() {
                try {
                    const settingsString = localStorage.getItem(this.autoSaveKey);
                    if (settingsString) {
                        return JSON.parse(settingsString);
                    }
                    return null;
                } catch (e) {
                    console.warn("Failed to load auto-saved settings:", e);
                    return null;
                }
            }

            /**
             * Exports all saved presets to a JSON file.
             */
            exportAllPresets() {
                try {
                    const allPresets = {};
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key.startsWith(this.storageKeyPrefix)) {
                            allPresets[key.replace(this.storageKeyPrefix, '')] = JSON.parse(localStorage.getItem(key));
                        }
                    }
                    const dataStr = JSON.stringify(allPresets, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `simple_relax_presets_${new Date().toISOString().replace(/:/g, '-')}.json`; // Renamed filename
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage("All presets exported successfully!");
                } catch (e) {
                    console.error("Failed to export presets:", e);
                    showMessage("Failed to export presets. See console for details.", 3000);
                }
            }

            /**
             * Imports presets from a JSON file.
             * @param {File} file - The JSON file containing presets.
             */
            importPresets(file) {
                if (!file) {
                    showMessage("No file selected for import.", 2000);
                    return;
                }
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedPresets = JSON.parse(event.target.result);
                        let importedCount = 0;
                        for (const name in importedPresets) {
                            if (importedPresets.hasOwnProperty(name) && importedPresets[name].settings) {
                                // Ensure the imported preset has a 'settings' property
                                if (this.savePreset(name, importedPresets[name].settings)) {
                                    importedCount++;
                                }
                            }
                        }
                        showMessage(`Successfully imported ${importedCount} presets!`);
                    } catch (e) {
                        console.error("Failed to parse imported presets file:", e);
                        showMessage("Failed to import presets. Invalid file format.", 3000);
                    }
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e);
                    showMessage("Error reading file. Please try again.", 3000);
                };
                reader.readAsText(file);
            }
        }

        const presetManager = new PresetManager();

        /**
         * Collects all current knob values into an object.
         * @returns {Object} An object containing all current settings.
         */
        function getCurrentSettings() {
            return {
                masterVolume: parseFloat(document.getElementById('masterVolume').value),
                tempo: parseFloat(document.getElementById('tempo').value),
                bassVolume: parseFloat(document.getElementById('bassVolume').value),
                synthVolume: parseFloat(document.getElementById('synthVolume').value),
                kickVolume: parseFloat(document.getElementById('kickVolume').value),
                snareVolume: parseFloat(document.getElementById('snareVolume').value),
                hihatVolume: parseFloat(document.getElementById('hihatVolume').value),
                delayTime: parseFloat(document.getElementById('delayTime').value),
                delayFeedback: parseFloat(document.getElementById('delayFeedback').value),
                delaySendLevel: parseFloat(document.getElementById('delaySendLevel').value),
                chorusDepth: parseFloat(document.getElementById('chorusDepth').value),
                isChorusBypassed: document.getElementById('chorusBypass').checked,
                currentDetune: currentDetune,
                currentFilterFrequency: currentFilterFrequency,
                currentFilterQ: currentFilterQ,
                baseNoteDuration: baseNoteDuration,
                humanizationFactor: humanizationFactor,
                // New: Compressor settings
                compThreshold: parseFloat(document.getElementById('compThreshold').value),
                compRatio: parseFloat(document.getElementById('compRatio').value),
                // New: Reverb settings
                reverbMix: parseFloat(document.getElementById('reverbMix').value),
                isReverbBypassed: document.getElementById('reverbBypass').checked
            };
        }

        /**
         * Applies saved settings to the knobs and global variables.
         * @param {Object} settings - An object containing settings to apply.
         */
        function applySettings(settings) {
            // Apply settings to UI elements and trigger their input events to update audio parameters
            document.getElementById('masterVolume').value = settings.masterVolume;
            document.getElementById('masterVolume').dispatchEvent(new Event('input'));

            document.getElementById('tempo').value = settings.tempo;
            document.getElementById('tempo').dispatchEvent(new Event('input'));

            document.getElementById('bassVolume').value = settings.bassVolume;
            document.getElementById('bassVolume').dispatchEvent(new Event('input'));

            document.getElementById('synthVolume').value = settings.synthVolume;
            document.getElementById('synthVolume').dispatchEvent(new Event('input'));

            document.getElementById('kickVolume').value = settings.kickVolume;
            document.getElementById('kickVolume').dispatchEvent(new Event('input'));

            document.getElementById('snareVolume').value = settings.snareVolume;
            document.getElementById('snareVolume').dispatchEvent(new Event('input'));

            document.getElementById('hihatVolume').value = settings.hihatVolume;
            document.getElementById('hihatVolume').dispatchEvent(new Event('input'));

            document.getElementById('delayTime').value = settings.delayTime;
            document.getElementById('delayTime').dispatchEvent(new Event('input'));

            document.getElementById('delayFeedback').value = settings.delayFeedback;
            document.getElementById('delayFeedback').dispatchEvent(new Event('input'));

            document.getElementById('delaySendLevel').value = settings.delaySendLevel;
            document.getElementById('delaySendLevel').dispatchEvent(new Event('input'));

            document.getElementById('chorusDepth').value = settings.chorusDepth;
            document.getElementById('chorusDepth').dispatchEvent(new Event('input'));
            
            document.getElementById('chorusBypass').checked = settings.isChorusBypassed;
            document.getElementById('chorusBypass').dispatchEvent(new Event('change')); // Trigger change event

            document.getElementById('compThreshold').value = settings.compThreshold;
            document.getElementById('compThreshold').dispatchEvent(new Event('input'));

            document.getElementById('compRatio').value = settings.compRatio;
            document.getElementById('compRatio').dispatchEvent(new Event('input'));
            
            document.getElementById('reverbMix').value = settings.reverbMix;
            document.getElementById('reverbMix').dispatchEvent(new Event('input'));

            document.getElementById('reverbBypass').checked = settings.isReverbBypassed;
            document.getElementById('reverbBypass').dispatchEvent(new Event('change')); // Trigger change event

            // Update global variables that are not directly tied to a knob
            currentDetune = settings.currentDetune;
            currentFilterFrequency = settings.currentFilterFrequency;
            currentFilterQ = settings.currentFilterQ;
            baseNoteDuration = settings.baseNoteDuration;
            humanizationFactor = settings.humanizationFactor;

            showMessage("Preset loaded successfully!");
            console.log("Settings applied:", settings);
        }

        /**
         * Saves the current knob settings to local storage using PresetManager.
         */
        function savePreset() {
            const presetNameInput = document.getElementById('presetNameInput');
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                showMessage("Please enter a name for your preset.", 2000);
                return;
            }
            const settings = getCurrentSettings();
            if (presetManager.savePreset(presetName, settings)) {
                showMessage(`Preset "${presetName}" saved!`);
                console.log(`Preset "${presetName}" saved:`, settings);
            } else {
                showMessage("Failed to save preset. Local storage might be full or unavailable.", 3000);
            }
        }

        /**
         * Loads a preset from local storage and applies its settings using PresetManager.
         */
        function loadPreset() {
            const presetNameInput = document.getElementById('presetNameInput');
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                showMessage("Please enter the name of the preset to load.", 2000);
                return;
            }
            const settings = presetManager.loadPreset(presetName);
            if (settings) {
                applySettings(settings);
            } else {
                showMessage(`Preset "${presetName}" not found.`, 2000);
                console.warn(`Preset "${presetName}" not found.`);
            }
        }

        /**
         * Updates the audio graph connection for chorus bypass.
         */
        function updateChorusBypassConnection() {
            if (!audioContext || !masterGainNode || !analyserNode || !chorusNode || !compressorNode) return;

            // Disconnect masterGainNode from compressor (its direct connection)
            try {
                masterGainNode.disconnect(compressorNode);
            } catch (e) { /* ignore */ }
            // Disconnect chorusNode from compressor if it was connected
            try {
                chorusNode.disconnect(compressorNode);
            } catch (e) { /* ignore */ }

            // Reconnect masterGainNode to chorus or compressor based on bypass state
            if (isChorusBypassed) {
                masterGainNode.connect(compressorNode);
            } else {
                masterGainNode.connect(chorusNode);
                chorusNode.connect(compressorNode); // Chorus output connects to compressor
            }
        }

        /**
         * Updates the audio graph connection for reverb bypass.
         */
        function updateReverbBypassConnection() {
            if (!audioContext || !compressorNode || !analyserNode || !convolverNode || !reverbGainNode || !dryGainNode) return;

            // Disconnect all previous connections from compressor to dry/wet paths
            try {
                compressorNode.disconnect(dryGainNode);
                compressorNode.disconnect(convolverNode);
            } catch (e) { /* ignore */ }
            
            // Disconnect dry/wet paths from analyser
            try {
                dryGainNode.disconnect(analyserNode);
                reverbGainNode.disconnect(analyserNode);
            } catch (e) { /* ignore */ }

            if (isReverbBypassed) {
                // If bypassed, connect compressor directly to analyser
                compressorNode.connect(analyserNode);
            } else {
                // If active, connect compressor to dry and wet paths
                compressorNode.connect(dryGainNode);
                dryGainNode.connect(analyserNode);

                compressorNode.connect(convolverNode);
                convolverNode.connect(reverbGainNode);
                reverbGainNode.connect(analyserNode);
            }
            // Analyser always connects to destination, ensure this path is maintained
            analyserNode.connect(audioContext.destination);
        }

        /**
         * Updates the audio parameter based on the knob ID.
         * This centralizes the logic for knob interactions.
         * @param {string} id - The ID of the knob.
         * @param {number} value - The new value of the knob.
         */
        function updateAudioParameter(id, value) {
            switch (id) {
                case 'masterVolume':
                    masterVolume = value;
                    if (audioContext && masterGainNode) masterGainNode.gain.setValueAtTime(masterVolume, audioContext.currentTime);
                    break;
                case 'tempo':
                    currentTempo = value;
                    break;
                case 'bassVolume':
                    bassVolume = value;
                    break;
                case 'synthVolume':
                    synthVolume = value;
                    break;
                case 'kickVolume':
                    kickVolume = value;
                    break;
                case 'snareVolume':
                    snareVolume = value;
                    break;
                case 'hihatVolume':
                    hihatVolume = value;
                    break;
                case 'delayTime':
                    delayTimeValue = value;
                    if (audioContext && delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, audioContext.currentTime);
                    break;
                case 'delayFeedback':
                    delayFeedbackValue = value;
                    if (audioContext && delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, audioContext.currentTime);
                    break;
                case 'delaySendLevel':
                    delaySendLevel = value;
                    break;
                case 'chorusDepth':
                    chorusDepth = value;
                    if (audioContext && chorusLfoGain) chorusLfoGain.gain.setValueAtTime(chorusDepth, audioContext.currentTime);
                    break;
                case 'compThreshold':
                    compThreshold = value;
                    if (audioContext && compressorNode) compressorNode.threshold.setValueAtTime(compThreshold, audioContext.currentTime);
                    break;
                case 'compRatio':
                    compRatio = value;
                    if (audioContext && compressorNode) compressorNode.ratio.setValueAtTime(compRatio, audioContext.currentTime);
                    break;
                case 'reverbMix':
                    reverbMix = value;
                    if (audioContext && reverbGainNode && dryGainNode) {
                        reverbGainNode.gain.setValueAtTime(reverbMix, audioContext.currentTime);
                        dryGainNode.gain.setValueAtTime(1 - reverbMix, audioContext.currentTime);
                    }
                    break;
            }
            // Update the display value for the knob
            const valueSpan = document.getElementById(`${id}Value`);
            if (valueSpan) {
                let displayValue = value;
                if (id === 'compThreshold') {
                    displayValue = `${value.toFixed(0)} dB`;
                } else if (id === 'compRatio') {
                    displayValue = `${value.toFixed(1)}:1`;
                } else if (id === 'reverbMix') {
                    displayValue = `${(value * 100).toFixed(0)}%`;
                } else if (id === 'chorusDepth') {
                    displayValue = value.toFixed(4);
                }
                else {
                    displayValue = value.toFixed(2);
                }
                valueSpan.textContent = displayValue;
            }
        }


        // Enhanced LooperRecorder Class
        class EnhancedLooperRecorder {
            constructor(audioContext) {
                this.audioContext = audioContext;
                this.mediaRecorder = null;
                this.chunks = [];
                this.isRecording = false;
                this.recordingStartTime = 0;
                // Ensure this selector matches the HTML element
                this.recordingMeter = document.querySelector('.recording-meter');
                this.recordingFormatSelect = document.getElementById('recordingFormat');
                this.selectedFormat = this.recordingFormatSelect ? this.recordingFormatSelect.value : 'wav';
                
                // Initialize if we have access to MediaRecorder
                if (typeof MediaRecorder !== 'undefined') {
                    this.initializeRecorder();
                } else {
                    showMessage('MediaRecorder is not supported in this browser. Recording feature unavailable.', 5000);
                    console.warn('MediaRecorder is not supported.');
                }

                if (this.recordingFormatSelect) {
                    this.recordingFormatSelect.addEventListener('change', (e) => {
                        this.selectedFormat = e.target.value;
                        if (this.selectedFormat === 'mp3') {
                            showMessage('MP3 recording is not natively supported in browsers and requires external libraries or server-side processing.', 5000);
                        }
                    });
                }
            }
            
            async initializeRecorder() {
                // Check if analyserNode exists before connecting
                if (!analyserNode) {
                    console.error("AnalyserNode not available for recording initialization.");
                    showMessage("Audio system not ready for recording. Please start music first.", 3000);
                    return;
                }

                const dest = this.audioContext.createMediaStreamDestination();
                // Connect the analyserNode to the recording destination
                // Important: Ensure analyserNode is connected to the audio graph before this,
                // and that its output is also going to the main audio destination.
                analyserNode.connect(dest);
                
                try {
                    this.mediaRecorder = new MediaRecorder(dest.stream);
                    this.mediaRecorder.ondataavailable = e => this.chunks.push(e.data);
                    this.mediaRecorder.onstop = () => this.processRecording();
                } catch (err) {
                    console.error('Failed to initialize MediaRecorder:', err);
                    showMessage('Recording initialization failed. Please try a different browser or check permissions.');
                }
            }
            
            startRecording() {
                if (!this.mediaRecorder) {
                    showMessage("Recording system not ready. Please try again.", 3000);
                    return;
                }
                if (this.isRecording) {
                    showMessage("Already recording!", 2000);
                    return;
                }
                if (this.selectedFormat === 'mp3') {
                    showMessage('MP3 recording is not natively supported. Recording in WAV format.', 4000);
                    // Fallback to WAV if MP3 is selected
                    this.selectedFormat = 'wav'; 
                }

                this.chunks = [];
                this.recordingStartTime = Date.now();
                this.isRecording = true;
                
                if (this.recordingMeter) {
                    this.recordingMeter.classList.add('active');
                }

                let countdown = 3;
                const countdownInterval = setInterval(() => {
                    if (this.recordingMeter) {
                        this.recordingMeter.textContent = `Recording starts in: ${countdown}s`;
                    }
                    countdown--;
                    if (countdown < 0) {
                        clearInterval(countdownInterval);
                        this.mediaRecorder.start();
                        this.updateRecordingTime();
                        showMessage('Recording started!');
                        console.log("Recording started.");
                    }
                }, 1000);
            }
            
            stopRecording() {
                if (!this.isRecording) {
                    showMessage("Not currently recording.", 2000);
                    return;
                }
                
                this.mediaRecorder.stop();
                this.isRecording = false;
                if (this.recordingMeter) {
                    this.recordingMeter.classList.remove('active');
                    this.recordingMeter.textContent = ''; // Clear text
                }
                
                showMessage('Recording stopped. Preparing download...');
                console.log("Recording stopped.");
            }
            
            updateRecordingTime() {
                if (!this.isRecording || !this.recordingMeter) return;
                
                const duration = (Date.now() - this.recordingStartTime) / 1000;
                this.recordingMeter.textContent = `Recording: ${duration.toFixed(1)}s`;
                requestAnimationFrame(() => this.updateRecordingTime());
            }
            
            async processRecording() {
                const mimeType = this.selectedFormat === 'wav' ? 'audio/wav' : 'audio/webm'; // Default to webm if not wav, though we only support wav for now
                const blob = new Blob(this.chunks, { type: mimeType }); 
                const url = URL.createObjectURL(blob);
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `simple_relax_loop_${new Date().toISOString().replace(/:/g, '-')}.${this.selectedFormat}`; // Renamed filename
                document.body.appendChild(a); // Append to body to make it clickable
                a.click();
                document.body.removeChild(a); // Clean up
                
                URL.revokeObjectURL(url); // Release object URL
                showMessage("Recording downloaded!", 3000);
                console.log("Recording download initiated.");
            }
        }

        // Add Recording Controls to UI
        function addRecordingControls() {
            const recordButton = document.getElementById('recordButton');
            const stopButton = document.getElementById('stopButton'); // Get stop button reference
            const startButton = document.getElementById('startButton'); // Get start button reference

            if (recordButton) {
                recordButton.addEventListener('click', () => {
                    // Ensure audioContext is initialized before interacting with recorder
                    if (!audioContext) {
                        showMessage("Please start the music loop first to initialize audio.", 3000);
                        return;
                    }
                    
                    // The looperRecorder is initialized in initAudio, so it should exist here.
                    // If it somehow doesn't, initialize it now.
                    if (!looperRecorder) {
                        looperRecorder = new EnhancedLooperRecorder(audioContext);
                    }

                    if (looperRecorder.isRecording) {
                        looperRecorder.stopRecording();
                        recordButton.textContent = 'Start Recording';
                        // Re-enable start/stop if needed, or handle based on main loop state
                        if (!isPlaying) {
                            startButton.disabled = false;
                            stopButton.disabled = true;
                        }
                    } else {
                        looperRecorder.startRecording();
                        recordButton.textContent = 'Stop Recording';
                    }
                });
            }
        }

        // Keyboard Controls Initialization
        function initializeKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                // Only handle shortcuts if not typing in an input
                if (e.target.tagName === 'INPUT') return;
                
                const startButton = document.getElementById('startButton');
                const stopButton = document.getElementById('stopButton');
                const recordButton = document.getElementById('recordButton'); // Get record button
                const chorusBypassCheckbox = document.getElementById('chorusBypass');
                const reverbBypassCheckbox = document.getElementById('reverbBypass');


                switch(e.code) {
                    case 'Space':
                    case 'Enter': // Add Enter as transport control
                        e.preventDefault(); // Prevent default spacebar/enter action (e.g., scrolling, submitting forms)
                        if (isPlaying) {
                            stopButton.click();
                        } else {
                            startButton.click();
                        }
                        break;
                    case 'KeyR':
                        if (e.ctrlKey) { // Ctrl+R for recording
                            e.preventDefault();
                            recordButton.click();
                        } else { // R key alone for Reverb bypass
                             e.preventDefault();
                             reverbBypassCheckbox.checked = !reverbBypassCheckbox.checked;
                             reverbBypassCheckbox.dispatchEvent(new Event('change'));
                        }
                        break;
                    case 'KeyC': // C key for Chorus bypass
                        e.preventDefault();
                        chorusBypassCheckbox.checked = !chorusBypassCheckbox.checked;
                        chorusBypassCheckbox.dispatchEvent(new Event('change'));
                        break;
                    case 'KeyM':
                        // Master volume mute/unmute
                        const volKnob = document.getElementById('masterVolume');
                        if (volKnob) {
                            if (parseFloat(volKnob.value) > 0) {
                                volKnob.dataset.lastValue = volKnob.value; // Store current value
                                volKnob.value = 0;
                            } else {
                                volKnob.value = volKnob.dataset.lastValue || 0.55; // Restore or default
                            }
                            volKnob.dispatchEvent(new Event('input')); // Trigger input event to update UI and audio
                            showMessage(`Master Volume: ${parseFloat(volKnob.value) === 0 ? 'Muted' : 'Unmuted'}`, 1500);
                        }
                        break;
                    case 'ArrowUp':
                    case 'ArrowDown':
                        // Parameter fine-tuning for all range inputs
                        if (e.target.tagName === 'INPUT' && e.target.type === 'range') {
                            e.preventDefault(); // Prevent default scrolling
                            const knob = e.target;
                            const step = e.shiftKey ? parseFloat(knob.step) : (knob.id === 'tempo' ? 10 : 0.01); // Smaller step for fine-tuning
                            const direction = e.code === 'ArrowUp' ? 1 : -1;
                            let newValue = parseFloat(knob.value) + (direction * step);

                            // Clamp value to min/max
                            newValue = Math.min(parseFloat(knob.max), Math.max(parseFloat(knob.min), newValue));
                            knob.value = newValue;
                            knob.dispatchEvent(new Event('input')); // Trigger input event to update UI and audio
                            showMessage(`${knob.labels[0].textContent}: ${knob.nextElementSibling.textContent}`, 1000);
                        } else {
                            // Default behavior for tempo if no specific knob is focused
                            const tempoKnob = document.getElementById('tempo');
                            if (tempoKnob) {
                                e.preventDefault(); // Prevent default scrolling
                                const step = e.shiftKey ? 1 : 10;
                                const direction = e.code === 'ArrowUp' ? 1 : -1;
                                tempoKnob.value = Math.min(parseFloat(tempoKnob.max), Math.max(parseFloat(tempoKnob.min), parseInt(tempoKnob.value) + (direction * step)));
                                tempoKnob.dispatchEvent(new Event('input')); // Trigger input event to update UI and audio
                                showMessage(`Tempo: ${tempoKnob.value} ms`, 1000);
                            }
                        }
                        break;
                    // Quick preset loading (1-9)
                    case 'Digit1':
                    case 'Digit2':
                    case 'Digit3':
                    case 'Digit4':
                    case 'Digit5':
                    case 'Digit6':
                    case 'Digit7':
                    case 'Digit8':
                    case 'Digit9':
                        e.preventDefault();
                        const presetNumber = parseInt(e.key);
                        const presetName = `Preset ${presetNumber}`;
                        document.getElementById('presetNameInput').value = presetName;
                        loadPreset(); // Call the existing loadPreset function
                        break;
                }
            });
        }

        // Add event listeners once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Attaching event listeners.");
            document.getElementById('startButton').addEventListener('click', startLoop);
            document.getElementById('stopButton').addEventListener('click', stopLoop);
            document.getElementById('savePresetButton').addEventListener('click', savePreset);
            document.getElementById('loadPresetButton').addEventListener('click', loadPreset);
            document.getElementById('exportPresetsButton').addEventListener('click', () => presetManager.exportAllPresets());
            document.getElementById('importPresetsButton').addEventListener('click', () => document.getElementById('importPresetsInput').click());
            document.getElementById('importPresetsInput').addEventListener('change', (event) => {
                if (event.target.files.length > 0) {
                    presetManager.importPresets(event.target.files[0]);
                }
            });
            
            // Add event listeners for all range input knobs
            document.querySelectorAll('input[type="range"]').forEach(knob => {
                knob.addEventListener('input', (e) => {
                    updateAudioParameter(e.target.id, parseFloat(e.target.value));
                });
            });

            // Add checkbox event listeners
            document.getElementById('chorusBypass').addEventListener('change', (event) => {
                isChorusBypassed = event.target.checked;
                updateChorusBypassConnection();
                showMessage(`Chorus is now ${isChorusBypassed ? 'bypassed' : 'active'}.`);
            });

            document.getElementById('reverbBypass').addEventListener('change', (event) => {
                isReverbBypassed = event.target.checked;
                updateReverbBypassConnection();
                showMessage(`Reverb is now ${isReverbBypassed ? 'bypassed' : 'active'}.`);
            });

            // Visualization mode buttons
            document.getElementById('visModeSpectrum').addEventListener('click', () => {
                visualizationMode = 'spectrum';
                document.getElementById('visModeSpectrum').classList.add('active');
                document.getElementById('visModeWaveform').classList.remove('active');
                document.getElementById('visModeBoth').classList.remove('active');
                document.getElementById('visModeBands').classList.remove('active');
                showMessage('Visualization: Spectrum');
            });
            document.getElementById('visModeWaveform').addEventListener('click', () => {
                visualizationMode = 'waveform';
                document.getElementById('visModeSpectrum').classList.remove('active');
                document.getElementById('visModeWaveform').classList.add('active');
                document.getElementById('visModeBoth').classList.remove('active');
                document.getElementById('visModeBands').classList.remove('active');
                showMessage('Visualization: Waveform');
            });
            document.getElementById('visModeBoth').addEventListener('click', () => {
                visualizationMode = 'both';
                document.getElementById('visModeSpectrum').classList.remove('active');
                document.getElementById('visModeWaveform').classList.remove('active');
                document.getElementById('visModeBoth').classList.add('active');
                document.getElementById('visModeBands').classList.remove('active');
                showMessage('Visualization: Both');
            });
            document.getElementById('visModeBands').addEventListener('click', () => {
                visualizationMode = 'bands';
                document.getElementById('visModeSpectrum').classList.remove('active');
                document.getElementById('visModeWaveform').classList.remove('active');
                document.getElementById('visModeBoth').classList.remove('active');
                document.getElementById('visModeBands').classList.add('active');
                showMessage('Visualization: Frequency Bands');
            });


            // Initial display update for all knobs
            document.querySelectorAll('input[type="range"]').forEach(knob => {
                // Manually trigger the update to set initial display values
                // and ensure global variables are in sync if not already
                updateAudioParameter(knob.id, parseFloat(knob.value));
            });

            updateSectionDisplay();

            // Initialize keyboard controls
            initializeKeyboardControls();
            
            // Add recording controls (looperRecorder is initialized in initAudio)
            addRecordingControls();

            // Auto-load settings on page load
            const autoSavedSettings = presetManager.loadAutoSavedSettings();
            if (autoSavedSettings) {
                applySettings(autoSavedSettings);
                showMessage("Auto-saved settings loaded.", 2000);
            }

            // Auto-save settings before page unload
            window.addEventListener('beforeunload', () => {
                presetManager.autoSaveSettings();
            });
        });
    </script>
</body>
</html>
