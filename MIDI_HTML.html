<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Relax Looper</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Apply Inter font and basic styling to the body */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background: radial-gradient(circle at top left, #2a2a2a, #1a1a1a 70%);
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px;
            flex-wrap: wrap;
        }

        /* Central content container */
        .central-content {
            flex: 1;
            min-width: 320px;
            background-color: #2a2a2a;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4), inset 0 0 10px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 25px;
            border: 1px solid rgba(144, 238, 144, 0.1);
            max-width: 600px; /* Limit width for central content */
        }

        /* Styling for the main heading */
        h1 {
            color: #90ee90;
            margin-bottom: 10px;
            font-size: 2.8em;
            text-shadow: 0 0 12px rgba(144, 238, 144, 0.7);
            font-weight: 700;
        }
        /* Styling for subheadings in knob sections (now in modals) */
        h3 {
            color: #a0ffa0;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.4em;
            font-weight: 600;
            border-bottom: 1px solid rgba(144, 238, 144, 0.3);
            padding-bottom: 10px;
        }

        /* Base button styling */
        button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2em;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            outline: none;
            font-weight: 600;
            color: white;
        }
        /* Primary button style (Start/Stop) - SMALLER */
        button.primary {
            background-color: #4CAF50;
            padding: 10px 20px; /* Smaller padding */
            font-size: 1em; /* Smaller font size */
        }
        button.primary:hover {
            background-color: #45a049;
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        button.primary:active {
            background-color: #3e8e41;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Secondary button style (Presets, Record, Vis Modes, Open Modals) */
        button.secondary {
            background-color: #555;
            border: 1px solid #777;
            padding: 12px 25px; /* Slightly adjusted padding for other buttons */
            font-size: 1.1em;
        }
        button.secondary:hover {
            background-color: #666;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        button.secondary:active {
            background-color: #444;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Styling for disabled buttons */
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        /* Custom message box (Toast Notification Style) */
        .message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #3a3a3a;
            color: #fff;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border: 1px solid #4CAF50;
            font-size: 1em;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out, transform 0.3s ease-in-out;
            z-index: 1000;
            min-width: 200px;
            text-align: center;
        }
        .message-box.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-10px);
        }

        /* Styling for paragraph text */
        p {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
            color: #ccc;
        }
        /* Styling for current section display */
        #currentSectionDisplay {
            margin-top: 15px;
            font-size: 1.4em;
            color: #a0ffa0;
            font-weight: bold;
            transition: color 0.3s ease;
        }
        /* Highlight for current section */
        #currentSectionDisplay.highlight {
            color: #ffcc00;
            text-shadow: 0 0 8px rgba(255, 204, 0, 0.6);
        }
        /* Flex container for control buttons */
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Styling for knob sections (now used inside modals) */
        .knob-section {
            background-color: #3a3a3a;
            padding: 20px;
            border-radius: 12px;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.2);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            border: 1px solid rgba(144, 238, 144, 0.05);
        }
        .knob-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            position: relative;
            padding: 10px;
            border-radius: 8px;
            background-color: #444;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .knob-group label {
            font-size: 1em;
            color: #ccc;
            font-weight: 500;
            text-align: center;
        }
        .knob-group input[type="range"] {
            width: 100%;
            max-width: 150px;
            -webkit-appearance: none;
            appearance: none;
            height: 10px;
            background: #555;
            outline: none;
            border-radius: 5px;
            transition: background 0.2s;
            background-image: linear-gradient(#90ee90, #90ee90);
            background-size: var(--fill-percentage, 0%) 100%;
            background-repeat: no-repeat;
        }
        .knob-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #90ee90;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(144, 238, 144, 0.7);
            border: 2px solid #1a1a1a;
            transition: background 0.2s, box-shadow 0.2s;
        }
        .knob-group input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #90ee90;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(144, 238, 144, 0.7);
            border: 2px solid #1a1a1a;
            transition: background 0.2s, box-shadow 0.2s;
        }
        .knob-group input[type="range"]:focus {
            box-shadow: 0 0 0 3px rgba(144, 238, 144, 0.5);
        }
        .knob-group input[type="range"]:active::-webkit-slider-thumb,
        .knob-group input[type="range"]:active::-moz-range-thumb {
            background: #a0ffa0;
            box-shadow: 0 0 12px rgba(160, 255, 160, 0.9);
        }

        .knob-value {
            font-size: 1.1em;
            color: #a0ffa0;
            font-weight: 700;
            margin-top: 5px;
        }
        .knob-group select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            width: 100%;
            max-width: 150px;
            text-align: center;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23e0e0e0%22%20d%3D%22M287%2C197.3L159.9%2C69.8c-4.4-4.3-11.4-4.3-15.8%2C0L5.1%2C197.3c-4.4%2C4.3-4.4%2C11.3%2C0%2C15.6l15.8%2C15.6c4.4%2C4.3%2C11.4%2C4.3%2C15.8%2C0L146%2C106.6c4.4-4.3%2C11.4-4.3%2C15.8%2C0l110.2%2C110.2c4.4%2C4.3%2C11.4%2C4.3%2C15.8%2C0l15.8-15.6C291.3%2C208.6%2C291.3%2C201.6%2C287%2C197.3z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 8px top 50%;
            background-size: 12px auto;
            transition: box-shadow 0.2s;
        }
        .knob-group select:focus {
            box-shadow: 0 0 0 3px rgba(144, 238, 144, 0.5);
        }

        /* Audio Visualizer */
        #audioVisualizer {
            background-color: #000;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            margin-top: 25px;
            width: 100%;
            max-width: 450px;
            height: 120px;
            box-shadow: 0 0 15px rgba(144, 238, 144, 0.5);
        }

        /* Volume Meter */
        .volume-meter-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 20px;
            gap: 12px;
            background-color: #3a3a3a;
            padding: 15px;
            border-radius: 10px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(144, 238, 144, 0.05);
        }
        .volume-meter-label {
            font-size: 1em;
            color: #ccc;
            font-weight: 500;
        }
        #volumeMeter {
            width: 180px;
            height: 18px;
            background-color: #555;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #4CAF50;
            position: relative;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }
        #volumeMeterFill {
            height: 100%;
            width: 0%;
            background-color: #90ee90;
            transition: width 0.05s ease-out;
            box-shadow: 0 0 8px rgba(144, 238, 144, 0.5);
        }
        #volumePeak {
            position: absolute;
            height: 100%;
            width: 3px;
            background-color: #ff0000;
            right: 0;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }

        /* Preset controls */
        .preset-controls {
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            background-color: #3a3a3a;
            padding: 20px;
            border-radius: 12px;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(144, 238, 144, 0.05);
        }
        .preset-controls input[type="text"] {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            width: 90%;
            max-width: 250px;
            font-size: 1em;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
            transition: box-shadow 0.2s;
        }
        .preset-controls input[type="text"]:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(144, 238, 144, 0.5);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            color: #ccc;
            font-size: 1em;
        }
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #90ee90;
            cursor: pointer;
        }

        /* Recording Meter Style */
        .recording-meter {
            background-color: #ff4d4d;
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 1em;
            display: none;
            animation: pulse 1s infinite alternate;
            font-weight: 600;
            box-shadow: 0 0 10px rgba(255, 77, 77, 0.6);
            border: 1px solid #ff0000;
        }

        .recording-meter.active {
            display: block;
        }

        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.7; }
        }

        /* Visualization Mode Controls */
        .visualization-controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .visualization-controls button {
            padding: 10px 18px;
            font-size: 0.95em;
            background-color: #555;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .visualization-controls button.active {
            background-color: #90ee90;
            color: #1a1a1a;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(144, 238, 144, 0.6);
        }

        /* Recording Format Dropdown */
        .recording-format-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
        }
        .recording-format-control label {
            font-size: 1em;
            color: #ccc;
            font-weight: 500;
        }
        .recording-format-control select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            width: 160px;
            text-align: center;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23e0e0e0%22%20d%3D%22M287%2C197.3L159.9%2C69.8c-4.4-4.3-11.4-4.3-15.8%2C0L5.1%2C197.3c-4.4%2C4.3-4.4%2C11.3%2C0%2C15.6l15.8%2C15.6c4.4%2C4.3%2C11.4%2C4.3%2C15.8%2C0L146%2C106.6c4.4-4.3%2C11.4-4.3%2C15.8%2C0l110.2%2C110.2c4.4%2C4.3%2C11.4%2C4.3%2C15.8%2C0l15.8-15.6C291.3%2C208.6%2C291.3%2C201.6%2C287%2C197.3z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 8px top 50%;
            background-size: 12px auto;
        }

        /* MODAL STYLES */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
            /* display: flex;  Removed from here, added by JS when opened */
            justify-content: center;
            align-items: center;
            padding: 20px; /* Padding around the modal content */
            box-sizing: border-box;
        }

        .modal-content {
            background-color: #2a2a2a;
            margin: auto;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(144, 238, 144, 0.2);
            max-width: 500px; /* Max width for modal content */
            width: 90%; /* Responsive width */
            position: relative; /* For close button positioning */
            display: flex;
            flex-direction: column;
            gap: 20px;
            animation: fadeInScale 0.3s ease-out; /* Simple animation */
            max-height: 90vh; /* Limit height to prevent overflow on small screens */
            overflow-y: auto; /* Enable scrolling within modal if content is too long */
        }

        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .close-button {
            color: #aaa;
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-button:hover,
        .close-button:focus {
            color: #90ee90;
            text-decoration: none;
            cursor: pointer;
        }

        /* Container for modal trigger buttons */
        .modal-trigger-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); /* Responsive grid for icons */
            gap: 15px;
            margin-top: 25px;
            padding: 20px;
            background-color: #3a3a3a;
            border-radius: 12px;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(144, 238, 144, 0.05);
        }
        .modal-trigger-buttons button {
            width: 100%; /* Make buttons fill grid column */
            padding: 10px; /* Smaller padding for icon buttons */
            font-size: 1.5em; /* Larger icon size */
            height: 60px; /* Fixed height for consistent look */
            flex-direction: column; /* Stack icon and text if needed, though only icon here */
            gap: 5px;
        }
        .modal-trigger-buttons button span {
            font-size: 0.5em; /* Smaller text for labels under icons */
            font-weight: normal;
            margin-top: 2px;
        }


        /* Responsive adjustments for mobile */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .central-content {
                width: 100%;
                padding: 15px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), inset 0 0 5px rgba(0, 0, 0, 0.1);
            }
            h1 {
                font-size: 2em;
                margin-bottom: 5px;
            }
            h3 {
                font-size: 1.2em;
                margin-bottom: 10px;
                padding-bottom: 8px;
            }
            p {
                font-size: 1em;
                margin-bottom: 10px;
            }
            button.primary {
                padding: 8px 15px; /* Even smaller for mobile */
                font-size: 0.9em;
            }
            button.secondary {
                padding: 10px 18px;
                font-size: 0.95em;
            }
            .controls {
                gap: 10px;
            }
            .knob-section {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 10px;
                padding: 15px;
            }
            .knob-group {
                padding: 8px;
                gap: 5px;
            }
            .knob-group label {
                font-size: 0.9em;
            }
            .knob-value {
                font-size: 1em;
            }
            .knob-group input[type="range"],
            .knob-group select {
                max-width: 100%;
            }
            #audioVisualizer {
                width: 100%;
                max-width: none;
                height: 100px;
                margin-top: 15px;
            }
            .volume-meter-container {
                padding: 10px;
                gap: 8px;
            }
            #volumeMeter {
                width: 150px;
                height: 15px;
            }
            .preset-controls {
                padding: 15px;
                gap: 10px;
            }
            .preset-controls input[type="text"],
            .preset-controls button {
                width: 95%;
                max-width: none;
            }
            .recording-format-control select {
                width: 100%;
            }
            .message-box {
                width: 90%;
                left: 5%;
                transform: translateX(0);
                padding: 12px 20px;
                font-size: 0.9em;
                bottom: 15px;
            }
            .message-box.show {
                transform: translateX(0) translateY(-10px);
            }
            .modal-content {
                padding: 20px;
                width: 95%;
            }
            .modal-trigger-buttons {
                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); /* Even smaller for mobile icon buttons */
                gap: 8px;
            }
            .modal-trigger-buttons button {
                height: 50px;
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="main-layout-container">
        <div class="central-content">
            <h1>Simple Relax Looper</h1>
            <p>Experience a subtly evolving ambient track designed for relaxation.</p>
            <div class="controls">
                <button id="startButton" class="primary" title="Start the music loop (Hotkey: Space/Enter)"><i class="fas fa-play"></i> Start</button>
                <button id="stopButton" class="primary" disabled title="Stop the music loop (Hotkey: Space/Enter)"><i class="fas fa-stop"></i> Stop</button>
            </div>
            <div id="currentSectionDisplay">Current Section: --</div>
            <div id="songIterationDisplay">Song Iteration: 0</div>
            <div id="messageBox" class="message-box"></div>

            <!-- Audio Visualization Canvas -->
            <canvas id="audioVisualizer" width="400" height="100"></canvas>

            <!-- Visualization Mode Controls -->
            <div class="visualization-controls">
                <button id="visModeSpectrum" class="secondary active" title="Show frequency spectrum visualization">Spectrum</button>
                <button id="visModeWaveform" class="secondary" title="Show waveform visualization">Waveform</button>
                <button id="visModeBoth" class="secondary" title="Show both spectrum and waveform visualization">Both</button>
                <button id="visModeBands" class="secondary" title="Show bass, mid, and treble frequency bands">Bands</button>
            </div>

            <!-- Master Volume Meter -->
            <div class="volume-meter-container">
                <span class="volume-meter-label">Master Volume:</span>
                <div id="volumeMeter">
                    <div id="volumeMeterFill"></div>
                    <div id="volumePeak"></div>
                </div>
            </div>

            <!-- New: Buttons to open control modals (now with icons) -->
            <div class="modal-trigger-buttons">
                <button id="openMasterControlsModal" class="secondary" title="Master Controls"><i class="fas fa-sliders-h"></i><span>Master</span></button>
                <button id="openInstrumentGainsModal" class="secondary" title="Instrument Gains"><i class="fas fa-volume-up"></i><span>Gains</span></button>
                <button id="openInstrumentTimbresModal" class="secondary" title="Instrument Timbres"><i class="fas fa-wave-square"></i><span>Timbres</span></button>
                <button id="openEffectsModal" class="secondary" title="Effects"><i class="fas fa-magic"></i><span>Effects</span></button>
                <button id="openCompressorModal" class="secondary" title="Compressor"><i class="fas fa-compress-alt"></i><span>Comp.</span></button>
                <button id="openReverbModal" class="secondary" title="Reverb"><i class="fas fa-cloud"></i><span>Reverb</span></button>
                <button id="openDistortionModal" class="secondary" title="Distortion"><i class="fas fa-fire"></i><span>Dist.</span></button>
                <button id="openPhaserModal" class="secondary" title="Phaser"><i class="fas fa-atom"></i><span>Phaser</span></button>
            </div>

            <!-- Preset Controls -->
            <div class="preset-controls">
                <h3>Presets</h3>
                <input type="text" id="presetNameInput" placeholder="Enter preset name" title="Enter a name for your preset">
                <button id="savePresetButton" class="secondary" title="Save current settings as a preset"><i class="fas fa-save"></i> Save Preset</button>
                <button id="loadPresetButton" class="secondary" title="Load a saved preset"><i class="fas fa-folder-open"></i> Load Preset</button>
                <button id="exportPresetsButton" class="secondary" title="Export all saved presets to a JSON file"><i class="fas fa-file-export"></i> Export All Presets</button>
                <input type="file" id="importPresetsInput" accept=".json" style="display: none;" title="Select a JSON file to import presets">
                <button id="importPresetsButton" class="secondary" title="Import Presets"><i class="fas fa-file-import"></i> Import Presets</button>
                <p>Quick Load: Press 1-9 to load "Preset 1" to "Preset 9"</p>
            </div>

            <!-- Recording Controls -->
            <div class="controls recording-controls">
                <button id="recordButton" class="secondary" title="Start/Stop recording audio (Hotkey: Ctrl+R)"><i class="fas fa-microphone"></i> Start Recording</button>
                <div class="recording-format-control">
                    <label for="recordingFormat">Format:</label>
                    <select id="recordingFormat" title="Select recording output format">
                        <option value="wav">WAV (Supported)</option>
                        <option value="mp3">MP3 (Not Supported Natively)</option>
                    </select>
                </div>
                <div class="recording-meter"></div>
            </div>
        </div>
    </div>

    <!-- MODAL WINDOWS -->

    <!-- Master Controls Modal -->
    <div id="masterControlsModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div class="knob-section">
                <h3>Master Controls</h3>
                <div class="knob-group">
                    <label for="masterVolume">Master Volume</label>
                    <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.55" title="Adjust overall volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="masterVolumeValue">0.55</span>
                </div>
                <div class="knob-group">
                    <label for="tempo">Tempo (ms)</label>
                    <input type="range" id="tempo" min="300" max="900" step="10" value="420" title="Adjust loop speed. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="tempoValue">420</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Instrument Gains Modal -->
    <div id="instrumentGainsModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div class="knob-section">
                <h3>Instrument Gains</h3>
                <div class="knob-group">
                    <label for="bassVolume">Bass Volume</label>
                    <input type="range" id="bassVolume" min="0" max="0.5" step="0.01" value="0.03" title="Adjust bass instrument volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="bassVolumeValue">0.03</span>
                </div>
                <div class="knob-group">
                    <label for="synthVolume">Synth Volume</label>
                    <input type="range" id="synthVolume" min="0" max="0.5" step="0.01" value="0.08" title="Adjust synth instrument volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="synthVolumeValue">0.08</span>
                </div>
                <div class="knob-group">
                    <label for="kickVolume">Kick Volume</label>
                    <input type="range" id="kickVolume" min="0" max="1" step="0.01" value="0.89" title="Adjust kick drum volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="kickVolumeValue">0.89</span>
                </div>
                <div class="knob-group">
                    <label for="snareVolume">Snare Volume</label>
                    <input type="range" id="snareVolume" min="0" max="0.3" step="0.01" value="0.21" title="Adjust snare drum volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="snareVolumeValue">0.21</span>
                </div>
                <div class="knob-group">
                    <label for="hihatVolume">Hi-Hat Volume</label>
                    <input type="range" id="hihatVolume" min="0" max="0.3" step="0.01" value="0.21" title="Adjust hi-hat volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="hihatVolumeValue">0.21</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Instrument Timbres Modal -->
    <div id="instrumentTimbresModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div class="knob-section">
                <h3>Instrument Timbres</h3>
                <div class="knob-group">
                    <label for="bassOscillatorType">Bass Wave</label>
                    <select id="bassOscillatorType" title="Select waveform for bass instrument">
                        <option value="sine" selected>Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="sawtooth">Sawtooth</option>
                        <option value="square">Square</option>
                    </select>
                </div>
                <div class="knob-group">
                    <label for="synthOscillatorType">Synth Wave</label>
                    <select id="synthOscillatorType" title="Select waveform for synth instrument">
                        <option value="square" selected>Square</option>
                        <option value="sine">Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="sawtooth">Sawtooth</option>
                    </select>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="synthArpeggiator" title="Enable arpeggiator for synth (Hotkey: A)">
                    <label for="synthArpeggiator">Synth Arpeggiator (A)</label>
                </div>
            </div>
        </div>
    </div>

    <!-- Effects Modal -->
    <div id="effectsModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div class="knob-section">
                <h3>Effects</h3>
                <div class="knob-group">
                    <label for="delayTime">Delay Time (s)</label>
                    <input type="range" id="delayTime" min="0.01" max="2.0" step="0.01" value="0.3" title="Set delay time. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="delayTimeValue">0.30</span>
                </div>
                <div class="knob-group">
                    <label for="delayFeedback">Delay Feedback</label>
                    <input type="range" id="delayFeedback" min="0" max="0.95" step="0.01" value="0.4" title="Set delay feedback amount. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="delayFeedbackValue">0.40</span>
                </div>
                <div class="knob-group">
                    <label for="delaySendLevel">Delay Send</label>
                    <input type="range" id="delaySendLevel" min="0" max="1.0" step="0.01" value="0.5" title="Set amount of signal sent to delay. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="delaySendLevelValue">0.50</span>
                </div>
                <div class="knob-group">
                    <label for="chorusDepth">Chorus Depth</label>
                    <input type="range" id="chorusDepth" min="0" max="0.01" step="0.0001" value="0.002" title="Set chorus modulation depth. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="chorusDepthValue">0.002</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="chorusBypass" checked title="Bypass the Chorus effect (Hotkey: C)">
                    <label for="chorusBypass">Bypass Chorus (C)</label>
                </div>
            </div>
        </div>
    </div>

    <!-- Compressor Modal -->
    <div id="compressorModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div class="knob-section">
                <h3>Compressor</h3>
                <div class="knob-group">
                    <label for="compThreshold">Threshold</label>
                    <input type="range" id="compThreshold" min="-60" max="0" step="1" value="-24" title="Set compressor threshold in dB. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="compThresholdValue">-24 dB</span>
                </div>
                <div class="knob-group">
                    <label for="compRatio">Ratio</label>
                    <input type="range" id="compRatio" min="1" max="20" step="0.1" value="12" title="Set compressor ratio. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="compRatioValue">12:1</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Reverb Modal -->
    <div id="reverbModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div class="knob-section">
                <h3>Reverb</h3>
                <div class="knob-group">
                    <label for="reverbMix">Mix</label>
                    <input type="range" id="reverbMix" min="0" max="1" step="0.01" value="0.5" title="Set wet/dry mix for reverb. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="reverbMixValue">50%</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="reverbBypass" checked title="Bypass the Reverb effect (Hotkey: R)">
                    <label for="reverbBypass">Bypass Reverb (R)</label>
                </div>
            </div>
        </div>
    </div>

    <!-- Distortion Modal -->
    <div id="distortionModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div class="knob-section">
                <h3>Distortion</h3>
                <div class="knob-group">
                    <label for="distortionAmount">Amount</label>
                    <input type="range" id="distortionAmount" min="0" max="1000" step="1" value="0" title="Adjust distortion amount. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="distortionAmountValue">0</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="distortionBypass" checked title="Bypass the Distortion effect (Hotkey: D)">
                    <label for="distortionBypass">Bypass Distortion (D)</label>
                </div>
            </div>
        </div>
    </div>

    <!-- Phaser Modal -->
    <div id="phaserModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div class="knob-section">
                <h3>Phaser</h3>
                <div class="knob-group">
                    <label for="phaserRate">Rate (Hz)</label>
                    <input type="range" id="phaserRate" min="0.1" max="10" step="0.1" value="1" title="Adjust phaser modulation rate. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="phaserRateValue">1.0</span>
                </div>
                <div class="knob-group">
                    <label for="phaserDepth">Depth</label>
                    <input type="range" id="phaserDepth" min="0" max="1" step="0.01" value="0.5" title="Adjust phaser modulation depth. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="phaserDepthValue">0.50</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="phaserBypass" checked title="Bypass the Phaser effect (Hotkey: P)">
                    <label for="phaserBypass">Bypass Phaser (P)</label>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for the Web Audio API context and nodes
        let audioContext;
        let masterGainNode;
        let isPlaying = false; // Flag to track if audio is currently playing
        let nextNoteTime = 0; // The time when the next note should be scheduled
        let loopTimeoutId; // ID for the setTimeout that schedules the next audio event

        // Musical parameters controlled by knobs - initialized to default values
        let masterVolume = 0.55;
        let bassVolume = 0.03;
        let synthVolume = 0.08;
        let kickVolume = 0.89;
        let snareVolume = 0.21;
        let hihatVolume = 0.21;

        let currentTempo = 420;
        let targetTempo = 420; // For dynamic tempo changes
        let tempoDriftDirection = 1; // For tempo drift

        // New target variables for smoother humanization
        let targetDetune = 0;
        let targetFilterFrequency = 1000;
        let targetFilterQ = 1;
        let targetBaseNoteDuration = 0.5;
        let targetHumanizationFactor = 0.5;
        let targetDelayTimeValue = 0.3;
        let targetDelayFeedbackValue = 0.4;

        let currentDetune = 0;
        let currentFilterFrequency = 1000;
        let currentFilterQ = 1;
        let baseNoteDuration = 0.5;

        // Global variables for filter and detune drift (still apply subtle background changes)
        let filterDriftDirection = 1;
        let detuneDriftDirection = 1;
        let delayTimeDriftDirection = 1;
        let delayFeedbackDriftDirection = 1;

        // Fibonacci-influenced drift scale factors for dynamic parameters
        const fibonacciDriftScales = [0.1, 0.2, 0.3, 0.5, 0.8, 1.3, 2.1];
        let currentFibonacciDriftScaleIndex = 0;

        // Humanization intensity factor, also influenced by Fibonacci drift
        let humanizationFactor = 0.5;

        // Instrument timbre settings
        let bassOscillatorType = 'sine';
        let synthOscillatorType = 'square';
        let isSynthArpeggiatorActive = false; // Arpeggiator control

        // Delay effect nodes and parameters
        let delayNode;
        let delayFeedbackGain;
        let delaySendGain;
        let delayTimeValue = 0.3;
        let delayFeedbackValue = 0.4;
        let delaySendLevel = 0.5;

        // Chorus effect nodes and parameters
        let chorusNode;
        let chorusLFO;
        let chorusLfoGain;
        let chorusDepth = 0.002;
        let isChorusBypassed = true;

        // Compressor nodes and parameters
        let compressorNode;
        let compThreshold = -24;
        let compRatio = 12;

        // Reverb nodes and parameters
        let convolverNode;
        let reverbGainNode;
        let dryGainNode;
        let preCompressorGain;
        let reverbMix = 0.5;
        let isReverbBypassed = true;

        // Distortion effect nodes and parameters
        let distortionNode;
        let distortionAmount = 0;
        let isDistortionBypassed = true;
        let postDistortionGain;

        // Phaser effect nodes and parameters
        let phaserLFO;
        let phaserLfoGain;
        let phaserFilterNodes = [];
        const PHASER_STAGES = 6;
        let phaserRate = 1;
        let phaserDepth = 0.5;
        let isPhaserBypassed = true;
        let phaserInputGain;
        let postPhaserGain;

        // Recording
        let looperRecorder;

        // Visualizer and Volume Meter elements
        let analyserNode;
        let audioVisualizerCanvas;
        let audioVisualizerCtx;
        let volumeMeterElement;
        let volumeMeterFillElement;
        let volumePeakElement;
        let dataArray;
        let frequencyDataArray;
        let peakValue = 0;
        let visualizationMode = 'spectrum';

        // For cycling through verse patterns (normal and Raga)
        const normalVerseOptions = {
            verse1: ['verse1_A', 'verse1_B', 'verse1_C', 'verse1_D'],
            verse2: ['verse2_A', 'verse2_B', 'verse2_C', 'verse2_D'],
            verse3: ['verse3_A', 'verse3_B', 'verse3_C']
        };
        const ragaVerseOptions = ['ragaYamanPhrase', 'ragaBhairaviPhrase', 'ragaBhoopaliPhrase', 'ragaKhamajPhrase', 'ragaBhimpalasiPhrase', 'ragaKedarPhrase', 'ragaBageshriPhrase', 'ragaMalkaunsPhrase', 'ragaDarbariPhrase', 'ragaBhairavPhrase'];
        let availableRagas = [...ragaVerseOptions];
        let normalVerseIndex = 0;
        let verseIterationCount = 0;

        // Predefined frequencies for a simple musical scale
        const notes = {
            'A1': 55.00, 'A#1': 58.27, 'B1': 61.74,
            'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 97.99, 'G#2': 103.83,
            'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65,
            'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30,
            'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25
        };

        // Chromatic scale for transposition calculations
        const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const noteToSemitone = {};
        chromaticScale.forEach((note, index) => {
            noteToSemitone[note] = index;
        });

        // Circle of Fifths for key modulation
        const majorKeysCircleOfFifths = [
            'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'Db', 'Ab', 'Eb', 'Bb', 'F'
        ];
        const keyToSemitoneOffsetFromC = {
            'C': 0, 'G': 7, 'D': 2, 'A': 9, 'E': 4, 'B': 11, 'F#': 6,
            'Db': 1, 'Ab': 8, 'Eb': 3, 'Bb': 10, 'F': 5
        };

        let currentKey = 'C';
        let sectionsSinceLastKeyChange = 0;
        let sectionsPerKeyChange = 2;

        let songIterationCount = 0;

        /**
         * Transposes an array of note strings by a given number of semitones.
         * @param {Array<string>} notesArray - An array of note strings (e.g., ['C4', 'G3']).
         * @param {number} semitones - The number of semitones to transpose by.
         * @returns {Array<string>} A new array with transposed note strings.
         */
        function transposeNotes(notesArray, semitones) {
            const validNotes = notesArray.filter(noteString => typeof noteString === 'string' && noteString.length >= 2);

            return validNotes.map(noteString => {
                const baseNote = noteString.slice(0, -1);
                const octave = parseInt(noteString.slice(-1));
                
                if (!noteToSemitone.hasOwnProperty(baseNote)) {
                    console.warn(`Unknown base note for transposition: ${baseNote}. Returning original.`);
                    return noteString;
                }

                let semitoneValue = noteToSemitone[baseNote] + semitones;
                let newOctave = octave + Math.floor(semitoneValue / 12);
                let newSemitoneIndex = (semitoneValue % 12 + 12) % 12;

                return chromaticScale[newSemitoneIndex] + newOctave;
            });
        }

        // Raga scale definitions (using C as tonic for simplicity)
        const ragaScales = {
            yaman: ['C4', 'D4', 'E4', 'F#4', 'G4', 'A4', 'B4', 'C5'],
            bhairavi: ['C4', 'C#4', 'D#4', 'F4', 'G4', 'G#4', 'A#4', 'C5'],
            bhoopali: ['C4', 'D4', 'E4', 'G4', 'A4', 'C5'],
            khamaj: ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'A#4', 'C5'],
            bhimpalasi: ['C4', 'Eb4', 'F4', 'G4', 'Bb4', 'C5'],
            kedar: ['C4', 'D4', 'E4', 'F#4', 'G4', 'A4', 'B4', 'C5'],
            bageshri: ['C4', 'Eb4', 'F4', 'Ab4', 'Bb4', 'C5'],
            malkauns: ['C4', 'Eb4', 'F4', 'Ab4', 'Bb4', 'C5'],
            darbari: ['C4', 'D4', 'Eb4', 'F4', 'G4', 'Ab4', 'Bb4', 'C5'],
            bhairav: ['C4', 'C#4', 'E4', 'F4', 'G4', 'G#4', 'B4', 'C5']
        };

        // Raga Characteristics System
        const ragaCharacteristics = {
            time: {
                morning: ['yaman', 'bhairavi', 'bhoopali', 'bhairav'],
                afternoon: ['bhimpalasi', 'khamaj', 'kedar'],
                evening: ['yaman', 'kedar', 'bageshri'],
                night: ['bageshri', 'malkauns', 'darbari']
            },
            moods: {
                peaceful: ['bhoopali', 'yaman', 'bhairav'],
                energetic: ['bhairavi', 'khamaj', 'kedar'],
                melancholic: ['bhimpalasi', 'bageshri', 'malkauns', 'darbari'],
                romantic: ['khamaj', 'yaman', 'bageshri']
            }
        };

        /**
         * Selects a Raga appropriate for the current time of day.
         * @returns {string} The name of a time-appropriate Raga (e.g., 'yaman').
         */
        function selectTimeAppropriateRaga() {
            const hour = new Date().getHours();
            const timeOfDay = 
                hour >= 4 && hour < 8 ? 'morning' :
                hour >= 8 && hour < 16 ? 'afternoon' :
                hour >= 16 && hour < 20 ? 'evening' : 'night';
            
            const appropriateRagas = ragaCharacteristics.time[timeOfDay];
            const availableAndDefinedRagas = appropriateRagas.filter(raga => ragaScales[raga]);

            if (availableAndDefinedRagas.length > 0) {
                return availableAndDefinedRagas[Math.floor(Math.random() * availableAndDefinedRagas.length)];
            } else {
                console.warn(`No defined Raga scales found for time of day: ${timeOfDay}. Falling back to 'yaman'.`);
                return 'yaman';
            }
        }


        /**
         * Generates a melodic phrase within a given Raga scale, with expressive variations.
         * @param {Array<string>} scale - Array of note names in the Raga scale (e.g., ['C4', 'D4', 'E4']).
         * @param {number} phraseLength - Number of steps in the phrase (e.g., 8).
         * @param {number} humanizationFactor - A factor influencing how "busy" or sparse the melody is (0-1).
         * @returns {Array<Object>} An array of phrase steps.
         */
        function generateRagaMelody(scale, phraseLength, humanizationFactor) {
            if (!Array.isArray(scale) || scale.length === 0) {
                console.error("generateRagaMelody received an empty or invalid scale array:", scale);
                return [];
            }

            const generatedPhrase = [];
            let currentSynthNoteIndex = Math.floor(Math.random() * scale.length);
            let lastSynthDirection = Math.random() < 0.5 ? 1 : -1;

            const getSafeNote = (arr, index) => arr[index] || arr[0];

            const vadiNote = getSafeNote(scale, 0);
            const samvadiNote = getSafeNote(scale, scale.length > 4 ? 4 : scale.length - 1);

            for (let i = 0; i < phraseLength; i++) {
                const step = {
                    bass: [],
                    synth: [],
                    percussion: {},
                    delaySend: 0.3 + (Math.random() * 0.3)
                };

                // --- Bass Line Generation ---
                if (i % 4 === 0) {
                    step.bass.push(vadiNote.replace('4', '2'));
                } else if (i % 2 === 0) {
                    if (Math.random() < 0.7) {
                        const bassOptions = [
                            vadiNote.replace('4', '2'),
                            samvadiNote.replace('4', '2')
                        ];
                        if (scale.length > 2) {
                            bassOptions.push(getSafeNote(scale, 2).replace('4', '2'));
                        }
                        const selectedBassNote = bassOptions[Math.floor(Math.random() * bassOptions.length)];
                        if (selectedBassNote) {
                            step.bass.push(selectedBassNote);
                        }
                    }
                }
                if (step.bass.length === 0) {
                    step.bass.push(vadiNote.replace('4', '2'));
                }

                // --- Synth Melody Generation ---
                const numSynthNotes = 1 + Math.floor(Math.random() * (humanizationFactor * 2));
                let synthNotesForStep = [];

                for (let j = 0; j < numSynthNotes; j++) {
                    let nextSynthNoteIndex = currentSynthNoteIndex;

                    if (Math.random() < 0.8) {
                        nextSynthNoteIndex = (currentSynthNoteIndex + lastSynthDirection + scale.length * 2) % scale.length;
                    } else if (Math.random() < 0.95) {
                        const leapAmount = Math.random() < 0.5 ? 2 : 3;
                        nextSynthNoteIndex = (currentSynthNoteIndex + lastSynthDirection * leapAmount + scale.length * 2) % scale.length;
                    } else {
                        lastSynthDirection *= -1;
                        const leapAmount = Math.floor(Math.random() * (scale.length / 2)) + 1;
                        nextSynthNoteIndex = (currentSynthNoteIndex + lastSynthDirection * leapAmount + scale.length * 2) % scale.length;
                    }

                    if (vadiNote && Math.random() < 0.4) {
                        const targetVadiBaseNote = vadiNote.slice(0, -1);
                        let vadiIndex = scale.findIndex(note => note.startsWith(targetVadiBaseNote));
                        if (vadiIndex !== -1) {
                            nextSynthNoteIndex = vadiIndex;
                        } else {
                            nextSynthNoteIndex = Math.floor(Math.random() * scale.length);
                            console.warn(`Vadi note base ${targetVadiBaseNote} not found in current scale. Picking random note.`);
                        }
                    } else if (samvadiNote && Math.random() < 0.25) {
                        const targetSamvadiBaseNote = samvadiNote.slice(0, -1);
                        let samvadiIndex = scale.findIndex(note => note.startsWith(targetSamvadiBaseNote));
                        if (samvadiIndex !== -1) {
                            nextSynthNoteIndex = samvadiIndex;
                        } else {
                            nextSynthNoteIndex = Math.floor(Math.random() * scale.length);
                            console.warn(`Samvadi note base ${targetSamvadiBaseNote} not found in current scale. Picking random note.`);
                        }
                    }

                    currentSynthNoteIndex = nextSynthNoteIndex;

                    if (currentSynthNoteIndex < 0 || currentSynthNoteIndex >= scale.length || !scale[currentSynthNoteIndex]) {
                        console.warn(`Invalid currentSynthNoteIndex (${currentSynthNoteIndex}) or undefined note in scale. Re-selecting random note.`);
                        currentSynthNoteIndex = Math.floor(Math.random() * scale.length);
                    }

                    let synthNote = scale[currentSynthNoteIndex];
                    const currentOctave = parseInt(synthNote.slice(-1));
                    
                    if (Math.random() < 0.2 * humanizationFactor) {
                        if (Math.random() < 0.5 && currentOctave < 5) {
                            synthNote = synthNote.slice(0, -1) + (currentOctave + 1);
                        } else if (currentOctave > 3) {
                            synthNote = synthNote.slice(0, -1) + (currentOctave - 1);
                        }
                    }
                    synthNotesForStep.push(synthNote);
                }
                
                if (humanizationFactor > 0.7 && Math.random() < 0.25 * humanizationFactor) {
                    const rootIndex = currentSynthNoteIndex;
                    const thirdNote = getSafeNote(scale, (rootIndex + 2) % scale.length);
                    const fifthNote = getSafeNote(scale, (rootIndex + 4) % scale.length);
                    
                    if (thirdNote) synthNotesForStep.push(thirdNote);
                    if (fifthNote) synthNotesForStep.push(fifthNote);
                }

                step.synth = synthNotesForStep.length > 0 ? synthNotesForStep : [getSafeNote(scale, currentSynthNoteIndex)];

                // --- Percussion Generation (more varied) ---
                if (i === 0) {
                    step.percussion.kick = { active: true, probability: 0.95, velocity: 1.0 };
                    step.percussion.hihat = { active: true, probability: 1.0, type: 'closed', velocity: 0.8 };
                } else if (i === 4) {
                    step.percussion.kick = { active: true, probability: 0.8, velocity: 0.9 };
                    step.percussion.hihat = { active: true, probability: 1.0, type: 'closed', velocity: 0.8 };
                } else if (i === 2 || i === 6) {
                    step.percussion.snare = { active: true, probability: 0.85, velocity: 1.0 };
                    step.percussion.hihat = { active: true, probability: 1.0, type: 'closed', velocity: 0.8 };
                } else if (i % 2 !== 0) {
                    if (Math.random() < 0.9) {
                        step.percussion.hihat = { active: true, probability: 1.0, type: 'closed', velocity: 0.7 };
                    }
                    if (Math.random() < 0.2) {
                        if (Math.random() < 0.5) {
                            step.percussion.kick = { active: true, probability: 0.5, velocity: 0.3 };
                        } else {
                            step.percussion.snare = { active: true, probability: 0.5, velocity: 0.3 };
                        }
                    }
                }
                
                generatedPhrase.push(step);
            }
            return generatedPhrase;
        }


        // Define musical phrases for each section of the song.
        // All phrases are defined in the key of C Major. They will be transposed dynamically.
        const musicalPhrases = {
            intro: [
                { bass: ['C2'], synth: ['C4'], percussion: {}, delaySend: 0.8 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.7 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.6 },
                { bass: ['F2'], synth: ['F3'], percussion: {}, delaySend: 0.5 },
                { bass: ['C2'], synth: ['C4', 'E4'], percussion: {}, delaySend: 0.4 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: {}, delaySend: 0.3 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: {}, delaySend: 0.2 },
                { bass: ['F2'], synth: ['F3', 'A3'], percussion: {}, delaySend: 0.1 },
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: {}, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: {}, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: {}, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: {}, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: {}, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: {}, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: {}, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: {}, delaySend: 0.0 }
            ],
            verse1_A: [
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3', 'C4', 'F4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_B: [
                { bass: ['C2'], synth: ['E4', 'G4', 'C5'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3', 'D4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4', 'E4', 'A4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3', 'C4', 'F4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_C: [
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_D: [
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } } },
                { bass: ['G2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_A: [
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_B: [
                { bass: ['F2'], synth: ['C4', 'F4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['G3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['D4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['E4', 'A4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_C: [
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_D: [
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['G3', 'E4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4', 'G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse3_A: [
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['D3', 'F#3', 'A3'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['F#3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['E2'], synth: ['E3', 'G3', 'B3'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['E2'], synth: ['G3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C3'], synth: ['C4', 'E4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C3'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse3_B: [
                { bass: ['G2'], synth: ['D4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['A3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['F#3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['E2'], synth: ['B3', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['E2'], synth: ['G3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C3'], synth: ['G4', 'C5'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C3'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse3_C: [
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['D3', 'A3'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['F#3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['E2'], synth: ['B3', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['E2'], synth: ['G3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C3'], synth: ['C4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            ragaYamanPhrase: [],
            ragaBhairaviPhrase: [],
            ragaBhoopaliPhrase: [],
            ragaKhamajPhrase: [],
            ragaBhimpalasiPhrase: [], 
            ragaKedarPhrase: [],      
            ragaBageshriPhrase: [],   
            ragaMalkaunsPhrase: [],   
            ragaDarbariPhrase: [],    
            ragaBhairavPhrase: [],    
            
            chorus: [
                { bass: ['C2'], synth: ['C4', 'E4', 'G4', 'C5'], percussion: { kick: { active: true, probability: 0.95, velocity: 1.0 }, snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['C2'], synth: ['G4', 'C5'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4', 'G4'], percussion: { kick: { active: true, probability: 0.95, velocity: 1.0 }, snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['G2'], synth: ['D4', 'G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4', 'A4'], percussion: { kick: { active: true, probability: 0.95, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.6 },
                { bass: ['A2'], synth: ['C4', 'E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4', 'F4'], percussion: { kick: { active: true, probability: 0.95, velocity: 1.0 }, snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['F2'], synth: ['A3', 'C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 }
            ],
            bridge: [
                { bass: ['D2'], synth: ['D4', 'F4', 'A4'], percussion: { hihat: { active: true, probability: 0.5, type: 'closed', velocity: 0.6 } }, delaySend: 0.5 },
                { bass: ['E2'], synth: ['E4', 'G4', 'B4'], percussion: { hihat: { active: true, probability: 0.5, type: 'closed', velocity: 0.6 } }, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3', 'D4', 'G4'], percussion: { hihat: { active: true, probability: 0.5, type: 'closed', velocity: 0.6 } }, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4', 'F4', 'A4'], percussion: { hihat: { active: true, probability: 0.5, type: 'closed', velocity: 0.6 } }, delaySend: 0.5 },
                { bass: ['D2'], synth: ['D4', 'F4', 'A4', 'C5'], percussion: { kick: { active: true, probability: 0.6, velocity: 0.8 } }, delaySend: 0.6 },
                { bass: ['E2'], synth: ['E4', 'G4', 'B4', 'D5'], percussion: { snare: { active: true, probability: 0.6, velocity: 0.8 } }, delaySend: 0.6 },
                { bass: ['A2'], synth: ['A3', 'D4', 'G4', 'C5'], percussion: { kick: { active: true, probability: 0.6, velocity: 0.8 } }, delaySend: 0.6 },
                { bass: ['C3'], synth: ['C4', 'F4', 'A4', 'D5'], percussion: { snare: { active: true, probability: 0.6, velocity: 0.8 } }, delaySend: 0.6 }
            ],
            outro: [
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: {}, delaySend: 0.8 },
                { bass: ['G2'], synth: ['E4'], percussion: {}, delaySend: 0.7 },
                { bass: ['A2'], synth: ['C4'], percussion: {}, delaySend: 0.6 },
                { bass: ['F2'], synth: ['F3'], percussion: {}, delaySend: 0.5 },
                { bass: ['C2'], synth: ['C4'], percussion: {}, delaySend: 0.4 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.3 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.2 },
                { bass: ['F2'], synth: ['F3'], percussion: {}, delaySend: 0.0 }
            ]
        };

        const songStructure = [
            { type: 'intro', durationMultiplier: 2, initialKey: 'C' },
            { type: 'verse', baseName: 'verse1', durationMultiplier: 3, initialKey: 'C' },
            { type: 'chorus', durationMultiplier: 2, initialKey: 'C' },
            { type: 'verse', baseName: 'verse2', durationMultiplier: 3, initialKey: 'C' },
            { type: 'verse', baseName: 'verse3', durationMultiplier: 5, initialKey: 'C' },
            { type: 'bridge', durationMultiplier: 2, initialKey: 'C' },
            { type: 'chorus', durationMultiplier: 3, initialKey: 'C' },
            { type: 'verse', baseName: 'verse1', durationMultiplier: 2, initialKey: 'C' },
            { type: 'outro', durationMultiplier: 2, initialKey: 'C' }
        ];

        let currentSongSectionIndex = 0;
        let currentSectionType = '';
        let currentSectionName = '';
        let currentSectionPhrase = [];
        let currentPhraseIndex = 0;
        let stepsPlayedInCurrentSection = 0;
        let currentSectionTotalSteps = 0;

        /**
         * Shuffles an array in place (Fisher-Yates algorithm).
         * @param {Array} array - The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * Gets the next Raga phrase from the available pool, ensuring non-repetition until all are played.
         * @returns {string} The name of the next Raga phrase.
         */
        function getNextRagaPhrase() {
            if (availableRagas.length === 0) {
                availableRagas = [...ragaVerseOptions];
                shuffleArray(availableRagas);
                console.log("Raga pool reset and shuffled:", availableRagas);
            }
            const nextRaga = availableRagas.shift();
            console.log("Next Raga:", nextRaga, "Remaining Ragas:", availableRagas);
            return nextRaga;
        }

        /**
         * Selects a random variation for a given normal verse base name.
         * @param {string} baseName - The base name of the verse (e.g., 'verse1').
         * @returns {string} The name of the selected verse variation (e.g., 'verse1_A').
         */
        function getRandomNormalVerseVariation(baseName) {
            const variations = normalVerseOptions[baseName];
            if (!variations || variations.length === 0) {
                console.warn(`No variations found for normal verse: ${baseName}`);
                return baseName;
            }
            const randomIndex = Math.floor(Math.random() * variations.length);
            return variations[randomIndex];
        }

        /**
         * Updates the display with the current song section and applies a highlight.
         */
        function updateSectionDisplay() {
            const displayElement = document.getElementById('currentSectionDisplay');
            if (displayElement) {
                const newText = `Current Section: ${currentSectionName.toUpperCase()} in ${currentKey} Major`;
                if (displayElement.textContent !== newText) {
                     displayElement.classList.remove('highlight');
                }
                displayElement.textContent = newText;
                requestAnimationFrame(() => {
                    displayElement.classList.add('highlight');
                });
            }
        }

        /**
         * Updates the display with the current song iteration count.
         */
        function updateSongIterationDisplay() {
            const displayElement = document.getElementById('songIterationDisplay');
            if (displayElement) {
                displayElement.textContent = `Song Iteration: ${songIterationCount}`;
            }
        }

        /**
         * Displays a temporary message to the user in a dedicated message box.
         * @param {string} message - The text message to display.
         * @param {number} duration - How long the message should be visible in milliseconds.
         */
        function showMessage(message, duration = 3000) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            messageBox.classList.add('show');
            clearTimeout(messageBox.hideTimeout);
            messageBox.hideTimeout = setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }

        /**
         * Generates a distortion curve for the WaveShaperNode.
         * @param {number} amount - The amount of distortion. Higher values mean more distortion.
         * @returns {Float32Array} A Float32Array representing the distortion curve.
         */
        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 0;
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            const deg = Math.PI / 180;
            for (let i = 0; i < n_samples; ++i) {
                const x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        /**
         * Updates the audio graph connection for distortion bypass.
         */
        function updateDistortionBypassConnection() {
            if (!audioContext || !masterGainNode || !distortionNode || !postDistortionGain || !phaserInputGain) return;

            try {
                masterGainNode.disconnect();
            } catch (e) { /* ignore */ }

            if (isDistortionBypassed) {
                masterGainNode.connect(postDistortionGain);
            } else {
                masterGainNode.connect(distortionNode);
                distortionNode.connect(postDistortionGain);
            }
            updatePhaserBypassConnection();
        }

        /**
         * Updates the audio graph connection for phaser bypass.
         */
        function updatePhaserBypassConnection() {
            if (!audioContext || !postDistortionGain || !phaserInputGain || phaserFilterNodes.length === 0 || !postPhaserGain || !chorusNode || !preCompressorGain) return;

            try {
                postDistortionGain.disconnect();
            } catch (e) { /* ignore */ }
            
            try {
                phaserFilterNodes[PHASER_STAGES - 1].disconnect();
            } catch (e) { /* ignore */ }

            if (isPhaserBypassed) {
                postDistortionGain.connect(postPhaserGain);
            } else {
                postDistortionGain.connect(phaserInputGain);
                phaserInputGain.connect(phaserFilterNodes[0]);
                phaserFilterNodes[PHASER_STAGES - 1].connect(postPhaserGain);
            }
            updateChorusBypassConnection();
        }

        /**
         * Updates the audio graph connection for chorus bypass.
         */
        function updateChorusBypassConnection() {
            if (!audioContext || !postPhaserGain || !preCompressorGain || !chorusNode) return;

            try {
                postPhaserGain.disconnect();
            } catch (e) { /* ignore */ }
            
            if (isChorusBypassed) {
                postPhaserGain.connect(preCompressorGain);
            } else {
                postPhaserGain.connect(chorusNode);
                chorusNode.connect(preCompressorGain);
            }
        }

        /**
         * Updates the audio graph connection for reverb bypass and wet/dry mix.
         */
        function updateReverbBypassConnection() {
            if (!audioContext || !preCompressorGain || !convolverNode || !reverbGainNode || !dryGainNode) return;

            try {
                preCompressorGain.disconnect(dryGainNode);
                preCompressorGain.disconnect(reverbGainNode);
            } catch (e) { /* ignore */ }

            try {
                convolverNode.disconnect(preCompressorGain);
            } catch (e) { /* ignore */ }

            if (isReverbBypassed) {
                // No need to connect dryGainNode or reverbGainNode if bypassed
            } else {
                dryGainNode.gain.setValueAtTime(1 - reverbMix, audioContext.currentTime);
                reverbGainNode.gain.setValueAtTime(reverbMix, audioContext.currentTime);

                preCompressorGain.connect(dryGainNode);
                dryGainNode.connect(compressorNode);

                preCompressorGain.connect(reverbGainNode);
                reverbGainNode.connect(convolverNode);
                convolverNode.connect(compressorNode);
            }
        }

        /**
         * Updates a specific audio parameter based on the UI element ID and its new value.
         * @param {string} id - The ID of the HTML input element.
         * @param {number|string} value - The new value from the input element.
         */
        function updateAudioParameter(id, value) {
            const valueDisplay = document.getElementById(id + 'Value');
            if (valueDisplay) {
                if (id === 'compThreshold') {
                    valueDisplay.textContent = `${value} dB`;
                } else if (id === 'compRatio') {
                    valueDisplay.textContent = `${value}:1`;
                } else if (id === 'reverbMix') {
                    valueDisplay.textContent = `${(value * 100).toFixed(0)}%`;
                } else if (id === 'delayTime' || id === 'delayFeedback' || id === 'delaySendLevel' || id === 'chorusDepth' || id === 'phaserRate' || id === 'phaserDepth') {
                    valueDisplay.textContent = parseFloat(value).toFixed(2);
                } else {
                    valueDisplay.textContent = parseFloat(value).toFixed(2);
                }
            }

            if (audioContext) {
                const currentTime = audioContext.currentTime;
                switch (id) {
                    case 'masterVolume':
                        masterVolume = value;
                        if (masterGainNode) masterGainNode.gain.setValueAtTime(masterVolume, currentTime);
                        break;
                    case 'tempo':
                        targetTempo = value;
                        break;
                    case 'bassVolume':
                        bassVolume = value;
                        break;
                    case 'synthVolume':
                        synthVolume = value;
                        break;
                    case 'kickVolume':
                        kickVolume = value;
                        break;
                    case 'snareVolume':
                        snareVolume = value;
                        break;
                    case 'hihatVolume':
                        hihatVolume = value;
                        break;
                    case 'bassOscillatorType':
                        bassOscillatorType = value;
                        break;
                    case 'synthOscillatorType':
                        synthOscillatorType = value;
                        break;
                    case 'delayTime':
                        delayTimeValue = value;
                        if (delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, currentTime);
                        break;
                    case 'delayFeedback':
                        delayFeedbackValue = value;
                        if (delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, currentTime);
                        break;
                    case 'delaySendLevel':
                        delaySendLevel = value;
                        break;
                    case 'chorusDepth':
                        chorusDepth = value;
                        if (chorusLfoGain) chorusLfoGain.gain.setValueAtTime(chorusDepth, currentTime);
                        break;
                    case 'compThreshold':
                        compThreshold = value;
                        if (compressorNode) compressorNode.threshold.setValueAtTime(compThreshold, currentTime);
                        break;
                    case 'compRatio':
                        compRatio = value;
                        if (compressorNode) compressorNode.ratio.setValueAtTime(compRatio, currentTime);
                        break;
                    case 'reverbMix':
                        reverbMix = value;
                        if (reverbGainNode) reverbGainNode.gain.setValueAtTime(reverbMix, currentTime);
                        if (dryGainNode) dryGainNode.gain.setValueAtTime(1 - reverbMix, currentTime);
                        break;
                    case 'distortionAmount':
                        distortionAmount = value;
                        if (distortionNode) distortionNode.curve = makeDistortionCurve(distortionAmount);
                        break;
                    case 'phaserRate':
                        phaserRate = value;
                        if (phaserLFO) phaserLFO.frequency.setValueAtTime(phaserRate, currentTime);
                        break;
                    case 'phaserDepth':
                        phaserDepth = value;
                        if (phaserLfoGain) phaserLfoGain.gain.setValueAtTime(phaserDepth * 1000, currentTime);
                        break;
                }
            }
            const knobElement = document.getElementById(id);
            if (knobElement && knobElement.type === 'range') {
                const min = parseFloat(knobElement.min);
                const max = parseFloat(knobElement.max);
                const percentage = ((parseFloat(value) - min) / (max - min)) * 100;
                knobElement.style.setProperty('--fill-percentage', `${percentage}%`);
            }
        }

        /**
         * Selects the next key based on weighted probabilities for musical coherence.
         * @param {string} currentKey - The current key (e.g., 'C').
         * @returns {string} The newly selected key.
         */
        function selectNextKey(currentKey) {
            const currentKeyIndex = majorKeysCircleOfFifths.indexOf(currentKey);
            let nextKey = currentKey;
            let transitionMessage = `Staying in ${currentKey} Major.`;

            const probabilities = {
                tonic: 0.40,
                dominant: 0.30,
                subdominant: 0.20,
                nearbyRandom: 0.10
            };

            const rand = Math.random();
            let cumulativeProbability = 0;

            cumulativeProbability += probabilities.tonic;
            if (rand < cumulativeProbability) {
                nextKey = currentKey;
                transitionMessage = `Staying in ${currentKey} Major.`;
            } else {
                cumulativeProbability += probabilities.dominant;
                if (rand < cumulativeProbability) {
                    nextKey = majorKeysCircleOfFifths[(currentKeyIndex + 1) % majorKeysCircleOfFifths.length];
                    transitionMessage = `Modulating to Dominant: ${nextKey} Major!`;
                } else {
                    cumulativeProbability += probabilities.subdominant;
                    if (rand < cumulativeProbability) {
                        nextKey = majorKeysCircleOfFifths[(currentKeyIndex - 1 + majorKeysCircleOfFifths.length) % majorKeysCircleOfFifths.length];
                        transitionMessage = `Modulating to Subdominant: ${nextKey} Major!`;
                    } else {
                        let offset;
                        do {
                            offset = Math.floor(Math.random() * 6) - 3;
                            if (offset >= 0) offset += 1;
                        } while (offset === 0);
                        
                        const newIndex = (currentKeyIndex + offset + majorKeysCircleOfFifths.length * 2) % majorKeysCircleOfFifths.length;
                        nextKey = majorKeysCircleOfFifths[newIndex];
                        transitionMessage = `Modulating to a nearby key: ${nextKey} Major!`;
                    }
                }
            }
            showMessage(transitionMessage, 2500);
            return nextKey;
        }


        /**
         * Initializes the Web Audio API context and the main audio graph nodes.
         * @returns {boolean} True if audio context was successfully initialized or already exists, false otherwise.
         */
        function initAudio() {
            console.log("Attempting to initialize audio context...");
            if (!audioContext) {
                try {
                    showMessage("Loading Audio System...", 5000);
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = masterVolume;

                    distortionNode = audioContext.createWaveShaper();
                    distortionNode.curve = makeDistortionCurve(distortionAmount);
                    distortionNode.oversample = '4x';
                    postDistortionGain = audioContext.createGain();

                    phaserInputGain = audioContext.createGain();
                    postPhaserGain = audioContext.createGain();

                    for (let i = 0; i < PHASER_STAGES; i++) {
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'allpass';
                        filter.frequency.value = 1000;
                        filter.Q.value = 1;
                        phaserFilterNodes.push(filter);
                    }

                    for (let i = 0; i < PHASER_STAGES - 1; i++) {
                        phaserFilterNodes[i].connect(phaserFilterNodes[i + 1]);
                    }

                    phaserLFO = audioContext.createOscillator();
                    phaserLFO.type = 'sine';
                    phaserLFO.frequency.value = phaserRate;
                    phaserLFO.start(0);

                    phaserLfoGain = audioContext.createGain();
                    phaserLfoGain.gain.value = phaserDepth * 1000;
                    phaserLFO.connect(phaserLfoGain);

                    phaserFilterNodes.forEach(filter => {
                        phaserLfoGain.connect(filter.frequency);
                    });

                    chorusNode = audioContext.createDelay(0.01);
                    chorusLFO = audioContext.createOscillator();
                    chorusLfoGain = audioContext.createGain();

                    chorusLFO.type = 'sine';
                    chorusLFO.frequency.value = 1.5;
                    chorusLfoGain.gain.value = chorusDepth;
                    
                    chorusLFO.connect(chorusLfoGain);
                    chorusLfoGain.connect(chorusNode.delayTime);
                    chorusLFO.start(audioContext.currentTime);

                    preCompressorGain = audioContext.createGain();

                    delayNode = audioContext.createDelay(2.0);
                    delayFeedbackGain = audioContext.createGain();
                    delaySendGain = audioContext.createGain();

                    delayNode.delayTime.value = delayTimeValue;
                    delayFeedbackGain.gain.value = delayFeedbackValue;
                    delaySendGain.gain.value = delaySendLevel;

                    delaySendGain.connect(delayNode);
                    delayNode.connect(delayFeedbackGain);
                    delayFeedbackGain.connect(delayNode);
                    delayNode.connect(preCompressorGain);

                    compressorNode = audioContext.createDynamicsCompressor();
                    compressorNode.threshold.value = compThreshold;
                    compressorNode.knee.value = 30;
                    compressorNode.ratio.value = compRatio;
                    compressorNode.attack.value = 0.003;
                    compressorNode.release.value = 0.25;

                    convolverNode = audioContext.createConvolver();
                    reverbGainNode = audioContext.createGain();
                    dryGainNode = audioContext.createGain();

                    const impulseLength = 2;
                    const sampleRate = audioContext.sampleRate;
                    const impulseBuffer = audioContext.createBuffer(2, sampleRate * impulseLength, sampleRate);
                    const leftChannel = impulseBuffer.getChannelData(0);
                    const rightChannel = impulseBuffer.getChannelData(1);

                    for (let i = 0; i < sampleRate * impulseLength; i++) {
                        leftChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / (sampleRate * impulseLength), 2);
                        rightChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / (sampleRate * impulseLength), 2);
                    }
                    convolverNode.buffer = impulseBuffer;
                    reverbGainNode.gain.value = reverbMix;
                    dryGainNode.gain.value = 1 - reverbMix;

                    analyserNode = audioContext.createAnalyser();
                    analyserNode.fftSize = 256;
                    analyserNode.smoothingTimeConstant = 0.8;
                    analyserNode.minDecibels = -90;
                    analyserNode.maxDecibels = -10;
                    
                    dataArray = new Uint8Array(analyserNode.frequencyBinCount);
                    frequencyDataArray = new Uint8Array(analyserNode.frequencyBinCount);

                    updateDistortionBypassConnection();
                    updatePhaserBypassConnection();
                    updateChorusBypassConnection();

                    preCompressorGain.connect(compressorNode);
                    compressorNode.connect(analyserNode);
                    analyserNode.connect(audioContext.destination);

                    preCompressorGain.connect(delaySendGain);
                    updateReverbBypassConnection();

                    audioVisualizerCanvas = document.getElementById('audioVisualizer');
                    audioVisualizerCtx = audioVisualizerCanvas.getContext('2d');
                    volumeMeterElement = document.getElementById('volumeMeter');
                    volumeMeterFillElement = document.getElementById('volumeMeterFill');
                    volumePeakElement = document.getElementById('volumePeak');

                    delayNode.delayTime.value = delayTimeValue;
                    delayFeedbackGain.gain.value = delayFeedbackValue;
                    delaySendGain.gain.value = delaySendLevel;

                    looperRecorder = new EnhancedLooperRecorder(audioContext);

                    showMessage(`Audio context initialized. Master Gain: ${masterVolume.toFixed(2)}`);
                    console.log("AudioContext initialized successfully. State:", audioContext.state);
                } catch (e) {
                    showMessage("Web Audio API is not supported in this browser or could not be initialized. Please try a different browser.", 5000);
                    console.error("Web Audio API error:", e);
                    return false;
                }
            } else {
                console.log("AudioContext already exists. State:", audioContext.state);
            }
            return true;
        }

        /**
         * Plays a single musical note using an oscillator and applies a simple ADSR envelope,
         * detune, and a low-pass filter.
         * @param {number} frequency - The frequency of the note in Hz.
         * @param {number} startTime - The AudioContext.currentTime when the note should start.
         * @param {number} duration - The duration of the note in seconds.
         * @param {number} detuneValue - The detune value in cents.
         * @param {number} filterFreq - The cutoff frequency for the low-pass filter.
         * @param {number} filterQ - The Q factor for the low-pass filter.
         * @param {string} instrumentType - 'bass' or 'synth' to determine timbre.
         * @param {number} velocity - The velocity (0-1) of the note.
         */
        function playNote(frequency, startTime, duration, detuneValue = currentDetune, filterFreq = currentFilterFrequency, filterQ = currentFilterQ, instrumentType = 'synth', velocity = 1.0) {
            if (!audioContext || !masterGainNode || !preCompressorGain) {
                console.warn("Cannot play note: AudioContext or main gain nodes not available.");
                return;
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();

            const timingOffset = (Math.random() - 0.5) * 0.08 * humanizationFactor;
            const dynamicFactor = 1 + (Math.random() - 0.5) * 0.6 * humanizationFactor;
            const durationFactor = 1 + (Math.random() - 0.5) * 0.3 * humanizationFactor;

            const actualStartTime = Math.max(0, startTime + timingOffset);
            const actualDuration = duration * durationFactor;

            let attackTime = 0.05;
            let decayTime = 0.2;
            let sustainLevel = 0.5;
            let releaseTime = 0.2;
            let initialGain;
            let oscType;

            switch (instrumentType) {
                case 'bass':
                    oscType = bassOscillatorType;
                    attackTime = 0.02;
                    decayTime = 0.3;
                    sustainLevel = 0.5;
                    releaseTime = 0.2;
                    initialGain = bassVolume * velocity;
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(400, actualStartTime);
                    filterNode.Q.setValueAtTime(0.8, actualStartTime);
                    break;
                case 'synth':
                default:
                    oscType = synthOscillatorType;
                    attackTime = 0.1;
                    decayTime = 0.5;
                    sustainLevel = 0.6;
                    releaseTime = 0.8;
                    initialGain = synthVolume * velocity;
                    filterNode.type = 'lowpass';
                    
                    const initialFilterFreq = filterFreq * (1 + (Math.random() - 0.5) * 0.2 * humanizationFactor);
                    const finalFilterFreq = filterFreq;
                    filterNode.frequency.setValueAtTime(initialFilterFreq, actualStartTime);
                    filterNode.frequency.linearRampToValueAtTime(finalFilterFreq, actualStartTime + 0.5);
                    
                    filterNode.Q.setValueAtTime(filterQ, actualStartTime);
                    break;
            }

            oscillator.type = oscType;
            oscillator.frequency.setValueAtTime(frequency, actualStartTime);
            oscillator.detune.setValueAtTime(detuneValue, actualStartTime);

            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(masterGainNode);
            
            gainNode.gain.setValueAtTime(0, actualStartTime);
            gainNode.gain.linearRampToValueAtTime(initialGain * dynamicFactor, actualStartTime + attackTime);
            gainNode.gain.linearRampToValueAtTime(initialGain * dynamicFactor * sustainLevel, actualStartTime + attackTime + decayTime);

            const releaseStartTime = Math.max(actualStartTime, actualStartTime + actualDuration - releaseTime);
            const finalReleaseTime = Math.max(actualStartTime + attackTime + decayTime, releaseStartTime);

            gainNode.gain.exponentialRampToValueAtTime(0.0001, finalReleaseTime);
            gainNode.gain.linearRampToValueAtTime(0, Math.max(actualStartTime, actualStartTime + actualDuration));

            oscillator.start(actualStartTime);
            oscillator.stop(Math.max(actualStartTime, actualStartTime + actualDuration));

            oscillator.onended = () => {
                oscillator.disconnect();
                gainNode.disconnect();
                filterNode.disconnect();
            };
        }

        /**
         * Plays a simple drum sound using a short, decaying sine wave.
         * @param {number} startTime - The AudioContext.currentTime when the drum sound should start.
         * @param {number} velocity - The velocity (0-1) of the drum hit.
         */
        function playDrum(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play drum: AudioContext or masterGainNode not available.");
                return;
            }

            const drumOscillator = audioContext.createOscillator();
            const drumGain = audioContext.createGain();
            const drumFilter = audioContext.createBiquadFilter();

            const actualStartTime = Math.max(0, startTime);

            drumOscillator.type = 'sine';
            drumOscillator.frequency.setValueAtTime(120, actualStartTime);
            drumOscillator.frequency.exponentialRampToValueAtTime(30, actualStartTime + 0.1);

            drumFilter.type = 'lowpass';
            drumFilter.frequency.setValueAtTime(500, actualStartTime);
            drumFilter.frequency.exponentialRampToValueAtTime(100, actualStartTime + 0.15);
            drumFilter.Q.setValueAtTime(0.8, actualStartTime);

            drumOscillator.connect(drumFilter);
            drumFilter.connect(drumGain);
            drumGain.connect(masterGainNode);

            drumGain.gain.setValueAtTime(kickVolume * velocity, actualStartTime);
            drumGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.2);

            drumOscillator.start(actualStartTime);
            drumOscillator.stop(actualStartTime + 0.2);

            drumOscillator.onended = () => {
                drumOscillator.disconnect();
                drumGain.disconnect();
                drumFilter.disconnect();
            };
        }

        /**
         * Plays a snare drum sound using white noise and an oscillator.
         * @param {number} startTime - The AudioContext.currentTime when the snare sound should start.
         * @param {number} velocity - The velocity (0-1) of the snare hit.
         */
        function playSnare(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play snare: AudioContext or masterGainNode not available.");
                return;
            }

            const actualStartTime = Math.max(0, startTime);

            const noise = audioContext.createBufferSource();
            const bufferSize = audioContext.sampleRate * 0.2;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(snareVolume * 0.7 * velocity, actualStartTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.15);
            noise.connect(noiseGain);

            const osc = audioContext.createOscillator();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, actualStartTime);
            osc.frequency.exponentialRampToValueAtTime(100, actualStartTime + 0.1);

            const oscGain = audioContext.createGain();
            oscGain.gain.setValueAtTime(snareVolume * 1.0 * velocity, actualStartTime);
            oscGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.1);
            osc.connect(oscGain);

            const mixer = audioContext.createGain();
            noiseGain.connect(mixer);
            oscGain.connect(mixer);
            mixer.connect(masterGainNode);

            noise.start(actualStartTime);
            osc.start(actualStartTime);
            noise.stop(actualStartTime + 0.2);
            osc.stop(actualStartTime + 0.2);

            osc.onended = () => {
                noise.disconnect();
                osc.disconnect();
                noiseGain.disconnect();
                oscGain.disconnect();
                mixer.disconnect();
            };
        }

        /**
         * Plays a closed hi-hat sound.
         * @param {number} startTime - The AudioContext.currentTime when the hi-hat sound should start.
         * @param {number} velocity - The velocity (0-1) of the hi-hat hit.
         */
        function playHiHatClosed(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) return;

            const actualStartTime = Math.max(0, startTime);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(10000, actualStartTime);
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(7000, actualStartTime);
            filter.Q.setValueAtTime(0.5, actualStartTime);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGainNode);

            gain.gain.setValueAtTime(hihatVolume * 0.7 * velocity, actualStartTime);
            gain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.05);

            osc.start(actualStartTime);
            osc.stop(actualStartTime + 0.05);

            osc.onended = () => {
                osc.disconnect(); 
                gain.disconnect();
                filter.disconnect();
            };
        }

        /**
         * Plays an open hi-hat sound.
         * @param {number} startTime - The AudioContext.currentTime when the hi-hat sound should start.
         * @param {number} velocity - The velocity (0-1) of the hi-hat hit.
         */
        function playHiHatOpen(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) return;

            const actualStartTime = Math.max(0, startTime);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(8000, actualStartTime);
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(5000, actualStartTime);
            filter.Q.setValueAtTime(0.5, actualStartTime);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGainNode);

            gain.gain.setValueAtTime(hihatVolume * 1.0 * velocity, actualStartTime);
            gain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.2);

            osc.start(actualStartTime);
            osc.stop(actualStartTime + 0.2);

            osc.onended = () => {
                osc.disconnect(); 
                gain.disconnect();
                filter.disconnect();
            };
        }

        /**
         * Plays an arpeggiated sequence of notes for the synth.
         * @param {Array<string>} notesArray - Array of note names.
         * @param {number} startTime - The AudioContext.currentTime when the arpeggio should start.
         * @param {number} totalDuration - The total duration the arpeggio should occupy.
         * @param {number} detuneValue - The detune value in cents.
         * @param {number} filterFreq - The cutoff frequency for the low-pass filter.
         * @param {number} filterQ - The Q factor for the low-pass filter.
         * @param {number} velocity - The base velocity for the arpeggio notes.
         */
        function playArpeggio(notesArray, startTime, totalDuration, detuneValue, filterFreq, filterQ, velocity) {
            if (!audioContext || notesArray.length === 0) return;

            const noteDuration = totalDuration / notesArray.length;
            let currentArpTime = startTime;

            notesArray.forEach(noteName => {
                const frequency = notes[noteName];
                if (frequency) {
                    const arpVelocity = velocity * (1 + (Math.random() - 0.5) * 0.2);
                    playNote(frequency, currentArpTime, noteDuration * 0.8, detuneValue, filterFreq, filterQ, 'synth', arpVelocity);
                }
                currentArpTime += noteDuration;
            });
        }

        /**
         * Applies subtle, random changes to various musical parameters for the next musical step.
         */
        function applySubtleChanges() {
            const driftScale = fibonacciDriftScales[currentFibonacciDriftScaleIndex];
            const interpolationFactor = 0.05;

            targetTempo += tempoDriftDirection * (Math.random() * driftScale * 10 + 2);
            if (targetTempo > 650) {
                tempoDriftDirection = -1;
            } else if (targetTempo < 380) {
                tempoDriftDirection = 1;
            }
            targetTempo = Math.max(300, Math.min(900, targetTempo));
            currentTempo += (targetTempo - currentTempo) * interpolationFactor;

            targetDetune += detuneDriftDirection * (Math.random() * driftScale * 2 + 0.5);
            if (targetDetune > 20) {
                detuneDriftDirection = -1;
            } else if (targetDetune < -20) {
                detuneDriftDirection = 1;
            }
            targetDetune = Math.max(-20, Math.min(20, targetDetune));
            currentDetune += (targetDetune - currentDetune) * interpolationFactor;

            targetFilterFrequency += filterDriftDirection * (Math.random() * driftScale * 100 + 20);
            if (targetFilterFrequency > 4000) {
                filterDriftDirection = -1;
            } else if (targetFilterFrequency < 400) {
                filterDriftDirection = 1;
            }
            targetFilterFrequency = Math.max(400, Math.min(4000, targetFilterFrequency));
            currentFilterFrequency += (targetFilterFrequency - currentFilterFrequency) * interpolationFactor;

            targetFilterQ += (Math.random() - 0.5) * driftScale * 0.8;
            targetFilterQ = Math.max(0.3, Math.min(4, targetFilterQ));
            currentFilterQ += (targetFilterQ - currentFilterQ) * interpolationFactor;

            targetBaseNoteDuration += (Math.random() - 0.5) * driftScale * 0.08;
            targetBaseNoteDuration = Math.max(0.2, Math.min(0.8, targetBaseNoteDuration));
            baseNoteDuration += (targetBaseNoteDuration - baseNoteDuration) * interpolationFactor;

            targetHumanizationFactor += (Math.random() - 0.5) * driftScale * 0.15;
            targetHumanizationFactor = Math.max(0.1, Math.min(1.0, targetHumanizationFactor));
            humanizationFactor += (targetHumanizationFactor - humanizationFactor) * interpolationFactor;

            targetDelayTimeValue += delayTimeDriftDirection * (Math.random() - 0.5) * driftScale * 0.05;
            if (targetDelayTimeValue > 1.5) {
                delayTimeDriftDirection = -1;
            } else if (targetDelayTimeValue < 0.05) {
                delayTimeDriftDirection = 1;
            }
            targetDelayTimeValue = Math.max(0.01, Math.min(2.0, targetDelayTimeValue));
            delayTimeValue += (targetDelayTimeValue - delayTimeValue) * interpolationFactor;
            if (audioContext && delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, audioContext.currentTime);

            targetDelayFeedbackValue += delayFeedbackDriftDirection * (Math.random() - 0.5) * driftScale * 0.03;
            if (targetDelayFeedbackValue > 0.9) {
                delayFeedbackDriftDirection = -1;
            } else if (targetDelayFeedbackValue < 0.05) {
                delayFeedbackDriftDirection = 1;
            }
            targetDelayFeedbackValue = Math.max(0, Math.min(0.95, targetDelayFeedbackValue));
            delayFeedbackValue += (targetDelayFeedbackValue - delayFeedbackValue) * interpolationFactor;
            if (audioContext && delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, audioContext.currentTime);
        }

        /**
         * The main audio scheduling loop.
         */
        function scheduler() {
            if (!isPlaying || !audioContext) {
                console.log("Scheduler stopping: isPlaying=", isPlaying, " audioContext=", audioContext);
                return;
            }

            while (nextNoteTime < audioContext.currentTime + 0.1) {
                const currentStep = currentSectionPhrase[currentPhraseIndex];
                
                if (!currentStep || typeof currentStep !== 'object' || !Array.isArray(currentStep.synth) || !Array.isArray(currentStep.bass) || typeof currentStep.percussion !== 'object' || currentStep.percussion === null) {
                    console.error(`Invalid or malformed currentStep at index ${currentPhraseIndex}:`, currentStep);
                    currentPhraseIndex = 0;
                    stepsPlayedInCurrentSection = currentSectionTotalSteps;
                    continue;
                }

                const duration = baseNoteDuration;
                const baseVelocity = 0.7 + (Math.random() * 0.3);

                const effectiveDelaySend = (currentStep.delaySend !== undefined ? currentStep.delaySend : 0.5) * delaySendLevel;
                if (audioContext && delaySendGain) {
                    delaySendGain.gain.linearRampToValueAtTime(effectiveDelaySend, audioContext.currentTime + 0.05);
                }

                if (currentStep.synth && currentStep.synth.length > 0) {
                    if (isSynthArpeggiatorActive) {
                        playArpeggio(currentStep.synth, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, baseVelocity);
                    } else {
                        currentStep.synth.forEach(noteName => {
                            const frequency = notes[noteName];
                            if (frequency) {
                                playNote(frequency, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, 'synth', baseVelocity);
                            } else {
                                console.warn(`Synth note frequency not found for note: ${noteName}`);
                            }
                        });
                    }
                }

                if (currentStep.bass && currentStep.bass.length > 0) {
                    currentStep.bass.forEach(noteName => {
                        const frequency = notes[noteName];
                        if (frequency) {
                            playNote(frequency, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, 'bass', baseVelocity);
                        } else {
                            console.warn(`Bass note frequency not found for note: ${noteName}`);
                        }
                    });
                }

                if (currentStep.percussion) {
                    if (currentStep.percussion.kick && currentStep.percussion.kick.active && Math.random() < currentStep.percussion.kick.probability) {
                        playDrum(nextNoteTime, currentStep.percussion.kick.velocity);
                    }
                    if (currentStep.percussion.snare && currentStep.percussion.snare.active && Math.random() < currentStep.percussion.snare.probability) {
                        playSnare(nextNoteTime, currentStep.percussion.snare.velocity);
                    }
                    if (currentStep.percussion.hihat && currentStep.percussion.hihat.active && Math.random() < currentStep.percussion.hihat.probability) {
                        if (currentStep.percussion.hihat.type === 'closed') {
                            playHiHatClosed(nextNoteTime, currentStep.percussion.hihat.velocity);
                        } else if (currentStep.percussion.hihat.type === 'open') {
                            playHiHatOpen(nextNoteTime, currentStep.percussion.hihat.velocity);
                        }
                    }
                }

                nextNoteTime += (currentTempo / 1000);
                
                stepsPlayedInCurrentSection++;
                currentPhraseIndex++;
                applySubtleChanges();

                if (currentPhraseIndex >= currentSectionPhrase.length) {
                    currentPhraseIndex = 0;
                }

                if (stepsPlayedInCurrentSection >= currentSectionTotalSteps) {
                    console.log(`End of section '${currentSectionName}' reached.`);
                    currentPhraseIndex = 0;
                    stepsPlayedInCurrentSection = 0;
                    currentSongSectionIndex++;

                    currentFibonacciDriftScaleIndex = (currentFibonacciDriftScaleIndex + 1) % fibonacciDriftScales.length;

                    if (currentSongSectionIndex >= songStructure.length) {
                        currentSongSectionIndex = 0;
                        songIterationCount++;
                        updateSongIterationDisplay();
                        console.log("End of song structure reached. Looping back to Intro. Song Iteration:", songIterationCount);
                    }

                    const nextSectionDef = songStructure[currentSongSectionIndex];
                    currentSectionType = nextSectionDef.type;
                    let phraseToUse = [];
                    
                    let previousKey = currentKey;
                    sectionsSinceLastKeyChange++;

                    if (sectionsSinceLastKeyChange >= sectionsPerKeyChange) {
                        currentKey = selectNextKey(previousKey);
                        sectionsSinceLastKeyChange = 0;
                        sectionsPerKeyChange = Math.floor(Math.random() * 3) + 2;
                        console.log(`Next key change will happen in ${sectionsPerKeyChange} sections.`);
                    } else {
                        showMessage(`Staying in ${currentKey} Major.`, 2500);
                    }

                    const semitonesToTranspose = keyToSemitoneOffsetFromC[currentKey] - keyToSemitoneOffsetFromC['C'];

                    if (currentSectionType === 'verse' && verseIterationCount % 2 === 0) {
                        const selectedRagaName = selectTimeAppropriateRaga();
                        currentSectionName = `raga${selectedRagaName.charAt(0).toUpperCase() + selectedRagaName.slice(1)}Phrase`;
                        
                        const selectedRagaScale = ragaScales[selectedRagaName];

                        if (selectedRagaScale && Array.isArray(selectedRagaScale) && selectedRagaScale.length > 0) {
                            const transposedRagaScale = transposeNotes(selectedRagaScale, semitonesToTranspose);
                            phraseToUse = generateRagaMelody(transposedRagaScale, 8, humanizationFactor);
                        } else {
                            console.error(`Invalid or empty Raga scale found for name: ${selectedRagaName}. Falling back to a default verse.`);
                            currentSectionName = getRandomNormalVerseVariation('verse1');
                            phraseToUse = musicalPhrases[currentSectionName].map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                        }
                    } else {
                        if (currentSectionType === 'verse') {
                            currentSectionName = getRandomNormalVerseVariation(nextSectionDef.baseName);
                        } else {
                            currentSectionName = nextSectionDef.type;
                        }
                        const basePhrase = musicalPhrases[currentSectionName];
                        if (basePhrase && Array.isArray(basePhrase)) {
                             phraseToUse = basePhrase.map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                        } else {
                            console.error(`Base phrase for section '${currentSectionName}' is undefined or not an array. Falling back to intro.`);
                            currentSectionName = 'intro';
                            phraseToUse = musicalPhrases.intro.map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                        }
                    }
                    
                    currentSectionPhrase = phraseToUse;

                    if (!currentSectionPhrase || currentSectionPhrase.length === 0) {
                        console.warn(`Section '${currentSectionName}' resulted in an empty phrase. Falling back to intro.`);
                        currentSectionName = 'intro';
                        currentSectionPhrase = musicalPhrases.intro.map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                        currentKey = songStructure[0].initialKey || 'C';
                        currentSectionTotalSteps = currentSectionPhrase.length * nextSectionDef.durationMultiplier;
                    }

                    currentSectionTotalSteps = currentSectionPhrase.length * nextSectionDef.durationMultiplier;

                    console.log(`Transitioning to section: ${currentSectionName} (type: ${currentSectionType}) in ${currentKey} Major for ${currentSectionTotalSteps} steps. Humanization Factor: ${humanizationFactor.toFixed(2)}`);
                    updateSectionDisplay();
                }
            }

            loopTimeoutId = setTimeout(scheduler, 50);
        }

        /**
         * Starts the music looping.
         */
        function startLoop() {
            console.log("Start button clicked. Attempting to start loop.");
            if (!initAudio()) {
                console.error("Audio initialization failed. Cannot start loop.");
                return;
            }

            if (audioContext.state === 'suspended') {
                console.log("AudioContext is suspended. Attempting to resume...");
                showMessage("Resuming audio context...");
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully!');
                    startLoopInternal();
                }).catch(e => {
                    showMessage("Could not resume audio context. Please try again or check browser settings.", 3000);
                    console.error("AudioContext resume error:", e);
                });
            } else {
                console.log("AudioContext is already running or pending. Starting loop directly.");
                startLoopInternal();
            }
        }

        /**
         * Internal function to start the music loop after audio context is ready.
         */
        function startLoopInternal() {
            if (isPlaying) {
                console.log("Loop is already playing. Skipping start.");
                return;
            }

            isPlaying = true;
            nextNoteTime = audioContext.currentTime;
            
            currentSongSectionIndex = 0;
            songIterationCount = 0;
            updateSongIterationDisplay();

            const initialSectionDef = songStructure[currentSongSectionIndex];
            currentSectionType = initialSectionDef.type;
            currentKey = initialSectionDef.initialKey || 'C';

            let initialPhraseToUse = [];
            const semitonesToTranspose = keyToSemitoneOffsetFromC[currentKey] - keyToSemitoneOffsetFromC['C'];

            if (currentSectionType === 'verse' && verseIterationCount % 2 === 0) {
                verseIterationCount = 1;
                currentSectionName = initialSectionDef.baseName + '_A';
                const basePhrase = musicalPhrases[currentSectionName];
                initialPhraseToUse = basePhrase.map(step => ({
                    ...step,
                    bass: transposeNotes(step.bass, semitonesToTranspose),
                    synth: transposeNotes(step.synth, semitonesToTranspose)
                }));
                console.log(`Forcing initial verse to start with: ${currentSectionName} in ${currentKey} Major`);
            } else {
                currentSectionName = initialSectionDef.type;
                const basePhrase = musicalPhrases[currentSectionName];
                initialPhraseToUse = basePhrase.map(step => ({
                    ...step,
                    bass: transposeNotes(step.bass, semitonesToTranspose),
                    synth: transposeNotes(step.synth, semitonesToTranspose)
                }));
            }

            currentSectionPhrase = initialPhraseToUse;

            shuffleArray(availableRagas);

            currentPhraseIndex = 0;
            stepsPlayedInCurrentSection = 0;
            sectionsSinceLastKeyChange = 0;
            sectionsPerKeyChange = Math.floor(Math.random() * 3) + 2;

            if (!currentSectionPhrase || currentSectionPhrase.length === 0) {
                console.warn(`Initial section phrase for '${currentSectionName}' is empty. Falling back to intro.`);
                currentSectionName = 'intro';
                currentSectionPhrase = musicalPhrases.intro.map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                currentKey = songStructure[0].initialKey || 'C';
                currentSectionTotalSteps = currentSectionPhrase.length * initialSectionDef.durationMultiplier;
            }

            currentSectionTotalSteps = currentSectionPhrase.length * initialSectionDef.durationMultiplier;

            updateSectionDisplay();
            console.log(`Starting with section: ${currentSectionName} (type: ${currentSectionType}) in ${currentKey} Major for ${currentSectionTotalSteps} steps. Humanization Factor: ${humanizationFactor.toFixed(2)}`);

            masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
            masterGainNode.gain.linearRampToValueAtTime(masterVolume, audioContext.currentTime + 4);

            scheduler();
            initializeVisualization();
            
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false;
            showMessage("Music started. Enjoy the evolving structured loop!");
            console.log("Music loop started.");
        }

        /**
         * Stops the music looping.
         */
        function stopLoop() {
            console.log("Stop button clicked. Attempting to stop loop.");
            isPlaying = false;
            clearTimeout(loopTimeoutId);

            if (audioContext && masterGainNode) {
                masterGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                masterGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
                setTimeout(() => {
                    if (audioContext && audioContext.state === 'running') {
                        audioContext.suspend().then(() => {
                            console.log('AudioContext suspended successfully!');
                            showMessage("Music stopped.");
                        }).catch(e => {
                            showMessage("Could not suspend audio context.", 3000);
                            console.error("AudioContext suspend error:", e);
                        });
                    } else {
                        console.log("AudioContext is not running or already suspended.");
                        showMessage("Music stopped.");
                    }
                }, 1000);
            } else {
                console.log("AudioContext or masterGainNode not available for smooth stop.");
                showMessage("Music stopped.");
            }
            
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            console.log("Music loop stopped.");
        }

        /**
         * The main drawing loop for audio visualization.
         */
        function initializeVisualization() {
            if (!analyserNode || !audioVisualizerCtx) return;
            
            drawVisualizationLoop();
        }

        /**
         * The main drawing loop for audio visualization.
         */
        function drawVisualizationLoop() {
            if (!isPlaying || !analyserNode || !audioVisualizerCtx) {
                if (audioVisualizerCtx) {
                    audioVisualizerCtx.clearRect(0, 0, audioVisualizerCanvas.width, audioVisualizerCanvas.height);
                }
                if (volumeMeterFillElement) {
                    volumeMeterFillElement.style.width = '0%';
                }
                if (volumePeakElement) {
                    volumePeakElement.style.opacity = 0;
                }
                return;
            }

            requestAnimationFrame(drawVisualizationLoop);

            const width = audioVisualizerCanvas.width;
            const height = audioVisualizerCanvas.height;

            analyserNode.getByteTimeDomainData(dataArray);
            analyserNode.getByteFrequencyData(frequencyDataArray);
            
            audioVisualizerCtx.fillStyle = '#000';
            audioVisualizerCtx.fillRect(0, 0, width, height);
            
            if (visualizationMode === 'spectrum') {
                const gradient = audioVisualizerCtx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(0.5, '#ffff00');
                gradient.addColorStop(1, '#00ff00');
                audioVisualizerCtx.fillStyle = gradient;
                
                const barWidth = width / analyserNode.frequencyBinCount;
                
                for(let i = 0; i < analyserNode.frequencyBinCount; i++) {
                    const barHeight = (frequencyDataArray[i] / 255) * height;
                    audioVisualizerCtx.fillRect(
                        i * barWidth,
                        height - barHeight,
                        barWidth - 1,
                        barHeight
                    );
                }
            } else if (visualizationMode === 'waveform') {
                audioVisualizerCtx.beginPath();
                audioVisualizerCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                audioVisualizerCtx.lineWidth = 2;
                
                const sliceWidth = width * 1.0 / dataArray.length;
                let x = 0;
                
                for(let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * height/2;
                    
                    if(i === 0) {
                        audioVisualizerCtx.moveTo(x, y);
                    } else {
                        audioVisualizerCtx.lineTo(x, y);
                    }
                    x += sliceWidth;
                }
                
                audioVisualizerCtx.lineTo(width, height/2);
                audioVisualizerCtx.stroke();
            } else if (visualizationMode === 'both') {
                const gradient = audioVisualizerCtx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(0.5, '#ffff00');
                gradient.addColorStop(1, '#00ff00');
                audioVisualizerCtx.fillStyle = gradient;
                
                const barWidth = width / analyserNode.frequencyBinCount;
                
                for(let i = 0; i < analyserNode.frequencyBinCount; i++) {
                    const barHeight = (frequencyDataArray[i] / 255) * height;
                    audioVisualizerCtx.fillRect(
                        i * barWidth,
                        height - barHeight,
                        barWidth - 1,
                        barHeight
                    );
                }

                audioVisualizerCtx.beginPath();
                audioVisualizerCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                audioVisualizerCtx.lineWidth = 2;
                
                const sliceWidth = width * 1.0 / dataArray.length;
                let x = 0;
                
                for(let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * height/2;
                    
                    if(i === 0) {
                        audioVisualizerCtx.moveTo(x, y);
                    } else {
                        audioVisualizerCtx.lineTo(x, y);
                    }
                    x += sliceWidth;
                }
                
                audioVisualizerCtx.lineTo(width, height/2);
                audioVisualizerCtx.stroke();
            } else if (visualizationMode === 'bands') {
                const nyquist = audioContext.sampleRate / 2;
                const binWidth = nyquist / analyserNode.frequencyBinCount;

                const bassMaxFreq = 250;
                const midMaxFreq = 2000;

                const bassEndBin = Math.floor(bassMaxFreq / binWidth);
                const midEndBin = Math.floor(midMaxFreq / binWidth);

                let bassEnergy = 0;
                let midEnergy = 0;
                let trebleEnergy = 0;

                for (let i = 0; i < analyserNode.frequencyBinCount; i++) {
                    const value = frequencyDataArray[i];
                    if (i <= bassEndBin) {
                        bassEnergy += value;
                    } else if (i <= midEndBin) {
                        midEnergy += value;
                    } else {
                        trebleEnergy += value;
                    }
                }

                const bassAvg = bassEndBin > 0 ? bassEnergy / bassEndBin : 0;
                const midAvg = (midEndBin - bassEndBin) > 0 ? midEnergy / (midEndBin - bassEndBin) : 0;
                const trebleAvg = (analyserNode.frequencyBinCount - midEndBin) > 0 ? trebleEnergy / (analyserNode.frequencyBinCount - midEndBin) : 0;

                const maxEnergy = 255;

                const barWidth = (width / 3) - 5;
                const spacing = 5;

                audioVisualizerCtx.fillStyle = `hsl(0, 100%, ${50 + (bassAvg / maxEnergy) * 40}%)`;
                const bassHeight = (bassAvg / maxEnergy) * height;
                audioVisualizerCtx.fillRect(spacing, height - bassHeight, barWidth, bassHeight);
                audioVisualizerCtx.fillText('Bass', spacing + barWidth / 2 - 15, height - bassHeight - 5);


                audioVisualizerCtx.fillStyle = `hsl(120, 100%, ${50 + (midAvg / maxEnergy) * 40}%)`;
                const midHeight = (midAvg / maxEnergy) * height;
                audioVisualizerCtx.fillRect(spacing * 2 + barWidth, height - midHeight, barWidth, midHeight);
                audioVisualizerCtx.fillText('Mid', spacing * 2 + barWidth / 2 + barWidth - 10, height - midHeight - 5);

                audioVisualizerCtx.fillStyle = `hsl(240, 100%, ${50 + (trebleAvg / maxEnergy) * 40}%)`;
                const trebleHeight = (trebleAvg / maxEnergy) * height;
                audioVisualizerCtx.fillRect(spacing * 3 + barWidth * 2, height - trebleHeight, barWidth, trebleHeight);
                audioVisualizerCtx.fillText('Treble', spacing * 3 + barWidth * 2 + barWidth / 2 - 20, height - trebleHeight - 5);
                
                audioVisualizerCtx.fillStyle = '#e0e0e0';
                audioVisualizerCtx.font = '10px Arial';
                audioVisualizerCtx.textAlign = 'center';
            }
            
            updateVolumeMeter();
        }

        /**
         * Updates the master volume meter and peak indicator.
         */
        function updateVolumeMeter() {
            if (!analyserNode || !volumeMeterFillElement || !volumePeakElement) return;
            
            let sum = 0;
            for(let i = 0; i < frequencyDataArray.length; i++) {
                sum += frequencyDataArray[i] * frequencyDataArray[i];
            }
            const rms = Math.sqrt(sum / frequencyDataArray.length);
            const volume = rms / 255;
            
            volumeMeterFillElement.style.width = `${volume * 100}%`;
            
            if (volume > peakValue) {
                peakValue = volume;
                volumePeakElement.style.right = `${(1 - peakValue) * 100}%`;
                volumePeakElement.style.opacity = '1';
                
                clearTimeout(volumePeakElement.fadeTimeout);
                volumePeakElement.fadeTimeout = setTimeout(() => {
                    volumePeakElement.style.opacity = '0.5';
                    clearTimeout(volumePeakElement.decayTimeout);
                    volumePeakElement.decayTimeout = setTimeout(() => {
                        peakValue *= 0.95;
                        if (peakValue < 0.01) peakValue = 0;
                    }, 500);
                }, 1000);
            }
        }


        /**
         * Manages saving and loading presets to/from local storage.
         */
        class PresetManager {
            constructor() {
                this.storageKeyPrefix = 'simple_relax_preset_';
                this.autoSaveKey = 'simple_relax_autosave_settings';
            }

            /**
             * Saves the current settings as a preset.
             * @param {string} name - The name of the preset.
             * @param {Object} settings - The settings object to save.
             * @returns {boolean} True if saved successfully, false otherwise.
             */
            savePreset(name, settings) {
                try {
                    const preset = {
                        settings: settings,
                        timestamp: Date.now(),
                        metadata: {
                            author: 'User',
                            description: `Saved at ${new Date().toLocaleString()}`,
                            tags: []
                        }
                    };
                    localStorage.setItem(this.storageKeyPrefix + name, JSON.stringify(preset));
                    return true;
                } catch (e) {
                    console.error('Preset save failed:', e);
                    return false;
                }
            }

            /**
             * Loads a preset by name.
             * @param {string} name - The name of the preset to load.
             * @returns {Object|null} The loaded settings object, or null if not found.
             */
            loadPreset(name) {
                try {
                    const presetString = localStorage.getItem(this.storageKeyPrefix + name);
                    if (presetString) {
                        const preset = JSON.parse(presetString);
                        return preset.settings;
                    }
                    return null;
                } catch (e) {
                    console.error('Preset load failed:', e);
                    return null;
                }
            }

            /**
             * Auto-saves the current settings.
             */
            autoSaveSettings() {
                try {
                    const settings = getCurrentSettings();
                    localStorage.setItem(this.autoSaveKey, JSON.stringify(settings));
                    console.log("Settings auto-saved.");
                } catch (e) {
                    console.warn("Auto-save failed:", e);
                }
            }

            /**
             * Loads auto-saved settings.
             * @returns {Object|null} The auto-saved settings, or null if none exist.
             */
            loadAutoSavedSettings() {
                try {
                    const settingsString = localStorage.getItem(this.autoSaveKey);
                    if (settingsString) {
                        return JSON.parse(settingsString);
                    }
                    return null;
                } catch (e) {
                    console.warn("Failed to load auto-saved settings:", e);
                    return null;
                }
            }

            /**
             * Exports all saved presets to a JSON file.
             */
            exportAllPresets() {
                try {
                    const allPresets = {};
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key.startsWith(this.storageKeyPrefix)) {
                            allPresets[key.replace(this.storageKeyPrefix, '')] = JSON.parse(localStorage.getItem(key));
                        }
                    }
                    const dataStr = JSON.stringify(allPresets, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `simple_relax_presets_${new Date().toISOString().replace(/:/g, '-')}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage("All presets exported successfully!");
                } catch (e) {
                    console.error("Failed to export presets:", e);
                    showMessage("Failed to export presets. See console for details.", 3000);
                }
            }

            /**
             * Imports presets from a JSON file.
             * @param {File} file - The JSON file containing presets.
             */
            importPresets(file) {
                if (!file) {
                    showMessage("No file selected for import.", 2000);
                    return;
                }
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedPresets = JSON.parse(event.target.result);
                        let importedCount = 0;
                        for (const name in importedPresets) {
                            if (importedPresets.hasOwnProperty(name) && importedPresets[name].settings) {
                                if (this.savePreset(name, importedPresets[name].settings)) {
                                    importedCount++;
                                }
                            }
                        }
                        showMessage(`Successfully imported ${importedCount} presets!`);
                    } catch (e) {
                        console.error("Failed to parse imported presets file:", e);
                        showMessage("Failed to import presets. Invalid file format.", 3000);
                    }
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e);
                    showMessage("Error reading file. Please try again.", 3000);
                };
                reader.readAsText(file);
            }
        }

        const presetManager = new PresetManager();

        /**
         * Collects all current knob values into an object.
         * @returns {Object} An object containing all current settings.
         */
        function getCurrentSettings() {
            return {
                masterVolume: parseFloat(document.getElementById('masterVolume').value),
                tempo: parseFloat(document.getElementById('tempo').value),
                bassVolume: parseFloat(document.getElementById('bassVolume').value),
                synthVolume: parseFloat(document.getElementById('synthVolume').value),
                kickVolume: parseFloat(document.getElementById('kickVolume').value),
                snareVolume: parseFloat(document.getElementById('snareVolume').value),
                hihatVolume: parseFloat(document.getElementById('hihatVolume').value),
                bassOscillatorType: document.getElementById('bassOscillatorType').value,
                synthOscillatorType: document.getElementById('synthOscillatorType').value,
                isSynthArpeggiatorActive: document.getElementById('synthArpeggiator').checked,
                delayTime: parseFloat(document.getElementById('delayTime').value),
                delayFeedback: parseFloat(document.getElementById('delayFeedback').value),
                delaySendLevel: parseFloat(document.getElementById('delaySendLevel').value),
                chorusDepth: parseFloat(document.getElementById('chorusDepth').value),
                isChorusBypassed: document.getElementById('chorusBypass').checked,
                targetDetune: targetDetune,
                targetFilterFrequency: targetFilterFrequency,
                targetFilterQ: targetFilterQ,
                targetBaseNoteDuration: targetBaseNoteDuration,
                targetHumanizationFactor: targetHumanizationFactor,
                targetDelayTimeValue: targetDelayTimeValue,
                targetDelayFeedbackValue: targetDelayFeedbackValue,
                compThreshold: parseFloat(document.getElementById('compThreshold').value),
                compRatio: parseFloat(document.getElementById('compRatio').value),
                reverbMix: parseFloat(document.getElementById('reverbMix').value),
                isReverbBypassed: document.getElementById('reverbBypass').checked,
                distortionAmount: parseFloat(document.getElementById('distortionAmount').value),
                isDistortionBypassed: document.getElementById('distortionBypass').checked,
                phaserRate: parseFloat(document.getElementById('phaserRate').value),
                phaserDepth: parseFloat(document.getElementById('phaserDepth').value),
                isPhaserBypassed: document.getElementById('phaserBypass').checked
            };
        }

        /**
         * Applies saved settings to the knobs and global variables.
         * @param {Object} settings - An object containing settings to apply.
         */
        function applySettings(settings) {
            document.getElementById('masterVolume').value = settings.masterVolume;
            document.getElementById('masterVolume').dispatchEvent(new Event('input'));

            document.getElementById('tempo').value = settings.tempo;
            document.getElementById('tempo').dispatchEvent(new Event('input'));

            document.getElementById('bassVolume').value = settings.bassVolume;
            document.getElementById('bassVolume').dispatchEvent(new Event('input'));

            document.getElementById('synthVolume').value = settings.synthVolume;
            document.getElementById('synthVolume').dispatchEvent(new Event('input'));

            document.getElementById('kickVolume').value = settings.kickVolume;
            document.getElementById('kickVolume').dispatchEvent(new Event('input'));

            document.getElementById('snareVolume').value = settings.snareVolume;
            document.getElementById('snareVolume').dispatchEvent(new Event('input'));

            document.getElementById('hihatVolume').value = settings.hihatVolume;
            document.getElementById('hihatVolume').dispatchEvent(new Event('input'));

            document.getElementById('bassOscillatorType').value = settings.bassOscillatorType;
            bassOscillatorType = settings.bassOscillatorType;
            document.getElementById('synthOscillatorType').value = settings.synthOscillatorType;
            synthOscillatorType = settings.synthOscillatorType;
            
            document.getElementById('synthArpeggiator').checked = settings.isSynthArpeggiatorActive;
            isSynthArpeggiatorActive = settings.isSynthArpeggiatorActive;

            document.getElementById('delayTime').value = settings.delayTime;
            document.getElementById('delayTime').dispatchEvent(new Event('input'));

            document.getElementById('delayFeedback').value = settings.delayFeedback;
            document.getElementById('delayFeedback').dispatchEvent(new Event('input'));

            document.getElementById('delaySendLevel').value = settings.delaySendLevel;
            document.getElementById('delaySendLevel').dispatchEvent(new Event('input'));

            document.getElementById('chorusDepth').value = settings.chorusDepth;
            document.getElementById('chorusDepth').dispatchEvent(new Event('input'));
            
            document.getElementById('chorusBypass').checked = settings.isChorusBypassed;
            document.getElementById('chorusBypass').dispatchEvent(new Event('change'));

            document.getElementById('compThreshold').value = settings.compThreshold;
            document.getElementById('compThreshold').dispatchEvent(new Event('input'));

            document.getElementById('compRatio').value = settings.compRatio;
            document.getElementById('compRatio').dispatchEvent(new Event('input'));
            
            document.getElementById('reverbMix').value = settings.reverbMix;
            document.getElementById('reverbMix').dispatchEvent(new Event('input'));

            document.getElementById('reverbBypass').checked = settings.isReverbBypassed;
            document.getElementById('reverbBypass').dispatchEvent(new Event('change'));

            document.getElementById('distortionAmount').value = settings.distortionAmount;
            document.getElementById('distortionAmount').dispatchEvent(new Event('input'));
            document.getElementById('distortionBypass').checked = settings.isDistortionBypassed;
            document.getElementById('distortionBypass').dispatchEvent(new Event('change'));

            document.getElementById('phaserRate').value = settings.phaserRate;
            document.getElementById('phaserRate').dispatchEvent(new Event('input'));
            document.getElementById('phaserDepth').value = settings.phaserDepth;
            document.getElementById('phaserDepth').dispatchEvent(new Event('input'));
            document.getElementById('phaserBypass').checked = settings.isPhaserBypassed;
            document.getElementById('phaserBypass').dispatchEvent(new Event('change'));

            currentDetune = settings.currentDetune;
            currentFilterFrequency = settings.currentFilterFrequency;
            currentFilterQ = settings.currentFilterQ;
            baseNoteDuration = settings.baseNoteDuration;
            humanizationFactor = settings.humanizationFactor;

            targetDetune = settings.targetDetune;
            targetFilterFrequency = settings.targetFilterFrequency;
            targetFilterQ = settings.targetFilterQ;
            targetBaseNoteDuration = settings.targetBaseNoteDuration;
            targetHumanizationFactor = settings.targetHumanizationFactor;
            targetDelayTimeValue = settings.targetDelayTimeValue;
            targetDelayFeedbackValue = settings.targetDelayFeedbackValue;


            showMessage("Preset loaded successfully!");
            console.log("Settings applied:", settings);
        }

        /**
         * Saves the current knob settings to local storage using PresetManager.
         */
        function savePreset() {
            const presetNameInput = document.getElementById('presetNameInput');
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                showMessage("Please enter a name for your preset.", 2000);
                return;
            }

            if (localStorage.getItem(presetManager.storageKeyPrefix + presetName)) {
                const confirmOverwrite = () => {
                    const confirmBox = document.createElement('div');
                    confirmBox.style.cssText = `
                        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        background-color: #3a3a3a; padding: 20px; border-radius: 10px;
                        box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 1000;
                        color: #e0e0e0; text-align: center;
                    `;
                    confirmBox.innerHTML = `
                        <p>Preset "${presetName}" already exists. Do you want to overwrite it?</p>
                        <button id="confirmOverwriteYes" class="secondary" style="margin-right: 10px;">Yes</button>
                        <button id="confirmOverwriteNo" class="secondary">No</button>
                    `;
                    document.body.appendChild(confirmBox);

                    document.getElementById('confirmOverwriteYes').onclick = () => {
                        document.body.removeChild(confirmBox);
                        const settings = getCurrentSettings();
                        if (presetManager.savePreset(presetName, settings)) {
                            showMessage(`Preset "${presetName}" saved!`);
                            console.log(`Preset "${presetName}" saved:`, settings);
                        } else {
                            showMessage("Failed to save preset. Local storage might be full or unavailable.", 3000);
                        }
                    };
                    document.getElementById('confirmOverwriteNo').onclick = () => {
                        document.body.removeChild(confirmBox);
                        showMessage("Preset save cancelled.", 2000);
                    };
                };
                confirmOverwrite();
                return;
            }

            const settings = getCurrentSettings();
            if (presetManager.savePreset(presetName, settings)) {
                showMessage(`Preset "${presetName}" saved!`);
                console.log(`Preset "${presetName}" saved:`, settings);
            } else {
                showMessage("Failed to save preset. Local storage might be full or unavailable.", 3000);
            }
        }

        /**
         * Loads a preset from local storage and applies its settings using PresetManager.
         */
        function loadPreset() {
            const presetNameInput = document.getElementById('presetNameInput');
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                showMessage("Please enter the name of the preset to load.", 2000);
                return;
            }
            const settings = presetManager.loadPreset(presetName);
            if (settings) {
                applySettings(settings);
            } else {
                showMessage(`Preset "${presetName}" not found.`, 2000);
                console.warn(`Preset "${presetName}" not found.`);
            }
        }
        
        // Enhanced LooperRecorder Class
        class EnhancedLooperRecorder {
            constructor(audioContext) {
                this.audioContext = audioContext;
                this.mediaRecorder = null;
                this.chunks = [];
                this.isRecording = false;
                this.recordingStartTime = 0;
                this.recordingMeter = document.querySelector('.recording-meter');
                this.recordingFormatSelect = document.getElementById('recordingFormat');
                this.selectedFormat = this.recordingFormatSelect ? this.recordingFormatSelect.value : 'wav';
                
                if (typeof MediaRecorder !== 'undefined') {
                    this.initializeRecorder();
                } else {
                    showMessage('MediaRecorder is not supported in this browser. Recording feature unavailable.', 5000);
                    console.warn('MediaRecorder is not supported.');
                }

                if (this.recordingFormatSelect) {
                    this.recordingFormatSelect.addEventListener('change', (e) => {
                        this.selectedFormat = e.target.value;
                        if (this.selectedFormat === 'mp3') {
                            showMessage('MP3 recording is not natively supported by browsers. Recording will be saved as WebM.', 5000);
                        }
                    });
                }
            }
            
            async initializeRecorder() {
                if (!analyserNode) {
                    console.error("AnalyserNode not available for recording initialization.");
                    showMessage("Audio system not ready for recording. Please start music first.", 3000);
                    return;
                }

                const dest = this.audioContext.createMediaStreamDestination();
                analyserNode.connect(dest);
                
                try {
                    this.mediaRecorder = new MediaRecorder(dest.stream);
                    this.mediaRecorder.ondataavailable = e => this.chunks.push(e.data);
                    this.mediaRecorder.onstop = () => this.processRecording();
                } catch (err) {
                    console.error('Failed to initialize MediaRecorder:', err);
                    showMessage('Recording initialization failed. Please try a different browser or check permissions.');
                }
            }
            
            startRecording() {
                if (!this.mediaRecorder) {
                    showMessage("Recording system not ready. Please try again.", 3000);
                    return;
                }
                if (this.isRecording) {
                    showMessage("Already recording!", 2000);
                    return;
                }
                if (this.selectedFormat === 'mp3') {
                    showMessage('MP3 recording is not natively supported. Recording in WAV format.', 4000);
                    this.selectedFormat = 'wav';
                }

                this.chunks = [];
                this.recordingStartTime = Date.now();
                this.isRecording = true;
                
                if (this.recordingMeter) {
                    this.recordingMeter.classList.add('active');
                }

                let countdown = 3;
                const countdownInterval = setInterval(() => {
                    if (this.recordingMeter) {
                        this.recordingMeter.textContent = `Recording starts in: ${countdown}s`;
                    }
                    countdown--;
                    if (countdown < 0) {
                        clearInterval(countdownInterval);
                        this.mediaRecorder.start();
                        this.updateRecordingTime();
                        showMessage('Recording started!');
                        console.log("Recording started.");
                    }
                }, 1000);
            }
            
            stopRecording() {
                if (!this.isRecording) {
                    showMessage("Not currently recording.", 2000);
                    return;
                }
                
                this.mediaRecorder.stop();
                this.isRecording = false;
                if (this.recordingMeter) {
                    this.recordingMeter.classList.remove('active');
                    this.recordingMeter.textContent = '';
                }
                
                showMessage('Recording stopped. Preparing download...');
                console.log("Recording stopped.");
            }
            
            updateRecordingTime() {
                if (!this.isRecording || !this.recordingMeter) return;
                
                const duration = (Date.now() - this.recordingStartTime) / 1000;
                this.recordingMeter.textContent = `Recording: ${duration.toFixed(1)}s`;
                requestAnimationFrame(() => this.updateRecordingTime());
            }
            
            async processRecording() {
                const mimeType = this.selectedFormat === 'wav' ? 'audio/wav' : 'audio/webm';
                const blob = new Blob(this.chunks, { type: mimeType }); 
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `simple_relax_loop_${new Date().toISOString().replace(/:/g, '-')}.${this.selectedFormat === 'wav' ? 'wav' : 'webm'}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
                showMessage("Recording downloaded!", 3000);
                console.log("Recording download initiated.");
            }
        }

        // Add Recording Controls to UI
        function addRecordingControls() {
            const recordButton = document.getElementById('recordButton');
            const stopButton = document.getElementById('stopButton');
            const startButton = document.getElementById('startButton');

            if (recordButton) {
                recordButton.addEventListener('click', () => {
                    if (!audioContext) {
                        showMessage("Please start the music loop first to initialize audio.", 3000);
                        return;
                    }
                    
                    if (!looperRecorder) {
                        looperRecorder = new EnhancedLooperRecorder(audioContext);
                    }

                    if (looperRecorder.isRecording) {
                        looperRecorder.stopRecording();
                        recordButton.innerHTML = '<i class="fas fa-microphone"></i> Start Recording';
                        if (!isPlaying) {
                            startButton.disabled = false;
                            stopButton.disabled = true;
                        }
                    } else {
                        looperRecorder.startRecording();
                        recordButton.innerHTML = '<i class="fas fa-stop"></i> Stop Recording';
                    }
                });
            }
        }

        // MODAL FUNCTIONS
        let activeModal = null; // Track the currently open modal

        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'flex'; // Use flex to center
                activeModal = modal;
            }
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
                if (activeModal === modal) {
                    activeModal = null;
                }
            }
        }

        // Keyboard Controls Initialization
        function initializeKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                
                const startButton = document.getElementById('startButton');
                const stopButton = document.getElementById('stopButton');
                const recordButton = document.getElementById('recordButton');
                const chorusBypassCheckbox = document.getElementById('chorusBypass');
                const reverbBypassCheckbox = document.getElementById('reverbBypass');
                const distortionBypassCheckbox = document.getElementById('distortionBypass');
                const phaserBypassCheckbox = document.getElementById('phaserBypass');
                const synthArpeggiatorCheckbox = document.getElementById('synthArpeggiator');

                switch(e.code) {
                    case 'Space':
                    case 'Enter':
                        e.preventDefault();
                        if (isPlaying) {
                            stopButton.click();
                        } else {
                            startButton.click();
                        }
                        break;
                    case 'Escape': // Close active modal on Escape key
                        if (activeModal) {
                            closeModal(activeModal.id);
                        }
                        break;
                    case 'KeyR':
                        if (e.ctrlKey) {
                            e.preventDefault();
                            recordButton.click();
                        } else {
                             e.preventDefault();
                             reverbBypassCheckbox.checked = !reverbBypassCheckbox.checked;
                             reverbBypassCheckbox.dispatchEvent(new Event('change'));
                        }
                        break;
                    case 'KeyC':
                        e.preventDefault();
                        chorusBypassCheckbox.checked = !chorusBypassCheckbox.checked;
                        chorusBypassCheckbox.dispatchEvent(new Event('change'));
                        break;
                    case 'KeyD':
                        e.preventDefault();
                        distortionBypassCheckbox.checked = !distortionBypassCheckbox.checked;
                        distortionBypassCheckbox.dispatchEvent(new Event('change'));
                        break;
                    case 'KeyP':
                        e.preventDefault();
                        phaserBypassCheckbox.checked = !phaserBypassCheckbox.checked;
                        phaserBypassCheckbox.dispatchEvent(new Event('change'));
                        break;
                    case 'KeyA':
                        e.preventDefault();
                        synthArpeggiatorCheckbox.checked = !synthArpeggiatorCheckbox.checked;
                        synthArpeggiatorCheckbox.dispatchEvent(new Event('change'));
                        break;
                    case 'KeyM':
                        const volKnob = document.getElementById('masterVolume');
                        if (volKnob) {
                            if (parseFloat(volKnob.value) > 0) {
                                volKnob.dataset.lastValue = volKnob.value;
                                volKnob.value = 0;
                            } else {
                                volKnob.value = volKnob.dataset.lastValue || 0.55;
                            }
                            volKnob.dispatchEvent(new Event('input'));
                            showMessage(`Master Volume: ${parseFloat(volKnob.value) === 0 ? 'Muted' : 'Unmuted'}`, 1500);
                        }
                        break;
                    case 'ArrowUp':
                    case 'ArrowDown':
                        if (e.target.tagName === 'INPUT' && e.target.type === 'range') {
                            e.preventDefault();
                            const knob = e.target;
                            const step = e.shiftKey ? parseFloat(knob.step) : (knob.id === 'tempo' ? 10 : 0.01);
                            const direction = e.code === 'ArrowUp' ? 1 : -1;
                            let newValue = parseFloat(knob.value) + (direction * step);

                            newValue = Math.min(parseFloat(knob.max), Math.max(parseFloat(knob.min), newValue));
                            knob.value = newValue;
                            knob.dispatchEvent(new Event('input'));
                            showMessage(`${knob.labels[0].textContent}: ${knob.nextElementSibling.textContent}`, 1000);
                        } else {
                            const tempoKnob = document.getElementById('tempo');
                            if (tempoKnob) {
                                e.preventDefault();
                                const step = e.shiftKey ? 1 : 10;
                                const direction = e.code === 'ArrowUp' ? 1 : -1;
                                tempoKnob.value = Math.min(parseFloat(tempoKnob.max), Math.max(parseFloat(tempoKnob.min), parseInt(tempoKnob.value) + (direction * step)));
                                tempoKnob.dispatchEvent(new Event('input'));
                                showMessage(`Tempo: ${tempoKnob.value} ms`, 1000);
                            }
                        }
                        break;
                    case 'Digit1':
                    case 'Digit2':
                    case 'Digit3':
                    case 'Digit4':
                    case 'Digit5':
                    case 'Digit6':
                    case 'Digit7':
                    case 'Digit8':
                    case 'Digit9':
                        e.preventDefault();
                        const presetNumber = parseInt(e.key);
                        const presetName = `Preset ${presetNumber}`;
                        document.getElementById('presetNameInput').value = presetName;
                        loadPreset();
                        break;
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Attaching event listeners.");
            document.getElementById('startButton').addEventListener('click', startLoop);
            document.getElementById('stopButton').addEventListener('click', stopLoop);
            document.getElementById('savePresetButton').addEventListener('click', savePreset);
            document.getElementById('loadPresetButton').addEventListener('click', loadPreset);
            document.getElementById('exportPresetsButton').addEventListener('click', () => presetManager.exportAllPresets());
            document.getElementById('importPresetsButton').addEventListener('click', () => {
                document.getElementById('importPresetsInput').click();
            });
            document.getElementById('importPresetsInput').addEventListener('change', (event) => {
                if (event.target.files.length > 0) {
                    presetManager.importPresets(event.target.files[0]);
                }
            });
            
            document.querySelectorAll('input[type="range"]').forEach(knob => {
                knob.addEventListener('input', (e) => {
                    updateAudioParameter(e.target.id, parseFloat(e.target.value));
                });
            });

            document.querySelectorAll('select').forEach(select => {
                select.addEventListener('change', (e) => {
                    updateAudioParameter(e.target.id, e.target.value);
                    showMessage(`${e.target.labels ? e.target.labels[0].textContent : e.target.id}: ${e.target.value}`);
                });
            });

            document.getElementById('chorusBypass').addEventListener('change', (event) => {
                isChorusBypassed = event.target.checked;
                updateChorusBypassConnection();
                showMessage(`Chorus is now ${isChorusBypassed ? 'bypassed' : 'active'}.`);
            });

            document.getElementById('reverbBypass').addEventListener('change', (event) => {
                isReverbBypassed = event.target.checked;
                updateReverbBypassConnection();
                showMessage(`Reverb is now ${isReverbBypassed ? 'bypassed' : 'active'}.`);
            });

            document.getElementById('distortionBypass').addEventListener('change', (event) => {
                isDistortionBypassed = event.target.checked;
                updateDistortionBypassConnection();
                showMessage(`Distortion is now ${isDistortionBypassed ? 'bypassed' : 'active'}.`);
            });

            document.getElementById('phaserBypass').addEventListener('change', (event) => {
                isPhaserBypassed = event.target.checked;
                updatePhaserBypassConnection();
                showMessage(`Phaser is now ${isPhaserBypassed ? 'bypassed' : 'active'}.`);
            });

            document.getElementById('synthArpeggiator').addEventListener('change', (event) => {
                isSynthArpeggiatorActive = event.target.checked;
                showMessage(`Synth Arpeggiator is now ${isSynthArpeggiatorActive ? 'active' : 'inactive'}.`);
            });

            // Visualization mode buttons
            document.getElementById('visModeSpectrum').addEventListener('click', () => {
                visualizationMode = 'spectrum';
                document.querySelectorAll('.visualization-controls button').forEach(btn => btn.classList.remove('active'));
                document.getElementById('visModeSpectrum').classList.add('active');
                showMessage('Visualization: Spectrum');
            });
            document.getElementById('visModeWaveform').addEventListener('click', () => {
                visualizationMode = 'waveform';
                document.querySelectorAll('.visualization-controls button').forEach(btn => btn.classList.remove('active'));
                document.getElementById('visModeWaveform').classList.add('active');
                showMessage('Visualization: Waveform');
            });
            document.getElementById('visModeBoth').addEventListener('click', () => {
                visualizationMode = 'both';
                document.querySelectorAll('.visualization-controls button').forEach(btn => btn.classList.remove('active'));
                document.getElementById('visModeBoth').classList.add('active');
                showMessage('Visualization: Both');
            });
            document.getElementById('visModeBands').addEventListener('click', () => {
                visualizationMode = 'bands';
                document.querySelectorAll('.visualization-controls button').forEach(btn => btn.classList.remove('active'));
                document.getElementById('visModeBands').classList.add('active');
                showMessage('Visualization: Frequency Bands');
            });

            // Modal Trigger Buttons
            document.getElementById('openMasterControlsModal').addEventListener('click', () => openModal('masterControlsModal'));
            document.getElementById('openInstrumentGainsModal').addEventListener('click', () => openModal('instrumentGainsModal'));
            document.getElementById('openInstrumentTimbresModal').addEventListener('click', () => openModal('instrumentTimbresModal'));
            document.getElementById('openEffectsModal').addEventListener('click', () => openModal('effectsModal'));
            document.getElementById('openCompressorModal').addEventListener('click', () => openModal('compressorModal'));
            document.getElementById('openReverbModal').addEventListener('click', () => openModal('reverbModal'));
            document.getElementById('openDistortionModal').addEventListener('click', () => openModal('distortionModal'));
            document.getElementById('openPhaserModal').addEventListener('click', () => openModal('phaserModal'));

            // Close buttons for modals
            document.querySelectorAll('.modal .close-button').forEach(button => {
                button.addEventListener('click', (e) => closeModal(e.target.closest('.modal').id));
            });

            // Close modal when clicking outside content
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) { // Only close if clicking on the overlay itself
                        closeModal(modal.id);
                    }
                });
            });


            document.querySelectorAll('input[type="range"]').forEach(knob => {
                updateAudioParameter(knob.id, parseFloat(knob.value));
            });
            document.querySelectorAll('select').forEach(select => {
                updateAudioParameter(select.id, select.value);
            });
            updateDistortionBypassConnection();
            updatePhaserBypassConnection();
            updateChorusBypassConnection();
            updateReverbBypassConnection();

            updateSectionDisplay();
            updateSongIterationDisplay();

            initializeKeyboardControls();
            addRecordingControls();

            const autoSavedSettings = presetManager.loadAutoSavedSettings();
            if (autoSavedSettings) {
                applySettings(autoSavedSettings);
                showMessage("Auto-saved settings loaded.", 2000);
            }

            window.addEventListener('beforeunload', () => {
                presetManager.autoSaveSettings();
            });
        });
    </script>
</body>
</html>
