<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Relax Looper</title>
    <style>
        /* Apply Inter font and basic styling to the body */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter as per instructions */
            display: flex;
            justify-content: center; /* Center content horizontally */
            align-items: flex-start; /* Align items to the top */
            min-height: 100vh; /* Ensure it takes full viewport height */
            background-color: #1a1a1a; /* Dark background for ambient feel */
            color: #e0e0e0; /* Light text color */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px; /* Space between the left panel and main content */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Main layout container for left panel and central content */
        .main-layout-container {
            display: flex;
            flex-direction: row; /* Controls on left, main content on right */
            gap: 20px;
            width: 100%;
            max-width: 1200px; /* Max width for the entire layout */
            justify-content: center; /* Center the layout within the body */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Left panel for knobs */
        .left-panel {
            flex: 0 0 250px; /* Fixed width for the left panel, no shrinking */
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Central content container (formerly 'container') */
        .central-content {
            flex: 1; /* Take remaining space */
            min-width: 300px; /* Minimum width for central content */
            background-color: #2a2a2a;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Styling for the main heading */
        h1 {
            color: #90ee90; /* Light green for "Weed" theme */
            margin-bottom: 10px; /* Reduced margin */
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(144, 238, 144, 0.6); /* Glow effect */
        }
        /* Styling for buttons */
        button {
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px; /* Rounded corners for buttons */
            cursor: pointer;
            font-size: 1.2em;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; /* Smooth transitions */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Button shadow */
            outline: none; /* Remove outline on focus */
        }
        /* Hover effects for buttons */
        button:hover {
            background-color: #45a049;
            transform: translateY(-2px); /* Slight lift effect */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        /* Active (click) effects for buttons */
        button:active {
            background-color: #3e8e41;
            transform: translateY(0); /* Return to original position */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        /* Styling for disabled buttons */
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        /* Styling for the custom message box */
        .message-box {
            background-color: #3a3a3a;
            color: #fff;
            padding: 15px;
            border-radius: 8px; /* Rounded corners */
            margin-top: 20px;
            font-size: 0.9em;
            display: none; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        /* Class to show the message box */
        .message-box.show {
            display: block;
            opacity: 1;
        }
        /* Styling for paragraph text */
        p {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        /* Styling for current section display */
        #currentSectionDisplay {
            margin-top: 10px;
            font-size: 1.3em;
            color: #a0ffa0;
            font-weight: bold;
            transition: color 0.3s ease; /* Smooth color transition for highlight */
        }
        /* Highlight for current section */
        #currentSectionDisplay.highlight {
            color: #ffcc00; /* Yellowish highlight */
            text-shadow: 0 0 8px rgba(255, 204, 0, 0.6); /* Subtle glow */
        }
        /* Flex container for control buttons */
        .controls {
            display: flex;
            gap: 15px; /* Space between buttons */
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Styling for knob sections */
        .knob-section {
            background-color: #3a3a3a;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Responsive grid for knobs */
            gap: 15px;
        }
        .knob-section h3 {
            color: #90ee90;
            margin-top: 0;
            margin-bottom: 10px;
            grid-column: 1 / -1; /* Span across all columns */
        }
        .knob-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .knob-group label {
            font-size: 0.9em;
            color: #ccc;
        }
        .knob-group input[type="range"] {
            width: 100px; /* Fixed width for sliders */
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #555;
            outline: none;
            border-radius: 5px;
            transition: background 0.2s;
        }
        .knob-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #90ee90;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(144, 238, 144, 0.5);
        }
        .knob-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #90ee90;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(144, 238, 144, 0.5);
        }
        .knob-value {
            font-size: 0.8em;
            color: #a0ffa0;
        }

        /* Audio Visualizer */
        #audioVisualizer {
            background-color: #000;
            border: 1px solid #4CAF50;
            border-radius: 8px;
            margin-top: 20px;
            width: 100%; /* Make it responsive */
            max-width: 400px; /* Max width for desktop */
            height: 100px; /* Fixed height */
        }

        /* Volume Meter */
        .volume-meter-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            gap: 10px;
        }
        .volume-meter-label {
            font-size: 0.9em;
            color: #ccc;
        }
        #volumeMeter {
            width: 150px;
            height: 15px;
            background-color: #555;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #4CAF50;
        }
        #volumeMeterFill {
            height: 100%;
            width: 0%; /* Starts empty */
            background-color: #90ee90;
            transition: width 0.05s ease-out; /* Smooth transition for volume changes */
        }
        #volumePeak {
            position: absolute;
            height: 100%;
            width: 2px; /* Thin line for peak */
            background-color: #ff0000; /* Red for peak */
            right: 0; /* Initially at the right, will move with peak */
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }

        /* Preset controls */
        .preset-controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        .preset-controls input[type="text"] {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            width: 80%;
            max-width: 200px;
        }
        .preset-controls button {
            padding: 10px 20px;
            font-size: 1em;
            width: 100%;
            max-width: 200px;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            color: #ccc;
            font-size: 0.9em;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-layout-container {
                flex-direction: column; /* Stack panels vertically on small screens */
                align-items: center;
            }
            .left-panel, .central-content {
                width: 95%; /* Make panels take more width */
                flex: none; /* Remove flex grow/shrink */
            }
            #audioVisualizer {
                width: 95%; /* Make visualizer wider on small screens */
            }
        }
    </style>
</head>
<body>
    <div class="main-layout-container">
        <div class="left-panel">
            <div class="knob-section">
                <h3>Master Controls</h3>
                <div class="knob-group">
                    <label for="masterVolume">Master Volume</label>
                    <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.55">
                    <span class="knob-value" id="masterVolumeValue">0.55</span>
                </div>
                <div class="knob-group">
                    <label for="tempo">Tempo (ms)</label>
                    <input type="range" id="tempo" min="300" max="900" step="10" value="420">
                    <span class="knob-value" id="tempoValue">420</span>
                </div>
            </div>

            <div class="knob-section">
                <h3>Instrument Gains</h3>
                <div class="knob-group">
                    <label for="bassVolume">Bass Volume</label>
                    <input type="range" id="bassVolume" min="0" max="0.5" step="0.01" value="0.13">
                    <span class="knob-value" id="bassVolumeValue">0.13</span>
                </div>
                <div class="knob-group">
                    <label for="synthVolume">Synth Volume</label>
                    <input type="range" id="synthVolume" min="0" max="0.5" step="0.01" value="0.08">
                    <span class="knob-value" id="synthVolumeValue">0.08</span>
                </div>
                <div class="knob-group">
                    <label for="kickVolume">Kick Volume</label>
                    <input type="range" id="kickVolume" min="0" max="1" step="0.01" value="0.89">
                    <span class="knob-value" id="kickVolumeValue">0.89</span>
                </div>
                <div class="knob-group">
                    <label for="snareVolume">Snare Volume</label>
                    <input type="range" id="snareVolume" min="0" max="0.3" step="0.01" value="0.21">
                    <span class="knob-value" id="snareVolumeValue">0.21</span>
                </div>
                <div class="knob-group">
                    <label for="hihatVolume">Hi-Hat Volume</label>
                    <input type="range" id="hihatVolume" min="0" max="0.3" step="0.01" value="0.21">
                    <span class="knob-value" id="hihatVolumeValue">0.21</span>
                </div>
            </div>

            <div class="knob-section">
                <h3>Effects</h3>
                <div class="knob-group">
                    <label for="delayTime">Delay Time (s)</label>
                    <input type="range" id="delayTime" min="0.01" max="2.0" step="0.01" value="0.3">
                    <span class="knob-value" id="delayTimeValue">0.30</span>
                </div>
                <div class="knob-group">
                    <label for="delayFeedback">Delay Feedback</label>
                    <input type="range" id="delayFeedback" min="0" max="0.95" step="0.01" value="0.4">
                    <span class="knob-value" id="delayFeedbackValue">0.40</span>
                </div>
                <div class="knob-group">
                    <label for="delaySendLevel">Delay Send</label>
                    <input type="range" id="delaySendLevel" min="0" max="1.0" step="0.01" value="0.5">
                    <span class="knob-value" id="delaySendLevelValue">0.50</span>
                </div>
                <div class="knob-group">
                    <label for="chorusDepth">Chorus Depth</label>
                    <input type="range" id="chorusDepth" min="0" max="0.01" step="0.0001" value="0.002">
                    <span class="knob-value" id="chorusDepthValue">0.002</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="chorusBypass" checked>
                    <label for="chorusBypass">Bypass Chorus</label>
                </div>
            </div>

            <!-- New Compressor Controls -->
            <div class="knob-section">
                <h3>Compressor</h3>
                <div class="knob-group">
                    <label for="compThreshold">Threshold</label>
                    <input type="range" id="compThreshold" min="-60" max="0" step="1" value="-24">
                    <span class="knob-value" id="compThresholdValue">-24 dB</span>
                </div>
                <div class="knob-group">
                    <label for="compRatio">Ratio</label>
                    <input type="range" id="compRatio" min="1" max="20" step="0.1" value="12">
                    <span class="knob-value" id="compRatioValue">12:1</span>
                </div>
            </div>

            <!-- New Reverb Controls -->
            <div class="knob-section">
                <h3>Reverb</h3>
                <div class="knob-group">
                    <label for="reverbMix">Mix</label>
                    <input type="range" id="reverbMix" min="0" max="1" step="0.01" value="0.5">
                    <span class="knob-value" id="reverbMixValue">50%</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="reverbBypass" checked>
                    <label for="reverbBypass">Bypass Reverb</label>
                </div>
            </div>

        </div>

        <div class="central-content">
            <h1>Simple Relax Looper</h1>
            <p>Experience a subtly evolving ambient track designed for relaxation.</p>
            <div class="controls">
                <button id="startButton">Start Looping</button>
                <button id="stopButton" disabled>Stop Looping</button>
            </div>
            <div id="currentSectionDisplay">Current Section: --</div>
            <div id="messageBox" class="message-box"></div>

            <!-- Audio Visualization Canvas -->
            <canvas id="audioVisualizer" width="400" height="100"></canvas>

            <!-- Master Volume Meter -->
            <div class="volume-meter-container">
                <span class="volume-meter-label">Master Volume:</span>
                <div id="volumeMeter" style="position: relative;">
                    <div id="volumeMeterFill"></div>
                    <div id="volumePeak"></div>
                </div>
            </div>

            <!-- Preset Controls -->
            <div class="preset-controls knob-section">
                <h3>Presets</h3>
                <input type="text" id="presetNameInput" placeholder="Enter preset name">
                <button id="savePresetButton">Save Preset</button>
                <button id="loadPresetButton">Load Preset</button>
            </div>

            <!-- New Recording Controls -->
            <div class="controls recording-controls">
                <button id="recordButton">Start Recording</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables for the Web Audio API context and nodes
        let audioContext;
        let masterGainNode;
        let isPlaying = false; // Flag to track if audio is currently playing
        let nextNoteTime = 0; // The time when the next note should be scheduled
        let loopTimeoutId; // ID for the setTimeout that schedules the next audio event

        // Musical parameters controlled by knobs - initialized to default values
        let masterVolume = 0.55;
        let bassVolume = 0.13;
        let synthVolume = 0.08;
        let kickVolume = 0.89;
        let snareVolume = 0.21;
        let hihatVolume = 0.21;

        let currentTempo = 420;
        let currentDetune = 0;
        let currentFilterFrequency = 1000;
        let currentFilterQ = 1;
        let baseNoteDuration = 0.5;

        // Global variables for filter and detune drift (still apply subtle background changes)
        let filterDriftDirection = 1;
        let detuneDriftDirection = 1;
        let delayTimeDriftDirection = 1;
        let delayFeedbackDriftDirection = 1;

        // Fibonacci-influenced drift scale factors for dynamic parameters
        const fibonacciDriftScales = [0.1, 0.2, 0.3, 0.5, 0.8, 1.3, 2.1];
        let currentFibonacciDriftScaleIndex = 0;

        // Humanization intensity factor, also influenced by Fibonacci drift
        let humanizationFactor = 0.5;

        // Delay effect nodes and parameters
        let delayNode;
        let delayFeedbackGain;
        let delaySendGain;
        let delayTimeValue = 0.3;
        let delayFeedbackValue = 0.4;
        let delaySendLevel = 0.5;

        // Chorus effect nodes and parameters
        let chorusNode;
        let chorusLFO;
        let chorusLfoGain;
        let chorusDepth = 0.002; // Default chorus depth (delay time modulation amount)
        let isChorusBypassed = true; // Default to bypassed

        // New: Compressor nodes and parameters
        let compressorNode;
        let compThreshold = -24;
        let compRatio = 12;

        // New: Reverb nodes and parameters
        let convolverNode;
        let reverbGainNode;
        let dryGainNode;
        let reverbMix = 0.5;
        let isReverbBypassed = true;

        // New: Recording
        let looperRecorder;

        // Visualizer and Volume Meter elements
        let analyserNode;
        let audioVisualizerCanvas;
        let audioVisualizerCtx;
        let volumeMeterElement;
        let volumeMeterFillElement;
        let volumePeakElement; // For peak indicator
        let dataArray; // For analyser data
        let peakValue = 0; // Stores the highest volume peak

        // For cycling through verse patterns (normal and Raga)
        const normalVerseOptions = {
            verse1: ['verse1_A', 'verse1_B', 'verse1_C', 'verse1_D'],
            verse2: ['verse2_A', 'verse2_B', 'verse2_C', 'verse2_D'],
            verse3: ['verse3_A', 'verse3_B', 'verse3_C']
        };
        // Updated: Added more Raga scales
        const ragaVerseOptions = ['ragaYamanPhrase', 'ragaBhairaviPhrase', 'ragaBhoopaliPhrase', 'ragaKhamajPhrase'];
        let availableRagas = [...ragaVerseOptions];
        let normalVerseIndex = 0;
        let verseIterationCount = 0;

        // Predefined frequencies for a simple musical scale
        const notes = {
            'A1': 55.00, 'A#1': 58.27, 'B1': 61.74,
            'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 97.99, 'G#2': 103.83,
            'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65,
            'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30,
            'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25
        };

        // New Raga scale definitions (using C as tonic for simplicity)
        const ragaScales = {
            yaman: ['C4', 'D4', 'E4', 'F#4', 'G4', 'A4', 'B4', 'C5'],
            bhairavi: ['C4', 'C#4', 'D#4', 'F4', 'G4', 'G#4', 'A#4', 'C5'],
            // New Raga scales
            bhoopali: ['C4', 'D4', 'E4', 'G4', 'A4', 'C5'], // Pentatonic scale
            khamaj: ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'A#4', 'C5'] // Natural minor with major 7th
        };

        /**
         * Generates a melodic phrase within a given Raga scale, with expressive variations.
         * @param {Array<string>} scale - Array of note names in the Raga scale (e.g., ['C4', 'D4', 'E4']).
         * @param {number} phraseLength - Number of steps in the phrase (e.g., 8).
         * @param {number} humanizationFactor - A factor influencing how "busy" or sparse the melody is (0-1).
         * @returns {Array<Object>} An array of phrase steps.
         */
        function generateRagaMelody(scale, phraseLength, humanizationFactor) {
            const generatedPhrase = [];
            let currentNoteIndex = Math.floor(Math.random() * scale.length);
            let lastDirection = Math.random() < 0.5 ? 1 : -1;

            // Ensure scale has enough elements before accessing specific indices
            const vadiNote = scale[0];
            const samvadiNote = scale.length > 4 ? scale[4] : scale[scale.length - 1]; // Fallback for scales with less than 5 notes

            for (let i = 0; i < phraseLength; i++) {
                const step = {
                    bass: [],
                    synth: [],
                    percussion: {},
                    delaySend: 0.3 + (Math.random() * 0.3)
                };

                // Bass Line Generation
                if (i % 4 === 0) {
                    step.bass.push(scale[0].replace('4', '2'));
                } else if (i % 2 === 0 && Math.random() < 0.6) {
                    const bassOptions = [scale[0].replace('4', '2'), (scale.length > 4 ? scale[4] : scale[scale.length -1]).replace('4', '2')];
                    if (scale.length > 5 && Math.random() < 0.3) {
                        bassOptions.push(scale[2].replace('4', '2'));
                    }
                    step.bass.push(bassOptions[Math.floor(Math.random() * bassOptions.length)]);
                }
                if (step.bass.length === 0) {
                    step.bass.push(scale[0].replace('4', '2'));
                }

                // Synth Melody Generation
                const numSynthNotes = 1 + Math.floor(Math.random() * (humanizationFactor * 2));
                
                for (let j = 0; j < numSynthNotes; j++) {
                    let nextNoteIndex = currentNoteIndex;

                    if (Math.random() < 0.3 + (humanizationFactor * 0.2)) {
                        lastDirection *= -1;
                    }

                    const moveType = Math.random();
                    let moveAmount = 0;

                    if (moveType < 0.7) {
                        moveAmount = 1;
                    } else if (moveType < 0.9) {
                        moveAmount = Math.random() < 0.5 ? 2 : 3;
                    } else {
                        moveAmount = Math.random() < 0.5 ? 4 : 5;
                    }

                    nextNoteIndex = (currentNoteIndex + lastDirection * moveAmount + scale.length * 2) % scale.length;
                    
                    const currentNoteFreq = notes[scale[currentNoteIndex]];
                    const vadiFreq = notes[vadiNote];
                    const samvadiFreq = notes[samvadiNote];

                    if (Math.abs(currentNoteFreq - vadiFreq) > 50 && Math.random() < 0.4) {
                        lastDirection = (currentNoteFreq < vadiFreq) ? 1 : -1;
                        nextNoteIndex = scale.indexOf(vadiNote);
                    } else if (samvadiNote && Math.abs(currentNoteFreq - samvadiFreq) > 50 && Math.random() < 0.2) {
                        lastDirection = (currentNoteFreq < samvadiFreq) ? 1 : -1;
                        nextNoteIndex = scale.indexOf(samvadiNote);
                    }

                    currentNoteIndex = nextNoteIndex;

                    let synthNote = scale[currentNoteIndex];
                    const currentOctave = parseInt(synthNote.slice(-1));
                    if (Math.random() < 0.3 * humanizationFactor) {
                        if (Math.random() < 0.5 && currentOctave < 5) {
                            synthNote = synthNote.slice(0, -1) + (currentOctave + 1);
                        } else if (currentOctave > 3) {
                            synthNote = synthNote.slice(0, -1) + (currentOctave - 1);
                        }
                    }
                    step.synth.push(synthNote);
                }
                if (step.synth.length === 0) {
                    step.synth.push(scale[currentNoteIndex]);
                }

                // Percussion: Use fixed probabilities for percussion in generated Raga melodies
                if (i === 0 || i === 4) { // Kick on 1 and 5
                    if (Math.random() < 0.9) { // 90% probability for kick
                        step.percussion.kick = { active: true, velocity: 1.0 };
                    }
                }
                if (i === 2 || i === 6) { // Snare on 3 and 7
                    if (Math.random() < 0.8) { // 80% probability for snare
                        step.percussion.snare = { active: true, velocity: 1.0 };
                    }
                }
                if (i % 2 === 0) { // On every other beat, hi-hat
                    if (Math.random() < 1.0) { // 100% probability for hi-hat
                        step.percussion.hihat = { active: true, type: 'closed', velocity: 0.8 }; // Slightly lower velocity for closed hi-hat
                    }
                    }

                generatedPhrase.push(step);
            }
            return generatedPhrase;
        }


        // Define musical phrases for each section of the song
        // Percussion now includes 'active', 'probability', and 'velocity' for dynamic sequencing
        const musicalPhrases = {
            intro: [
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.8 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.7 },
                { bass: ['E2'], synth: ['E4'], percussion: {}, delaySend: 0.6 },
                { bass: ['E2'], synth: ['E4'], percussion: {}, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4'], percussion: {}, delaySend: 0.4 },
                { bass: ['C3'], synth: ['C4'], percussion: {}, delaySend: 0.3 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.2 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.1 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: {}, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: {}, delaySend: 0.0 },
                { bass: ['E2'], synth: ['E4', 'G4'], percussion: {}, delaySend: 0.0 },
                { bass: ['E2'], synth: ['E4', 'G4'], percussion: {}, delaySend: 0.0 },
                { bass: ['C3'], synth: ['C4', 'E4'], percussion: {}, delaySend: 0.0 },
                { bass: ['C3'], synth: ['C4', 'E4'], percussion: {}, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: {}, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: {}, delaySend: 0.0 }
            ],
            verse1_A: [
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3', 'C4', 'F4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_B: [
                { bass: ['C2'], synth: ['E4', 'G4', 'C5'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3', 'D4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4', 'E4', 'A4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3', 'C4', 'F4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_C: [
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_D: [
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } } },
                { bass: ['G2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 }
            ],
            verse2_A: [
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_B: [
                { bass: ['F2'], synth: ['C4', 'F4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['G3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['D4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['E4', 'A4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_C: [
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            ragaYamanPhrase: [],
            ragaBhairaviPhrase: [],
            ragaBhoopaliPhrase: [], // New Raga phrase placeholder
            ragaKhamajPhrase: [],   // New Raga phrase placeholder
            
            chorus: [
                { bass: ['A2'], synth: ['A4', 'C5', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['A2'], synth: ['C5'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['G2'], synth: ['G4', 'B4', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['G2'], synth: ['B4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['C3'], synth: ['C4', 'E4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['C3'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['F2'], synth: ['F4', 'A4', 'C5'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['F2'], synth: ['A4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 }
            ],
            bridge: [
                { bass: ['D2'], synth: ['D4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 },
                { bass: ['E2'], synth: ['E4', 'G4', 'B4'], percussion: {}, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3', 'D4', 'G4'], percussion: {}, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 },
                { bass: ['D2'], synth: ['D4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 },
                { bass: ['E2'], synth: ['E4', 'G4', 'B4'], percussion: {}, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3', 'D4', 'G4'], percussion: {}, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 }
            ],
            outro: [
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: {}, delaySend: 0.8 },
                { bass: ['A2'], synth: ['E4'], percussion: {}, delaySend: 0.7 },
                { bass: ['C3'], synth: ['C4', 'G3'], percussion: {}, delaySend: 0.6 },
                { bass: ['C3'], synth: ['G3'], percussion: {}, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.4 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.3 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.2 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.0 }
            ]
        };

        const songStructure = [
            { type: 'intro', durationMultiplier: 2 },
            { type: 'verse', baseName: 'verse1', durationMultiplier: 3 },
            { type: 'chorus', durationMultiplier: 2 },
            { type: 'verse', baseName: 'verse2', durationMultiplier: 3 },
            { type: 'verse', baseName: 'verse3', durationMultiplier: 5 },
            { type: 'bridge', durationMultiplier: 2 },
            { type: 'chorus', durationMultiplier: 3 },
            { type: 'verse', baseName: 'verse1', durationMultiplier: 2 },
            { type: 'outro', durationMultiplier: 2 }
        ];

        let currentSongSectionIndex = 0;
        let currentSectionType = '';
        let currentSectionName = '';
        let currentSectionPhrase = [];
        let currentPhraseIndex = 0;
        let stepsPlayedInCurrentSection = 0;
        let currentSectionTotalSteps = 0;

        /**
         * Shuffles an array in place (Fisher-Yates algorithm).
         * @param {Array} array - The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * Gets the next Raga phrase from the available pool, ensuring non-repetition until all are played.
         * @returns {string} The name of the next Raga phrase.
         */
        function getNextRagaPhrase() {
            if (availableRagas.length === 0) {
                availableRagas = [...ragaVerseOptions];
                shuffleArray(availableRagas);
                console.log("Raga pool reset and shuffled:", availableRagas);
            }
            const nextRaga = availableRagas.shift();
            console.log("Next Raga:", nextRaga, "Remaining Ragas:", availableRagas);
            return nextRaga;
        }

        /**
         * Selects a random variation for a given normal verse base name.
         * @param {string} baseName - The base name of the verse (e.g., 'verse1').
         * @returns {string} The name of the selected verse variation (e.g., 'verse1_A').
         */
        function getRandomNormalVerseVariation(baseName) {
            const variations = normalVerseOptions[baseName];
            if (!variations || variations.length === 0) {
                console.warn(`No variations found for normal verse: ${baseName}`);
                return baseName;
            }
            const randomIndex = Math.floor(Math.random() * variations.length);
            return variations[randomIndex];
        }

        /**
         * Updates the display with the current song section and applies a highlight.
         */
        function updateSectionDisplay() {
            const displayElement = document.getElementById('currentSectionDisplay');
            if (displayElement) {
                if (displayElement.textContent !== `Current Section: ${currentSectionName.toUpperCase()}`) {
                     displayElement.classList.remove('highlight');
                }
                displayElement.textContent = `Current Section: ${currentSectionName.toUpperCase()}`;
                requestAnimationFrame(() => {
                    displayElement.classList.add('highlight');
                });
            }
        }

        /**
         * Displays a temporary message to the user in a dedicated message box.
         * @param {string} message - The text message to display.
         * @param {number} duration - How long the message should be visible in milliseconds.
         */
        function showMessage(message, duration = 3000) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }

        /**
         * Initializes the Web Audio API context and the master gain node.
         * This function needs to be called after a user gesture (e.g., button click)
         * to comply with browser autoplay policies.
         * @returns {boolean} True if audio context was successfully initialized or already exists, false otherwise.
         */
        function initAudio() {
            console.log("Attempting to initialize audio context...");
            if (!audioContext) {
                try {
                    showMessage("Initializing audio system...");
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = masterVolume;
                    
                    // Delay setup
                    delayNode = audioContext.createDelay(2.0);
                    delayFeedbackGain = audioContext.createGain();
                    delaySendGain = audioContext.createGain();

                    // Chorus setup
                    chorusNode = audioContext.createDelay(0.01); // Max delay for chorus, typically very small
                    chorusLFO = audioContext.createOscillator();
                    chorusLfoGain = audioContext.createGain();

                    chorusLFO.type = 'sine';
                    chorusLFO.frequency.value = 1.5; // LFO frequency for chorus modulation
                    chorusLfoGain.gain.value = chorusDepth; // Modulation depth
                    
                    chorusLFO.connect(chorusLfoGain);
                    chorusLfoGain.connect(chorusNode.delayTime);
                    chorusLFO.start(audioContext.currentTime); // Start LFO immediately

                    // Compressor setup
                    compressorNode = audioContext.createDynamicsCompressor();
                    compressorNode.threshold.value = compThreshold;
                    compressorNode.knee.value = 30; // Default value, not exposed to UI
                    compressorNode.ratio.value = compRatio;
                    compressorNode.attack.value = 0.003; // Default value
                    compressorNode.release.value = 0.25; // Default value

                    // Reverb setup
                    convolverNode = audioContext.createConvolver();
                    reverbGainNode = audioContext.createGain();
                    dryGainNode = audioContext.createGain();

                    // Create a simple synthetic impulse response for reverb
                    const impulseLength = 2; // seconds
                    const sampleRate = audioContext.sampleRate;
                    const impulseBuffer = audioContext.createBuffer(2, sampleRate * impulseLength, sampleRate);
                    const leftChannel = impulseBuffer.getChannelData(0);
                    const rightChannel = impulseBuffer.getChannelData(1);

                    for (let i = 0; i < sampleRate * impulseLength; i++) {
                        // Simple decaying noise burst
                        leftChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / (sampleRate * impulseLength), 2);
                        rightChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / (sampleRate * impulseLength), 2);
                    }
                    convolverNode.buffer = impulseBuffer;
                    reverbGainNode.gain.value = reverbMix;
                    dryGainNode.gain.value = 1 - reverbMix; // Initial dry mix

                    // Analyser Node for Visualization and Volume Meter
                    analyserNode = audioContext.createAnalyser();
                    analyserNode.fftSize = 256;
                    analyserNode.smoothingTimeConstant = 0.8; // Smoother visualization
                    analyserNode.minDecibels = -90;
                    analyserNode.maxDecibels = -10;
                    const bufferLength = analyserNode.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);

                    // Connect nodes:
                    // Master -> Delay Send -> Delay -> Destination
                    // Master -> Compressor -> (Dry Signal / Reverb Wet Signal) -> Analyser -> Destination
                    
                    // Main audio path: Master -> Compressor
                    masterGainNode.connect(compressorNode);

                    // Delay path: Master -> Delay Send -> Delay -> Destination
                    masterGainNode.connect(delaySendGain);
                    delaySendGain.connect(delayNode);
                    delayNode.connect(audioContext.destination);

                    // Reverb path: Compressor -> (Dry Gain / Convolver + Reverb Gain) -> Analyser
                    // Disconnect analyser from masterGainNode if it was connected directly
                    try {
                        masterGainNode.disconnect(analyserNode);
                    } catch (e) { /* ignore */ }

                    // Connect compressor to dry and wet reverb paths
                    compressorNode.connect(dryGainNode);
                    dryGainNode.connect(analyserNode); // Dry signal to analyser

                    compressorNode.connect(convolverNode);
                    convolverNode.connect(reverbGainNode);
                    reverbGainNode.connect(analyserNode); // Wet signal to analyser

                    // Analyser always connects to destination
                    analyserNode.connect(audioContext.destination);

                    // Initialize UI elements for visualization and volume meter
                    audioVisualizerCanvas = document.getElementById('audioVisualizer');
                    audioVisualizerCtx = audioVisualizerCanvas.getContext('2d');
                    volumeMeterElement = document.getElementById('volumeMeter');
                    volumeMeterFillElement = document.getElementById('volumeMeterFill');
                    volumePeakElement = document.getElementById('volumePeak');

                    // Set initial values for delay
                    delayNode.delayTime.value = delayTimeValue;
                    delayFeedbackGain.gain.value = delayFeedbackValue;
                    delaySendGain.gain.value = delaySendLevel;

                    // Initialize recorder
                    looperRecorder = new LooperRecorder(audioContext);

                    showMessage(`Audio context initialized. Master Gain: ${masterVolume.toFixed(2)}`);
                    console.log("AudioContext initialized successfully. State:", audioContext.state);
                } catch (e) {
                    showMessage("Web Audio API is not supported in this browser or could not be initialized. Please try a different browser.", 5000);
                    console.error("Web Audio API error:", e);
                    return false;
                }
            } else {
                console.log("AudioContext already exists. State:", audioContext.state);
            }
            return true;
        }

        /**
         * Plays a single musical note using an oscillator and applies a simple ADSR envelope,
         * detune, and a low-pass filter.
         * @param {number} frequency - The frequency of the note in Hz.
         * @param {number} startTime - The AudioContext.currentTime when the note should start.
         * @param {number} duration - The duration of the note in seconds.
         * @param {number} detuneValue - The detune value in cents.
         * @param {number} filterFreq - The cutoff frequency for the low-pass filter.
         * @param {number} filterQ - The Q factor for the low-pass filter.
         * @param {string} instrumentType - 'bass' or 'synth' to determine timbre.
         */
        function playNote(frequency, startTime, duration, detuneValue = currentDetune, filterFreq = currentFilterFrequency, filterQ = currentFilterQ, instrumentType = 'synth') {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play note: AudioContext or masterGainNode not available.");
                return;
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();

            const timingOffset = (Math.random() - 0.5) * 0.08 * humanizationFactor;
            const dynamicFactor = 1 + (Math.random() - 0.5) * 0.6 * humanizationFactor;
            const durationFactor = 1 + (Math.random() - 0.5) * 0.3 * humanizationFactor;

            const actualStartTime = Math.max(0, startTime + timingOffset);
            const actualDuration = duration * durationFactor;

            let attackTime = 0.05;
            let decayTime = 0.2;
            let sustainLevel = 0.5;
            let releaseTime = 0.2;
            let initialGain = synthVolume;
            let oscType = 'sine';

            switch (instrumentType) {
                case 'bass':
                    oscType = 'triangle';
                    attackTime = 0.02;
                    decayTime = 0.3;
                    sustainLevel = 0.5;
                    releaseTime = 0.2;
                    initialGain = bassVolume;
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(400, actualStartTime);
                    filterNode.Q.setValueAtTime(0.8, actualStartTime);
                    break;
                case 'synth':
                default:
                    oscType = 'sine';
                    attackTime = 0.1;
                    decayTime = 0.5;
                    sustainLevel = 0.6;
                    releaseTime = 0.8;
                    initialGain = synthVolume;
                    filterNode.type = 'lowpass';
                    
                    const initialFilterFreq = filterFreq * (1 + (Math.random() - 0.5) * 0.2 * humanizationFactor);
                    const finalFilterFreq = filterFreq;
                    filterNode.frequency.setValueAtTime(initialFilterFreq, actualStartTime);
                    filterNode.frequency.linearRampToValueAtTime(finalFilterFreq, actualStartTime + 0.5);
                    
                    filterNode.Q.setValueAtTime(filterQ, actualStartTime);
                    break;
            }

            oscillator.type = oscType;
            oscillator.frequency.setValueAtTime(frequency, actualStartTime);
            oscillator.detune.setValueAtTime(detuneValue, actualStartTime);

            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(masterGainNode);

            gainNode.gain.setValueAtTime(0, actualStartTime);
            gainNode.gain.linearRampToValueAtTime(initialGain * dynamicFactor, actualStartTime + attackTime);
            gainNode.gain.linearRampToValueAtTime(initialGain * dynamicFactor * sustainLevel, actualStartTime + attackTime + decayTime);

            const releaseStartTime = Math.max(actualStartTime, actualStartTime + actualDuration - releaseTime);
            const finalReleaseTime = Math.max(actualStartTime + attackTime + decayTime, releaseStartTime);

            gainNode.gain.exponentialRampToValueAtTime(0.0001, finalReleaseTime);
            gainNode.gain.linearRampToValueAtTime(0, Math.max(actualStartTime, actualStartTime + actualDuration));

            oscillator.start(actualStartTime);
            oscillator.stop(Math.max(actualStartTime, actualStartTime + actualDuration));

            oscillator.onended = () => {
                oscillator.disconnect();
                gainNode.disconnect();
                filterNode.disconnect();
            };
        }

        /**
         * Plays a simple drum sound using a short, decaying sine wave.
         * @param {number} startTime - The AudioContext.currentTime when the drum sound should start.
         * @param {number} velocity - The velocity (0-1) of the drum hit.
         */
        function playDrum(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play drum: AudioContext or masterGainNode not available.");
                return;
            }

            const drumOscillator = audioContext.createOscillator();
            const drumGain = audioContext.createGain();
            const drumFilter = audioContext.createBiquadFilter();

            const actualStartTime = Math.max(0, startTime);

            drumOscillator.type = 'sine';
            drumOscillator.frequency.setValueAtTime(80, actualStartTime);
            drumOscillator.frequency.exponentialRampToValueAtTime(30, actualStartTime + 0.1);

            drumFilter.type = 'lowpass';
            drumFilter.frequency.setValueAtTime(500, actualStartTime);
            drumFilter.frequency.exponentialRampToValueAtTime(100, actualStartTime + 0.15);
            drumFilter.Q.setValueAtTime(1, actualStartTime);

            drumOscillator.connect(drumFilter);
            drumFilter.connect(drumGain);
            drumGain.connect(masterGainNode);

            drumGain.gain.setValueAtTime(kickVolume * velocity, actualStartTime); // Apply velocity
            drumGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.2);

            drumOscillator.start(actualStartTime);
            drumOscillator.stop(actualStartTime + 0.2);

            drumOscillator.onended = () => {
                drumOscillator.disconnect();
                drumGain.disconnect();
                drumFilter.disconnect();
            };
        }

        /**
         * Plays a snare drum sound using white noise and an oscillator.
         * @param {number} startTime - The AudioContext.currentTime when the snare sound should start.
         * @param {number} velocity - The velocity (0-1) of the snare hit.
         */
        function playSnare(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play snare: AudioContext or masterGainNode not available.");
                return;
            }

            const actualStartTime = Math.max(0, startTime);

            const noise = audioContext.createBufferSource();
            const bufferSize = audioContext.sampleRate * 0.2;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(snareVolume * 0.7 * velocity, actualStartTime); // Apply velocity
            noiseGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.15);
            noise.connect(noiseGain);

            const osc = audioContext.createOscillator();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, actualStartTime);
            osc.frequency.exponentialRampToValueAtTime(100, actualStartTime + 0.1);

            const oscGain = audioContext.createGain();
            oscGain.gain.setValueAtTime(snareVolume * 1.0 * velocity, actualStartTime); // Apply velocity
            oscGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.1);
            osc.connect(oscGain);

            const mixer = audioContext.createGain();
            noiseGain.connect(mixer);
            oscGain.connect(mixer);
            mixer.connect(masterGainNode);

            noise.start(actualStartTime);
            osc.start(actualStartTime);
            noise.stop(actualStartTime + 0.2);
            osc.stop(actualStartTime + 0.2);

            osc.onended = () => {
                noise.disconnect();
                osc.disconnect();
                noiseGain.disconnect();
                oscGain.disconnect();
                mixer.disconnect();
            };
        }

        /**
         * Plays a closed hi-hat sound.
         * @param {number} startTime - The AudioContext.currentTime when the hi-hat sound should start.
         * @param {number} velocity - The velocity (0-1) of the hi-hat hit.
         */
        function playHiHatClosed(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) return;

            const actualStartTime = Math.max(0, startTime);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(10000, actualStartTime);
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(7000, actualStartTime);
            filter.Q.setValueAtTime(0.5, actualStartTime);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGainNode);

            gain.gain.setValueAtTime(hihatVolume * 0.7 * velocity, actualStartTime); // Apply velocity
            gain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.05);

            osc.start(actualStartTime);
            osc.stop(actualStartTime + 0.05);

            osc.onended = () => {
                osc.disconnect();
                gain.disconnect();
                filter.disconnect();
            };
        }

        /**
         * Plays an open hi-hat sound.
         * @param {number} startTime - The AudioContext.currentTime when the hi-hat sound should start.
         * @param {number} velocity - The velocity (0-1) of the hi-hat hit.
         */
        function playHiHatOpen(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) return;

            const actualStartTime = Math.max(0, startTime);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(8000, actualStartTime);
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(5000, actualStartTime);
            filter.Q.setValueAtTime(0.5, actualStartTime);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGainNode);

            gain.gain.setValueAtTime(hihatVolume * 1.0 * velocity, actualStartTime); // Apply velocity
            gain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.2);

            osc.start(actualStartTime);
            osc.stop(actualStartTime + 0.2);

            osc.onended = () => {
                osc.disconnect();
                gain.disconnect();
                filter.disconnect();
            };
        }

        /**
         * Applies subtle, random changes to various musical parameters for the next musical step.
         * These changes are applied on top of the user-controlled knob values.
         */
        function applySubtleChanges() {
            const driftScale = fibonacciDriftScales[currentFibonacciDriftScaleIndex];

            currentDetune += detuneDriftDirection * (Math.random() * driftScale * 1.5 + (driftScale / 2));
            if (currentDetune > 12) {
                detuneDriftDirection = -1;
            } else if (currentDetune < -12) {
                detuneDriftDirection = 1;
            }
            currentDetune = Math.max(-12, Math.min(12, currentDetune));

            currentFilterFrequency += filterDriftDirection * (Math.random() * driftScale * 50 + 10);
            if (currentFilterFrequency > 3000) {
                filterDriftDirection = -1;
            } else if (currentFilterFrequency < 500) {
                filterDriftDirection = 1;
            }
            currentFilterFrequency = Math.max(500, Math.min(3000, currentFilterFrequency));

            currentFilterQ += (Math.random() - 0.5) * driftScale * 0.5;
            currentFilterQ = Math.max(0.5, Math.min(3, currentFilterQ));

            baseNoteDuration += (Math.random() - 0.5) * driftScale * 0.05;
            baseNoteDuration = Math.max(0.3, Math.min(0.7, baseNoteDuration));

            humanizationFactor += (Math.random() - 0.5) * driftScale * 0.1;
            humanizationFactor = Math.max(0.1, Math.min(1.0, humanizationFactor));

            delayTimeValue += delayTimeDriftDirection * (Math.random() - 0.5) * driftScale * 0.02;
            if (delayTimeValue > 1.0) {
                delayTimeDriftDirection = -1;
            } else if (delayTimeValue < 0.1) {
                delayTimeDriftDirection = 1;
            }
            delayTimeValue = Math.max(0.01, Math.min(2.0, delayTimeValue));
            if (delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, audioContext.currentTime);

            delayFeedbackValue += delayFeedbackDriftDirection * (Math.random() - 0.5) * driftScale * 0.01;
            if (delayFeedbackValue > 0.8) {
                delayFeedbackDriftDirection = -1;
            } else if (delayFeedbackValue < 0.1) {
                delayFeedbackDriftDirection = 1;
            }
            delayFeedbackValue = Math.max(0, Math.min(0.95, delayFeedbackValue));
            if (delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, audioContext.currentTime);
        }

        /**
         * The main audio scheduling loop. It continuously checks if there are events
         * to be played in the near future and schedules them using AudioContext.currentTime.
         * This method is more precise than setTimeout for timing musical events.
         */
        function scheduler() {
            if (!isPlaying || !audioContext) {
                console.log("Scheduler stopping: isPlaying=", isPlaying, " audioContext=", audioContext);
                return;
            }

            while (nextNoteTime < audioContext.currentTime + 0.1) {
                const currentStep = currentSectionPhrase[currentPhraseIndex];
                
                // Robust check for currentStep and its essential properties
                if (!currentStep || typeof currentStep !== 'object' || !Array.isArray(currentStep.synth) || !Array.isArray(currentStep.bass) || typeof currentStep.percussion !== 'object' || currentStep.percussion === null) {
                    console.error(`Invalid or malformed currentStep at index ${currentPhraseIndex}:`, currentStep);
                    // Attempt to recover by forcing a section transition
                    currentPhraseIndex = 0; // Reset index for the new section
                    stepsPlayedInCurrentSection = currentSectionTotalSteps; // Force transition
                    continue; // Skip to the next iteration of the while loop
                }

                const duration = baseNoteDuration;

                const effectiveDelaySend = (currentStep.delaySend !== undefined ? currentStep.delaySend : 0.5) * delaySendLevel;
                if (delaySendGain) {
                    delaySendGain.gain.linearRampToValueAtTime(effectiveDelaySend, audioContext.currentTime + 0.05);
                }

                if (currentStep.synth && currentStep.synth.length > 0) {
                    currentStep.synth.forEach(noteName => {
                        const frequency = notes[noteName];
                        if (frequency) {
                            playNote(frequency, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, 'synth');
                        } else {
                            console.warn(`Synth note frequency not found for note: ${noteName}`);
                        }
                    });
                }

                if (currentStep.bass && currentStep.bass.length > 0) {
                    currentStep.bass.forEach(noteName => {
                        const frequency = notes[noteName];
                        if (frequency) {
                            playNote(frequency, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, 'bass');
                        } else {
                            console.warn(`Bass note frequency not found for note: ${noteName}`);
                        }
                    });
                }

                // Percussion logic updated to use probability and velocity
                if (currentStep.percussion) {
                    if (currentStep.percussion.kick && currentStep.percussion.kick.active && Math.random() < currentStep.percussion.kick.probability) {
                        playDrum(nextNoteTime, currentStep.percussion.kick.velocity);
                    }
                    if (currentStep.percussion.snare && currentStep.percussion.snare.active && Math.random() < currentStep.percussion.snare.probability) {
                        playSnare(nextNoteTime, currentStep.percussion.snare.velocity);
                    }
                    if (currentStep.percussion.hihat && currentStep.percussion.hihat.active && Math.random() < currentStep.percussion.hihat.probability) {
                        if (currentStep.percussion.hihat.type === 'closed') {
                            playHiHatClosed(nextNoteTime, currentStep.percussion.hihat.velocity);
                        } else if (currentStep.percussion.hihat.type === 'open') {
                            playHiHatOpen(nextNoteTime, currentStep.percussion.hihat.velocity);
                        }
                    }
                }

                nextNoteTime += (currentTempo / 1000);
                
                stepsPlayedInCurrentSection++;
                currentPhraseIndex++;
                applySubtleChanges();

                if (currentPhraseIndex >= currentSectionPhrase.length) {
                    currentPhraseIndex = 0;
                }

                if (stepsPlayedInCurrentSection >= currentSectionTotalSteps) {
                    console.log(`End of section '${currentSectionName}' reached.`);
                    currentPhraseIndex = 0;
                    stepsPlayedInCurrentSection = 0;
                    currentSongSectionIndex++;

                    currentFibonacciDriftScaleIndex = (currentFibonacciDriftScaleIndex + 1) % fibonacciDriftScales.length;

                    if (currentSongSectionIndex >= songStructure.length) {
                        currentSongSectionIndex = 0;
                        console.log("End of song structure reached. Looping back to Intro.");
                    }

                    const nextSectionDef = songStructure[currentSongSectionIndex];
                    currentSectionType = nextSectionDef.type;
                    let phraseToUse = []; // Temporary variable to hold the phrase before assignment
                    
                    if (currentSectionType === 'verse') {
                        verseIterationCount++;
                        if (currentSongSectionIndex === 1) { // Special case for the very first verse in the song structure
                            currentSectionName = nextSectionDef.baseName + '_C';
                            phraseToUse = musicalPhrases[currentSectionName];
                            console.log(`Forcing first verse to start with: ${currentSectionName}`);
                        } else if (verseIterationCount % 2 === 0) { // This is where Ragas are introduced
                            currentSectionName = getNextRagaPhrase();
                            // FIX: Remove 'raga' prefix and convert to lowercase to correctly match keys in ragaScales
                            const ragaScaleName = currentSectionName.replace('raga', '').replace('Phrase', '').toLowerCase(); 
                            const selectedRagaScale = ragaScales[ragaScaleName]; // Get the actual scale array

                            // Safeguard: Ensure selectedRagaScale is a valid, non-empty array
                            if (selectedRagaScale && Array.isArray(selectedRagaScale) && selectedRagaScale.length > 0) {
                                phraseToUse = generateRagaMelody(selectedRagaScale, 8, humanizationFactor);
                            } else {
                                console.error(`Invalid or empty Raga scale found for name: ${ragaScaleName}. Falling back to a default verse.`);
                                currentSectionName = getRandomNormalVerseVariation('verse1'); // Fallback to a known good verse
                                phraseToUse = musicalPhrases[currentSectionName];
                            }
                        } else {
                            currentSectionName = getRandomNormalVerseVariation(nextSectionDef.baseName);
                            phraseToUse = musicalPhrases[currentSectionName];
                        }
                    } else {
                        currentSectionName = nextSectionDef.name || nextSectionDef.type;
                        phraseToUse = musicalPhrases[currentSectionName];
                    }
                    
                    // Assign the determined/generated phrase to currentSectionPhrase
                    currentSectionPhrase = phraseToUse;

                    // Safeguard: Ensure the phrase is not empty after selection/generation.
                    // If it is, fall back to a known good phrase.
                    if (!currentSectionPhrase || currentSectionPhrase.length === 0) {
                        console.warn(`Section '${currentSectionName}' resulted in an empty phrase. Falling back to intro.`);
                        currentSectionName = 'intro';
                        currentSectionPhrase = musicalPhrases.intro;
                    }

                    // Calculate total steps based on the *final* currentSectionPhrase length
                    currentSectionTotalSteps = currentSectionPhrase.length * nextSectionDef.durationMultiplier;

                    console.log(`Transitioning to section: ${currentSectionName} (type: ${currentSectionType}) for ${currentSectionTotalSteps} steps. Humanization Factor: ${humanizationFactor.toFixed(2)}`);
                    updateSectionDisplay();
                }
            }

            loopTimeoutId = setTimeout(scheduler, 50);
        }

        /**
         * Starts the music looping. Handles initial audio context setup and resumption.
         */
        function startLoop() {
            console.log("Start button clicked. Attempting to start loop.");
            if (!initAudio()) {
                console.error("Audio initialization failed. Cannot start loop.");
                return;
            }

            if (audioContext.state === 'suspended') {
                console.log("AudioContext is suspended. Attempting to resume...");
                showMessage("Resuming audio context...");
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully!');
                    startLoopInternal();
                }).catch(e => {
                    showMessage("Could not resume audio context. Please try again or check browser settings.", 3000);
                    console.error("AudioContext resume error:", e);
                });
            } else {
                console.log("AudioContext is already running or pending. Starting loop directly.");
                startLoopInternal();
            }
        }

        /**
         * Internal function to start the music loop after audio context is ready.
         */
        function startLoopInternal() {
            if (isPlaying) {
                console.log("Loop is already playing. Skipping start.");
                return;
            }

            isPlaying = true;
            nextNoteTime = audioContext.currentTime;
            
            currentSongSectionIndex = 0;
            const initialSectionDef = songStructure[currentSongSectionIndex];
            currentSectionType = initialSectionDef.type;
            
            let initialPhraseToUse = [];

            if (currentSectionType === 'verse') {
                verseIterationCount = 1;
                currentSectionName = initialSectionDef.baseName + '_C';
                initialPhraseToUse = musicalPhrases[currentSectionName];
                console.log(`Forcing initial verse to start with: ${currentSectionName}`);
            } else {
                currentSectionName = initialSectionDef.name || initialSectionDef.type;
                initialPhraseToUse = musicalPhrases[currentSectionName];
            }

            currentSectionPhrase = initialPhraseToUse; // Assign the determined phrase

            shuffleArray(availableRagas);

            currentPhraseIndex = 0;
            stepsPlayedInCurrentSection = 0;
            
            // Calculate total steps based on the assigned currentSectionPhrase length
            currentSectionTotalSteps = currentSectionPhrase.length * initialSectionDef.durationMultiplier;

            // Safeguard for initial phrase if it somehow ends up empty (though unlikely for 'intro')
            if (!currentSectionPhrase || currentSectionPhrase.length === 0) {
                console.warn(`Initial section phrase for '${currentSectionName}' is empty. Falling back to intro.`);
                currentSectionName = 'intro';
                currentSectionPhrase = musicalPhrases.intro;
                currentSectionTotalSteps = currentSectionPhrase.length * initialSectionDef.durationMultiplier;
            }

            updateSectionDisplay();
            console.log(`Starting with section: ${currentSectionName} (type: ${currentSectionType}) for ${currentSectionTotalSteps} steps. Humanization Factor: ${humanizationFactor.toFixed(2)}`);

            masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
            masterGainNode.gain.linearRampToValueAtTime(masterVolume, audioContext.currentTime + 4);

            scheduler();
            drawVisualization();

            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false; /* Corrected: Enable stop button */
            showMessage("Music started. Enjoy the evolving structured loop!");
            console.log("Music loop started.");
        }

        /**
         * Stops the music looping by clearing the scheduler timeout and suspending the audio context.
         */
        function stopLoop() {
            console.log("Stop button clicked. Attempting to stop loop.");
            isPlaying = false;
            clearTimeout(loopTimeoutId);

            if (audioContext && masterGainNode) {
                masterGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                masterGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
                setTimeout(() => {
                    if (audioContext && audioContext.state === 'running') {
                        audioContext.suspend().then(() => {
                            console.log('AudioContext suspended successfully!');
                            showMessage("Music stopped.");
                        }).catch(e => {
                            showMessage("Could not suspend audio context.", 3000);
                            console.error("AudioContext suspend error:", e);
                        });
                    } else {
                        console.log("AudioContext is not running or already suspended.");
                        showMessage("Music stopped.");
                    }
                }, 1000);
            } else {
                console.log("AudioContext or masterGainNode not available for smooth stop.");
                showMessage("Music stopped.");
            }
            
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            console.log("Music loop stopped.");
        }

        /**
         * Draws the audio visualization on the canvas and updates the volume meter.
         * This function is called repeatedly using requestAnimationFrame.
         */
        function drawVisualization() {
            if (!isPlaying || !analyserNode || !audioVisualizerCtx) {
                if (audioVisualizerCtx) {
                    audioVisualizerCtx.clearRect(0, 0, audioVisualizerCanvas.width, audioVisualizerCanvas.height);
                }
                if (volumeMeterFillElement) {
                    volumeMeterFillElement.style.width = '0%';
                }
                if (volumePeakElement) {
                    volumePeakElement.style.opacity = 0;
                }
                return;
            }

            requestAnimationFrame(drawVisualization);

            analyserNode.getByteTimeDomainData(dataArray);

            audioVisualizerCtx.clearRect(0, 0, audioVisualizerCanvas.width, audioVisualizerCanvas.height);
            audioVisualizerCtx.lineWidth = 2;
            audioVisualizerCtx.strokeStyle = '#90ee90';
            audioVisualizerCtx.beginPath();

            const sliceWidth = audioVisualizerCanvas.width * 1.0 / dataArray.length;
            let x = 0;

            let sumOfSquares = 0;
            let maxAmplitude = 0; // For peak detection

            for (let i = 0; i < dataArray.length; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * audioVisualizerCanvas.height / 2;

                if (i === 0) {
                    audioVisualizerCtx.moveTo(x, y);
                } else {
                    audioVisualizerCtx.lineTo(x, y);
                }

                x += sliceWidth;

                const normalizedValue = (dataArray[i] - 128) / 128;
                sumOfSquares += normalizedValue * normalizedValue;
                maxAmplitude = Math.max(maxAmplitude, Math.abs(normalizedValue)); // Track max amplitude
            }

            audioVisualizerCtx.lineTo(audioVisualizerCanvas.width, audioVisualizerCanvas.height / 2);
            audioVisualizerCtx.stroke();

            // Calculate RMS for volume meter
            const rms = Math.sqrt(sumOfSquares / dataArray.length);
            const volumePercentage = Math.min(100, rms * 200); // Scale RMS to a percentage for display
            if (volumeMeterFillElement) {
                volumeMeterFillElement.style.width = `${volumePercentage}%`;
            }

            // Peak detection logic
            if (volumePeakElement) {
                // Update peak if current max amplitude is higher
                if (maxAmplitude > peakValue) {
                    peakValue = maxAmplitude;
                    volumePeakElement.style.opacity = 1; // Show peak indicator
                    // Position peak line based on the current peak value
                    volumePeakElement.style.left = `${Math.min(100, peakValue * 200)}%`; // Scale peak value to percentage
                    
                    // Clear previous fade-out timeout and set a new one
                    clearTimeout(volumePeakElement.fadeTimeout);
                    volumePeakElement.fadeTimeout = setTimeout(() => {
                        volumePeakElement.style.opacity = 0;
                    }, 500); // Peak fades out after 500ms
                } else if (maxAmplitude < peakValue * 0.8 && volumePeakElement.style.opacity === '1') {
                    // Slowly decay peak if current volume drops significantly below it
                    clearTimeout(volumePeakElement.decayTimeout);
                    volumePeakElement.decayTimeout = setTimeout(() => {
                        peakValue *= 0.9; // Decay peak value
                        if (peakValue < 0.1) peakValue = 0; // Reset if too low
                    }, 100);
                }
            }
        }

        /**
         * Manages saving and loading presets to/from local storage.
         */
        class PresetManager {
            constructor() {
                this.storageKeyPrefix = 'looper_preset_';
            }

            /**
             * Saves the current settings as a preset.
             * @param {string} name - The name of the preset.
             * @param {Object} settings - The settings object to save.
             * @returns {boolean} True if saved successfully, false otherwise.
             */
            savePreset(name, settings) {
                try {
                    const preset = {
                        settings: settings,
                        timestamp: Date.now(),
                        metadata: {
                            author: 'User',
                            description: `Saved at ${new Date().toLocaleString()}`,
                            tags: []
                        }
                    };
                    localStorage.setItem(this.storageKeyPrefix + name, JSON.stringify(preset));
                    return true;
                } catch (e) {
                    console.error('Preset save failed:', e);
                    return false;
                }
            }

            /**
             * Loads a preset by name.
             * @param {string} name - The name of the preset to load.
             * @returns {Object|null} The loaded settings object, or null if not found.
             */
            loadPreset(name) {
                try {
                    const presetString = localStorage.getItem(this.storageKeyPrefix + name);
                    if (presetString) {
                        const preset = JSON.parse(presetString);
                        return preset.settings;
                    }
                    return null;
                } catch (e) {
                    console.error('Preset load failed:', e);
                    return null;
                }
            }
        }

        const presetManager = new PresetManager();

        /**
         * Collects all current knob values into an object.
         * @returns {Object} An object containing all current settings.
         */
        function getCurrentSettings() {
            return {
                masterVolume: parseFloat(document.getElementById('masterVolume').value),
                tempo: parseFloat(document.getElementById('tempo').value),
                bassVolume: parseFloat(document.getElementById('bassVolume').value),
                synthVolume: parseFloat(document.getElementById('synthVolume').value),
                kickVolume: parseFloat(document.getElementById('kickVolume').value),
                snareVolume: parseFloat(document.getElementById('snareVolume').value),
                hihatVolume: parseFloat(document.getElementById('hihatVolume').value),
                delayTime: parseFloat(document.getElementById('delayTime').value),
                delayFeedback: parseFloat(document.getElementById('delayFeedback').value),
                delaySendLevel: parseFloat(document.getElementById('delaySendLevel').value),
                chorusDepth: parseFloat(document.getElementById('chorusDepth').value),
                isChorusBypassed: document.getElementById('chorusBypass').checked,
                currentDetune: currentDetune,
                currentFilterFrequency: currentFilterFrequency,
                currentFilterQ: currentFilterQ,
                baseNoteDuration: baseNoteDuration,
                humanizationFactor: humanizationFactor,
                // New: Compressor settings
                compThreshold: parseFloat(document.getElementById('compThreshold').value),
                compRatio: parseFloat(document.getElementById('compRatio').value),
                // New: Reverb settings
                reverbMix: parseFloat(document.getElementById('reverbMix').value),
                isReverbBypassed: document.getElementById('reverbBypass').checked
            };
        }

        /**
         * Applies saved settings to the knobs and global variables.
         * @param {Object} settings - An object containing settings to apply.
         */
        function applySettings(settings) {
            setupKnob('masterVolume', 'masterVolumeValue', settings.masterVolume, 2, (value) => { masterVolume = value; if (audioContext && masterGainNode) masterGainNode.gain.setValueAtTime(masterVolume, audioContext.currentTime); });
            setupKnob('tempo', 'tempoValue', settings.tempo, 0, (value) => { currentTempo = value; });
            setupKnob('bassVolume', 'bassVolumeValue', settings.bassVolume, 2, (value) => { bassVolume = value; });
            setupKnob('synthVolume', 'synthVolumeValue', settings.synthVolume, 2, (value) => { synthVolume = value; });
            setupKnob('kickVolume', 'kickVolumeValue', settings.kickVolume, 2, (value) => { kickVolume = value; });
            setupKnob('snareVolume', 'snareVolumeValue', settings.snareVolume, 2, (value) => { snareVolume = value; });
            setupKnob('hihatVolume', 'hihatVolumeValue', settings.hihatVolume, 2, (value) => { hihatVolume = value; });
            setupKnob('delayTime', 'delayTimeValue', settings.delayTime, 2, (value) => { delayTimeValue = value; if (audioContext && delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, audioContext.currentTime); });
            setupKnob('delayFeedback', 'delayFeedbackValue', settings.delayFeedback, 2, (value) => { delayFeedbackValue = value; if (audioContext && delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, audioContext.currentTime); });
            setupKnob('delaySendLevel', 'delaySendLevelValue', settings.delaySendLevel, 2, (value) => { delaySendLevel = value; });
            setupKnob('chorusDepth', 'chorusDepthValue', settings.chorusDepth, 4, (value) => { chorusDepth = value; if (audioContext && chorusLfoGain) chorusLfoGain.gain.setValueAtTime(chorusDepth, audioContext.currentTime); });
            
            document.getElementById('chorusBypass').checked = settings.isChorusBypassed;
            isChorusBypassed = settings.isChorusBypassed;
            updateChorusBypassConnection();

            // Apply new settings for Compressor
            setupKnob('compThreshold', 'compThresholdValue', settings.compThreshold, 0, (value) => { compThreshold = value; if (audioContext && compressorNode) compressorNode.threshold.setValueAtTime(compThreshold, audioContext.currentTime); });
            setupKnob('compRatio', 'compRatioValue', settings.compRatio, 1, (value) => { compRatio = value; if (audioContext && compressorNode) compressorNode.ratio.setValueAtTime(compRatio, audioContext.currentTime); });
            
            // Apply new settings for Reverb
            setupKnob('reverbMix', 'reverbMixValue', settings.reverbMix, 2, (value) => { reverbMix = value; if (audioContext && reverbGainNode && dryGainNode) { reverbGainNode.gain.setValueAtTime(reverbMix, audioContext.currentTime); dryGainNode.gain.setValueAtTime(1 - reverbMix, audioContext.currentTime); } });
            document.getElementById('reverbBypass').checked = settings.isReverbBypassed;
            isReverbBypassed = settings.isReverbBypassed;
            updateReverbBypassConnection();

            currentDetune = settings.currentDetune;
            currentFilterFrequency = settings.currentFilterFrequency;
            currentFilterQ = settings.currentFilterQ;
            baseNoteDuration = settings.baseNoteDuration;
            humanizationFactor = settings.humanizationFactor;

            showMessage("Preset loaded successfully!");
            console.log("Settings applied:", settings);
        }

        /**
         * Saves the current knob settings to local storage using PresetManager.
         */
        function savePreset() {
            const presetNameInput = document.getElementById('presetNameInput');
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                showMessage("Please enter a name for your preset.", 2000);
                return;
            }
            const settings = getCurrentSettings();
            if (presetManager.savePreset(presetName, settings)) {
                showMessage(`Preset "${presetName}" saved!`);
                console.log(`Preset "${presetName}" saved:`, settings);
            } else {
                showMessage("Failed to save preset. Local storage might be full or unavailable.", 3000);
            }
        }

        /**
         * Loads a preset from local storage and applies its settings using PresetManager.
         */
        function loadPreset() {
            const presetNameInput = document.getElementById('presetNameInput');
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                showMessage("Please enter the name of the preset to load.", 2000);
                return;
            }
            const settings = presetManager.loadPreset(presetName);
            if (settings) {
                applySettings(settings);
            } else {
                showMessage(`Preset "${presetName}" not found.`, 2000);
                console.warn(`Preset "${presetName}" not found.`);
            }
        }

        /**
         * Updates the audio graph connection for chorus bypass.
         */
        function updateChorusBypassConnection() {
            if (!audioContext || !masterGainNode || !analyserNode || !chorusNode || !compressorNode) return;

            // Disconnect masterGainNode from compressor (its direct connection)
            masterGainNode.disconnect(compressorNode);
            // Disconnect chorusNode from analyserNode if it was connected
            try {
                chorusNode.disconnect(compressorNode); // Chorus connects to compressor now
            } catch (e) { /* ignore */ }

            // Reconnect masterGainNode to chorus or compressor based on bypass state
            if (isChorusBypassed) {
                masterGainNode.connect(compressorNode);
            } else {
                masterGainNode.connect(chorusNode);
                chorusNode.connect(compressorNode); // Chorus output connects to compressor
            }
        }

        /**
         * Updates the audio graph connection for reverb bypass.
         */
        function updateReverbBypassConnection() {
            if (!audioContext || !compressorNode || !analyserNode || !convolverNode || !reverbGainNode || !dryGainNode) return;

            // Disconnect all previous connections from compressor to dry/wet paths
            compressorNode.disconnect(dryGainNode);
            compressorNode.disconnect(convolverNode);
            
            // Disconnect dry/wet paths from analyser
            try {
                dryGainNode.disconnect(analyserNode);
                reverbGainNode.disconnect(analyserNode);
            } catch (e) { /* ignore */ }

            if (isReverbBypassed) {
                // If bypassed, connect compressor directly to analyser
                compressorNode.connect(analyserNode);
            } else {
                // If active, connect compressor to dry and wet paths
                compressorNode.connect(dryGainNode);
                dryGainNode.connect(analyserNode);

                compressorNode.connect(convolverNode);
                convolverNode.connect(reverbGainNode);
                reverbGainNode.connect(analyserNode);
            }
            analyserNode.connect(audioContext.destination); // Analyser always connects to destination
        }

        // --- Knob Event Listeners and Value Display ---
        function setupKnob(knobId, valueSpanId, initialValue, displayPrecision = 2, onInputChangeCallback) {
            const knob = document.getElementById(knobId);
            const valueSpan = document.getElementById(valueSpanId);

            if (knob) {
                knob.value = initialValue;
                valueSpan.textContent = initialValue.toFixed(displayPrecision);

                knob.addEventListener('input', (event) => {
                    let value = parseFloat(event.target.value);
                    valueSpan.textContent = value.toFixed(displayPrecision);
                    if (onInputChangeCallback) {
                        onInputChangeCallback(value);
                    }
                });
            } else {
                console.warn(`Knob with ID '${knobId}' not found.`);
            }
        }

        // New: LooperRecorder Class
        class LooperRecorder {
            constructor(audioContext) {
                this.audioContext = audioContext;
                this.chunks = [];
                this.mediaRecorder = null;
                this.isRecording = false;
                
                // Initialize recorder only if audioContext is available
                if (this.audioContext) {
                    this.initializeRecorder();
                } else {
                    console.warn("AudioContext not available for LooperRecorder initialization.");
                }
            }
            
            async initializeRecorder() {
                // Create a MediaStreamDestination to capture audio from the analyserNode
                const dest = this.audioContext.createMediaStreamDestination();
                // Connect the main output (analyserNode) to the recording destination
                analyserNode.connect(dest); 
                
                this.mediaRecorder = new MediaRecorder(dest.stream);
                this.mediaRecorder.ondataavailable = (e) => this.chunks.push(e.data);
                this.mediaRecorder.onstop = () => this.createDownload();
            }
            
            startRecording() {
                if (!this.mediaRecorder) {
                    showMessage("Recording not initialized. Please start audio first.", 3000);
                    return;
                }
                this.chunks = [];
                this.mediaRecorder.start();
                this.isRecording = true;
                showMessage("Recording started!");
                console.log("Recording started.");
            }
            
            stopRecording() {
                if (!this.mediaRecorder || !this.isRecording) {
                    showMessage("Not currently recording.", 2000);
                    return;
                }
                this.mediaRecorder.stop();
                this.isRecording = false;
                showMessage("Recording stopped. Preparing download...");
                console.log("Recording stopped.");
            }
            
            createDownload() {
                const blob = new Blob(this.chunks, { type: 'audio/wav' }); // Using WAV for broader compatibility
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `relax_loop_${new Date().toISOString().replace(/:/g, '-')}.wav`; // Sanitize filename
                document.body.appendChild(a); // Append to body to make it clickable
                a.click();
                document.body.removeChild(a); // Clean up
                URL.revokeObjectURL(url); // Release object URL
                showMessage("Recording downloaded!", 3000);
                console.log("Recording download initiated.");
            }
        }

        // New: Add Recording Controls to UI
        function addRecordingControls() {
            const recordButton = document.getElementById('recordButton');
            if (recordButton) {
                recordButton.addEventListener('click', () => {
                    if (looperRecorder.isRecording) {
                        looperRecorder.stopRecording();
                        recordButton.textContent = 'Start Recording';
                    } else {
                        // Ensure audio context is initialized before starting recording
                        if (!audioContext || audioContext.state === 'suspended') {
                            showMessage("Please start the music loop before recording.", 3000);
                            return;
                        }
                        looperRecorder.startRecording();
                        recordButton.textContent = 'Stop Recording';
                    }
                });
            }
        }

        // New: Keyboard Controls Initialization
        function initializeKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                // Only handle shortcuts if not typing in an input
                if (e.target.tagName === 'INPUT') return;
                
                const startButton = document.getElementById('startButton');
                const stopButton = document.getElementById('stopButton');

                switch(e.code) {
                    case 'Space':
                        e.preventDefault(); // Prevent default spacebar action (e.g., scrolling)
                        if (isPlaying) {
                            stopButton.click();
                        } else {
                            startButton.click();
                        }
                        break;
                    case 'KeyM':
                        // Master volume mute/unmute
                        const volKnob = document.getElementById('masterVolume');
                        if (volKnob) {
                            if (parseFloat(volKnob.value) > 0) {
                                volKnob.dataset.lastValue = volKnob.value; // Store current value
                                volKnob.value = 0;
                            } else {
                                volKnob.value = volKnob.dataset.lastValue || 0.55; // Restore or default
                            }
                            volKnob.dispatchEvent(new Event('input')); // Trigger input event to update UI and audio
                            showMessage(`Master Volume: ${parseFloat(volKnob.value) === 0 ? 'Muted' : 'Unmuted'}`, 1500);
                        }
                        break;
                    case 'ArrowUp':
                    case 'ArrowDown':
                        // Tempo control
                        const tempoKnob = document.getElementById('tempo');
                        if (tempoKnob) {
                            e.preventDefault(); // Prevent default scrolling
                            const step = e.code === 'ArrowUp' ? 10 : -10;
                            tempoKnob.value = Math.min(parseFloat(tempoKnob.max), Math.max(parseFloat(tempoKnob.min), parseInt(tempoKnob.value) + step));
                            tempoKnob.dispatchEvent(new Event('input')); // Trigger input event to update UI and audio
                            showMessage(`Tempo: ${tempoKnob.value} ms`, 1000);
                        }
                        break;
                }
            });
        }

        // MIDI Input Initialization (Removed due to permissions policy in this environment)
        // function initializeMidi() {
        //     if (navigator.requestMIDIAccess) {
        //         navigator.requestMIDIAccess()
        //             .then(onMIDISuccess, onMIDIFailure);
        //     } else {
        //         console.warn("Web MIDI API is not supported in this browser.");
        //         showMessage("MIDI input not supported by your browser.", 3000);
        //     }
        // }

        // function onMIDISuccess(midiAccess) {
        //     console.log("Web MIDI API access granted.", midiAccess);
        //     showMessage("MIDI access granted! Looking for devices...", 2000);

        //     // Get MIDI inputs
        //     const inputs = midiAccess.inputs;
        //     if (inputs.size === 0) {
        //         console.log("No MIDI input devices found.");
        //         showMessage("No MIDI input devices found.", 2000);
        //         return;
        //     }

        //     inputs.forEach(input => {
        //         console.log(`MIDI Input: Name: ${input.name}, Manufacturer: ${input.manufacturer}, ID: ${input.id}`);
        //         input.onmidimessage = onMIDIMessage;
        //     });
        // }

        // function onMIDIFailure(error) {
        //     console.error(`Failed to get MIDI access: ${error.code} - ${error.message}`);
        //     showMessage(`Failed to get MIDI access: ${error.message}`, 5000);
        // }

        // function onMIDIMessage(event) {
        //     const data = event.data; // [status, note, velocity]
        //     const status = data[0];
        //     const note = data[1];
        //     const velocity = data[2];

        //     // Example: Log MIDI messages
        //     console.log(`MIDI Message: Status: ${status}, Note: ${note}, Velocity: ${velocity}`);

        //     // Basic MIDI note on/off handling (for future expansion)
        //     if (status === 144) { // Note On (0x90)
        //         // console.log(`MIDI Note On: ${note} with velocity ${velocity}`);
        //         // Future: Map MIDI note to play a specific sound or trigger a sequence
        //     } else if (status === 128) { // Note Off (0x80)
        //         // console.log(`MIDI Note Off: ${note}`);
        //     } else if (status >= 176 && status <= 191) { // Control Change (0xB0-0xBF)
        //         // console.log(`MIDI Control Change: Controller: ${note}, Value: ${velocity}`);
        //         // Future: Map MIDI CC to control knobs
        //     }
        // }


        // Add event listeners once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Attaching event listeners.");
            document.getElementById('startButton').addEventListener('click', startLoop);
            document.getElementById('stopButton').addEventListener('click', stopLoop);
            document.getElementById('savePresetButton').addEventListener('click', savePreset);
            document.getElementById('loadPresetButton').addEventListener('click', loadPreset);
            
            document.getElementById('chorusBypass').addEventListener('change', (event) => {
                isChorusBypassed = event.target.checked;
                updateChorusBypassConnection();
                showMessage(`Chorus is now ${isChorusBypassed ? 'bypassed' : 'active'}.`);
            });

            document.getElementById('reverbBypass').addEventListener('change', (event) => {
                isReverbBypassed = event.target.checked;
                updateReverbBypassConnection();
                showMessage(`Reverb is now ${isReverbBypassed ? 'bypassed' : 'active'}.`);
            });

            updateSectionDisplay();

            // Setup all knobs
            setupKnob('masterVolume', 'masterVolumeValue', masterVolume, 2, (value) => {
                masterVolume = value;
                if (audioContext && masterGainNode) masterGainNode.gain.setValueAtTime(masterVolume, audioContext.currentTime);
            });
            setupKnob('bassVolume', 'bassVolumeValue', bassVolume, 2, (value) => {
                bassVolume = value;
            });
            setupKnob('synthVolume', 'synthVolumeValue', synthVolume, 2, (value) => {
                synthVolume = value;
            });
            setupKnob('kickVolume', 'kickVolumeValue', kickVolume, 2, (value) => {
                kickVolume = value;
            });
            setupKnob('snareVolume', 'snareVolumeValue', snareVolume, 2, (value) => {
                snareVolume = value;
            });
            setupKnob('hihatVolume', 'hihatVolumeValue', hihatVolume, 2, (value) => {
                hihatVolume = value;
            });
            setupKnob('tempo', 'tempoValue', currentTempo, 0, (value) => {
                currentTempo = value;
            });
            setupKnob('delayTime', 'delayTimeValue', delayTimeValue, 2, (value) => {
                delayTimeValue = value;
                if (audioContext && delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, audioContext.currentTime);
            });
            setupKnob('delayFeedback', 'delayFeedbackValue', delayFeedbackValue, 2, (value) => {
                delayFeedbackValue = value;
                if (audioContext && delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, audioContext.currentTime);
            });
            setupKnob('delaySendLevel', 'delaySendLevelValue', delaySendLevel, 2, (value) => {
                delaySendLevel = value;
            });
            setupKnob('chorusDepth', 'chorusDepthValue', chorusDepth, 4, (value) => {
                chorusDepth = value;
                if (audioContext && chorusLfoGain) chorusLfoGain.gain.setValueAtTime(chorusDepth, audioContext.currentTime);
            });
            // New: Compressor knob setup
            setupKnob('compThreshold', 'compThresholdValue', compThreshold, 0, (value) => {
                compThreshold = value;
                if (audioContext && compressorNode) compressorNode.threshold.setValueAtTime(compThreshold, audioContext.currentTime);
                document.getElementById('compThresholdValue').textContent = `${value} dB`;
            });
            setupKnob('compRatio', 'compRatioValue', compRatio, 1, (value) => {
                compRatio = value;
                if (audioContext && compressorNode) compressorNode.ratio.setValueAtTime(compRatio, audioContext.currentTime);
                document.getElementById('compRatioValue').textContent = `${value}:1`;
            });
            // New: Reverb knob setup
            setupKnob('reverbMix', 'reverbMixValue', reverbMix, 2, (value) => {
                reverbMix = value;
                if (audioContext && reverbGainNode && dryGainNode) {
                    reverbGainNode.gain.setValueAtTime(reverbMix, audioContext.currentTime);
                    dryGainNode.gain.setValueAtTime(1 - reverbMix, audioContext.currentTime);
                }
                document.getElementById('reverbMixValue').textContent = `${(value * 100).toFixed(0)}%`;
            });

            // Initialize keyboard controls
            initializeKeyboardControls();
            
            // Add recording controls (looperRecorder is initialized in initAudio)
            addRecordingControls();

            // Initial connection update for chorus and reverb
            updateChorusBypassConnection();
            updateReverbBypassConnection();

            // MIDI initialization is commented out because it requires specific browser permissions
            // that are not available in this sandboxed environment.
            // initializeMidi();
        });
    </script>
</body>
</html>
