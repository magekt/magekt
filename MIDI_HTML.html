<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Relax Looper</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Apply Inter font and basic styling to the body */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter as per instructions */
            display: flex;
            justify-content: center; /* Center content horizontally */
            align-items: flex-start; /* Align items to the top */
            min-height: 100vh; /* Ensure it takes full viewport height */
            background-color: #1a1a1a; /* Dark background for ambient feel */
            color: #e0e0e0; /* Light text color */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px; /* Space between the left panel and main content */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Main layout container for left panel and central content */
        .main-layout-container {
            display: flex;
            flex-direction: row; /* Controls on left, main content on right */
            gap: 20px;
            width: 100%;
            max-width: 1200px; /* Max width for the entire layout */
            justify-content: center; /* Center the layout within the body */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Left panel for knobs */
        .left-panel {
            flex: 0 0 280px; /* Slightly wider fixed width for the left panel */
            background-color: #2a2a2a;
            padding: 25px; /* Increased padding */
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 25px; /* Increased gap between sections */
        }

        /* Central content container (formerly 'container') */
        .central-content {
            flex: 1; /* Take remaining space */
            min-width: 320px; /* Minimum width for central content */
            background-color: #2a2a2a;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 25px; /* Increased gap between sections */
        }

        /* Styling for the main heading */
        h1 {
            color: #90ee90; /* Light green for "Weed" theme */
            margin-bottom: 10px; /* Reduced margin */
            font-size: 2.8em; /* Slightly larger */
            text-shadow: 0 0 12px rgba(144, 238, 144, 0.7); /* Stronger glow effect */
            font-weight: 700; /* Bolder */
        }
        /* Styling for subheadings in knob sections */
        h3 {
            color: #a0ffa0; /* Slightly brighter green for subheadings */
            margin-top: 0;
            margin-bottom: 15px; /* More space below subheading */
            font-size: 1.4em;
            font-weight: 600;
            border-bottom: 1px solid rgba(144, 238, 144, 0.3); /* Subtle separator */
            padding-bottom: 10px;
        }

        /* Styling for buttons */
        button {
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px; /* Rounded corners for buttons */
            cursor: pointer;
            font-size: 1.2em;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; /* Smooth transitions */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); /* More prominent button shadow */
            outline: none; /* Remove outline on focus */
            font-weight: 600;
        }
        /* Hover effects for buttons */
        button:hover {
            background-color: #45a049;
            transform: translateY(-3px); /* Slight lift effect */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        /* Active (click) effects for buttons */
        button:active {
            background-color: #3e8e41;
            transform: translateY(0); /* Return to original position */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        /* Styling for disabled buttons */
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        /* Styling for the custom message box */
        .message-box {
            background-color: #3a3a3a;
            color: #fff;
            padding: 15px;
            border-radius: 8px; /* Rounded corners */
            margin-top: 20px;
            font-size: 0.9em;
            display: none; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid #4CAF50; /* Green border for message box */
        }
        /* Class to show the message box */
        .message-box.show {
            display: block;
            opacity: 1;
        }
        /* Styling for paragraph text */
        p {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
            color: #ccc;
        }
        /* Styling for current section display */
        #currentSectionDisplay {
            margin-top: 15px; /* Increased margin */
            font-size: 1.4em; /* Slightly larger */
            color: #a0ffa0;
            font-weight: bold;
            transition: color 0.3s ease; /* Smooth color transition for highlight */
        }
        /* Highlight for current section */
        #currentSectionDisplay.highlight {
            color: #ffcc00; /* Yellowish highlight */
            text-shadow: 0 0 8px rgba(255, 204, 0, 0.6); /* Subtle glow */
        }
        /* Flex container for control buttons */
        .controls {
            display: flex;
            gap: 15px; /* Space between buttons */
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Styling for knob sections */
        .knob-section {
            background-color: #3a3a3a;
            padding: 20px; /* Increased padding */
            border-radius: 12px; /* Slightly more rounded */
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.2); /* Inner shadow for depth */
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Responsive grid for knobs, slightly wider min */
            gap: 20px; /* Increased gap */
        }
        .knob-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px; /* Increased gap */
            position: relative; /* For value indicator */
            padding: 10px;
            border-radius: 8px;
            background-color: #444; /* Slightly lighter background for individual knob groups */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .knob-group label {
            font-size: 1em; /* Slightly larger */
            color: #ccc;
            font-weight: 500;
            text-align: center;
        }
        .knob-group input[type="range"] {
            width: 100%; /* Make sliders fill their group width */
            max-width: 150px; /* Max width for consistency */
            -webkit-appearance: none;
            appearance: none;
            height: 10px; /* Slightly thicker slider track */
            background: #555;
            outline: none;
            border-radius: 5px;
            transition: background 0.2s;
        }
        .knob-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px; /* Slightly larger thumb */
            height: 22px;
            border-radius: 50%;
            background: #90ee90;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(144, 238, 144, 0.7); /* Stronger glow */
            border: 2px solid #1a1a1a; /* Dark border for contrast */
        }
        .knob-group input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #90ee90;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(144, 238, 144, 0.7);
            border: 2px solid #1a1a1a;
        }
        /* Enhanced focus styles for range inputs */
        .knob-group input[type="range"]:focus {
            box-shadow: 0 0 0 3px rgba(144, 238, 144, 0.5); /* Green glow on focus */
        }

        .knob-value {
            font-size: 1.1em; /* Slightly larger for better readability */
            color: #a0ffa0;
            font-weight: 700; /* Bolder for emphasis */
            margin-top: 5px;
        }
        .knob-group select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            width: 100%;
            max-width: 150px;
            text-align: center;
            appearance: none; /* Remove default arrow */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23e0e0e0%22%20d%3D%22M287%2C197.3L159.9%2C69.8c-4.4-4.3-11.4-4.3-15.8%2C0L5.1%2C197.3c-4.4%2C4.3-4.4%2C11.3%2C0%2C15.6l15.8%2C15.6c4.4%2C4.3%2C11.4%2C4.3%2C15.8%2C0L146%2C106.6c4.4-4.3%2C11.4-4.3%2C15.8%2C0l110.2%2C110.2c4.4%2C4.3%2C11.4%2C4.3%2C15.8%2C0l15.8-15.6C291.3%2C208.6%2C291.3%2C201.6%2C287%2C197.3z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 8px top 50%;
            background-size: 12px auto;
        }
        /* Enhanced focus styles for select inputs */
        .knob-group select:focus {
            box-shadow: 0 0 0 3px rgba(144, 238, 144, 0.5); /* Green glow on focus */
        }

        /* Audio Visualizer */
        #audioVisualizer {
            background-color: #000;
            border: 2px solid #4CAF50; /* Thicker border */
            border-radius: 10px; /* More rounded */
            margin-top: 25px; /* Increased margin */
            width: 100%; /* Make it responsive */
            max-width: 450px; /* Max width for desktop */
            height: 120px; /* Slightly taller */
            box-shadow: 0 0 15px rgba(144, 238, 144, 0.5); /* Glowing effect */
        }

        /* Volume Meter */
        .volume-meter-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 20px;
            gap: 12px; /* Increased gap */
            background-color: #3a3a3a;
            padding: 15px;
            border-radius: 10px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
        }
        .volume-meter-label {
            font-size: 1em;
            color: #ccc;
            font-weight: 500;
        }
        #volumeMeter {
            width: 180px; /* Wider meter */
            height: 18px; /* Taller meter */
            background-color: #555;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #4CAF50;
            position: relative;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }
        #volumeMeterFill {
            height: 100%;
            width: 0%; /* Starts empty */
            background-color: #90ee90;
            transition: width 0.05s ease-out; /* Smooth transition for volume changes */
            box-shadow: 0 0 8px rgba(144, 238, 144, 0.5); /* Subtle glow on fill */
        }
        #volumePeak {
            position: absolute;
            height: 100%;
            width: 3px; /* Thicker line for peak */
            background-color: #ff0000; /* Red for peak */
            right: 0; /* Initially at the right, will move with peak */
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }

        /* Preset controls */
        .preset-controls {
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            gap: 15px; /* Increased gap */
            align-items: center;
            background-color: #3a3a3a; /* Consistent background */
            padding: 20px;
            border-radius: 12px;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.2);
        }
        .preset-controls input[type="text"] {
            padding: 10px; /* Increased padding */
            border-radius: 8px; /* More rounded */
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            width: 90%; /* Wider input */
            max-width: 250px; /* Increased max-width */
            font-size: 1em;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
        }
        .preset-controls button {
            padding: 12px 25px; /* Adjusted padding */
            font-size: 1.1em; /* Slightly smaller than main buttons */
            width: 90%;
            max-width: 250px;
            background-color: #555; /* Different color for preset buttons */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .preset-controls button:hover {
            background-color: #666;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        .preset-controls button:active {
            background-color: #444;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px; /* Increased gap */
            margin-top: 10px;
            color: #ccc;
            font-size: 1em; /* Slightly larger */
        }
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #90ee90; /* Green accent for checkbox */
            cursor: pointer;
        }

        /* Recording Meter Style */
        .recording-meter {
            background-color: #ff4d4d; /* Red for recording */
            color: white;
            padding: 8px 15px; /* Increased padding */
            border-radius: 8px; /* More rounded */
            margin-top: 15px;
            font-size: 1em; /* Slightly larger */
            display: none; /* Hidden by default */
            animation: pulse 1s infinite alternate; /* Pulsing animation */
            font-weight: 600;
            box-shadow: 0 0 10px rgba(255, 77, 77, 0.6); /* Red glow */
            border: 1px solid #ff0000;
        }

        .recording-meter.active {
            display: block;
        }

        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.7; }
        }

        /* Visualization Mode Controls */
        .visualization-controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .visualization-controls button {
            padding: 10px 18px; /* Adjusted padding */
            font-size: 0.95em; /* Slightly larger */
            background-color: #555;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .visualization-controls button.active {
            background-color: #90ee90;
            color: #1a1a1a;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(144, 238, 144, 0.6);
        }

        /* Recording Format Dropdown */
        .recording-format-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px; /* Increased gap */
            margin-top: 15px;
        }
        .recording-format-control label {
            font-size: 1em;
            color: #ccc;
            font-weight: 500;
        }
        .recording-format-control select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            width: 160px; /* Slightly wider */
            text-align: center;
            appearance: none; /* Remove default arrow */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23e0e0e0%22%20d%3D%22M287%2C197.3L159.9%2C69.8c-4.4-4.3-11.4-4.3-15.8%2C0L5.1%2C197.3c-4.4%2C4.3-4.4%2C11.3%2C0%2C15.6l15.8%2C15.6c4.4%2C4.3%2C11.4%2C4.3%2C15.8%2C0L146%2C106.6c4.4-4.3%2C11.4-4.3%2C15.8%2C0l110.2%2C110.2c4.4%2C4.3%2C11.4%2C4.3%2C15.8%2C0l15.8-15.6C291.3%2C208.6%2C291.3%2C201.6%2C287%2C197.3z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 8px top 50%;
            background-size: 12px auto;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-layout-container {
                flex-direction: column; /* Stack panels vertically on small screens */
                align-items: center;
                padding: 10px; /* Reduced padding */
            }
            .left-panel, .central-content {
                width: 98%; /* Make panels take more width */
                flex: none; /* Remove flex grow/shrink */
                padding: 20px; /* Adjusted padding */
            }
            h1 {
                font-size: 2.2em; /* Smaller on mobile */
            }
            button {
                padding: 12px 20px; /* Smaller button padding */
                font-size: 1.1em;
            }
            .knob-section {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Adjust grid for smaller screens */
                gap: 15px;
            }
            #audioVisualizer {
                width: 98%; /* Make visualizer wider on small screens */
                max-width: none; /* No max-width on mobile */
            }
            .preset-controls input[type="text"],
            .preset-controls button {
                max-width: 90%; /* Wider on mobile */
            }
        }
    </style>
</head>
<body>
    <div class="main-layout-container">
        <div class="left-panel">
            <div class="knob-section">
                <h3>Master Controls</h3>
                <div class="knob-group">
                    <label for="masterVolume">Master Volume</label>
                    <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.55" title="Adjust overall volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="masterVolumeValue">0.55</span>
                </div>
                <div class="knob-group">
                    <label for="tempo">Tempo (ms)</label>
                    <input type="range" id="tempo" min="300" max="900" step="10" value="420" title="Adjust loop speed. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="tempoValue">420</span>
                </div>
            </div>

            <div class="knob-section">
                <h3>Instrument Gains</h3>
                <div class="knob-group">
                    <label for="bassVolume">Bass Volume</label>
                    <input type="range" id="bassVolume" min="0" max="0.5" step="0.01" value="0.03" title="Adjust bass instrument volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="bassVolumeValue">0.03</span>
                </div>
                <div class="knob-group">
                    <label for="synthVolume">Synth Volume</label>
                    <input type="range" id="synthVolume" min="0" max="0.5" step="0.01" value="0.08" title="Adjust synth instrument volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="synthVolumeValue">0.08</span>
                </div>
                <div class="knob-group">
                    <label for="kickVolume">Kick Volume</label>
                    <input type="range" id="kickVolume" min="0" max="1" step="0.01" value="0.89" title="Adjust kick drum volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="kickVolumeValue">0.89</span>
                </div>
                <div class="knob-group">
                    <label for="snareVolume">Snare Volume</label>
                    <input type="range" id="snareVolume" min="0" max="0.3" step="0.01" value="0.21" title="Adjust snare drum volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="snareVolumeValue">0.21</span>
                </div>
                <div class="knob-group">
                    <label for="hihatVolume">Hi-Hat Volume</label>
                    <input type="range" id="hihatVolume" min="0" max="0.3" step="0.01" value="0.21" title="Adjust hi-hat volume. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="hihatVolumeValue">0.21</span>
                </div>
            </div>

            <!-- Instrument Timbres Section -->
            <div class="knob-section">
                <h3>Instrument Timbres</h3>
                <div class="knob-group">
                    <label for="bassOscillatorType">Bass Wave</label>
                    <select id="bassOscillatorType" title="Select waveform for bass instrument">
                        <option value="sine" selected>Sine</option> <!-- Changed default to Sine -->
                        <option value="triangle">Triangle</option>
                        <option value="sawtooth">Sawtooth</option>
                        <option value="square">Square</option>
                    </select>
                </div>
                <div class="knob-group">
                    <label for="synthOscillatorType">Synth Wave</label>
                    <select id="synthOscillatorType" title="Select waveform for synth instrument">
                        <option value="square" selected>Square</option> <!-- Changed default to Square -->
                        <option value="sine">Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="sawtooth">Sawtooth</option>
                    </select>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="synthArpeggiator" title="Enable arpeggiator for synth (Hotkey: A)">
                    <label for="synthArpeggiator">Synth Arpeggiator (A)</label>
                </div>
            </div>

            <div class="knob-section">
                <h3>Effects</h3>
                <div class="knob-group">
                    <label for="delayTime">Delay Time (s)</label>
                    <input type="range" id="delayTime" min="0.01" max="2.0" step="0.01" value="0.3" title="Set delay time. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="delayTimeValue">0.30</span>
                </div>
                <div class="knob-group">
                    <label for="delayFeedback">Delay Feedback</label>
                    <input type="range" id="delayFeedback" min="0" max="0.95" step="0.01" value="0.4" title="Set delay feedback amount. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="delayFeedbackValue">0.40</span>
                </div>
                <div class="knob-group">
                    <label for="delaySendLevel">Delay Send</label>
                    <input type="range" id="delaySendLevel" min="0" max="1.0" step="0.01" value="0.5" title="Set amount of signal sent to delay. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="delaySendLevelValue">0.50</span>
                </div>
                <div class="knob-group">
                    <label for="chorusDepth">Chorus Depth</label>
                    <input type="range" id="chorusDepth" min="0" max="0.01" step="0.0001" value="0.002" title="Set chorus modulation depth. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="chorusDepthValue">0.002</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="chorusBypass" checked title="Bypass the Chorus effect (Hotkey: C)">
                    <label for="chorusBypass">Bypass Chorus (C)</label>
                </div>
            </div>

            <!-- Compressor Controls -->
            <div class="knob-section">
                <h3>Compressor</h3>
                <div class="knob-group">
                    <label for="compThreshold">Threshold</label>
                    <input type="range" id="compThreshold" min="-60" max="0" step="1" value="-24" title="Set compressor threshold in dB. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="compThresholdValue">-24 dB</span>
                </div>
                <div class="knob-group">
                    <label for="compRatio">Ratio</label>
                    <input type="range" id="compRatio" min="1" max="20" step="0.1" value="12" title="Set compressor ratio. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="compRatioValue">12:1</span>
                </div>
            </div>

            <!-- Reverb Controls -->
            <div class="knob-section">
                <h3>Reverb</h3>
                <div class="knob-group">
                    <label for="reverbMix">Mix</label>
                    <input type="range" id="reverbMix" min="0" max="1" step="0.01" value="0.5" title="Set wet/dry mix for reverb. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="reverbMixValue">50%</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="reverbBypass" checked title="Bypass the Reverb effect (Hotkey: R)">
                    <label for="reverbBypass">Bypass Reverb (R)</label>
                </div>
            </div>

            <!-- Distortion Controls -->
            <div class="knob-section">
                <h3>Distortion</h3>
                <div class="knob-group">
                    <label for="distortionAmount">Amount</label>
                    <input type="range" id="distortionAmount" min="0" max="1000" step="1" value="0" title="Adjust distortion amount. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="distortionAmountValue">0</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="distortionBypass" checked title="Bypass the Distortion effect (Hotkey: D)">
                    <label for="distortionBypass">Bypass Distortion (D)</label>
                </div>
            </div>

            <!-- Phaser Controls -->
            <div class="knob-section">
                <h3>Phaser</h3>
                <div class="knob-group">
                    <label for="phaserRate">Rate (Hz)</label>
                    <input type="range" id="phaserRate" min="0.1" max="10" step="0.1" value="1" title="Adjust phaser modulation rate. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="phaserRateValue">1.0</span>
                </div>
                <div class="knob-group">
                    <label for="phaserDepth">Depth</label>
                    <input type="range" id="phaserDepth" min="0" max="1" step="0.01" value="0.5" title="Adjust phaser modulation depth. (Shift + Up/Down for fine tune)">
                    <span class="knob-value" id="phaserDepthValue">0.50</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="phaserBypass" checked title="Bypass the Phaser effect (Hotkey: P)">
                    <label for="phaserBypass">Bypass Phaser (P)</label>
                </div>
            </div>

        </div>

        <div class="central-content">
            <h1>Simple Relax Looper</h1>
            <p>Experience a subtly evolving ambient track designed for relaxation.</p>
            <div class="controls">
                <button id="startButton" title="Start the music loop (Hotkey: Space/Enter)">Start Looping</button>
                <button id="stopButton" disabled title="Stop the music loop (Hotkey: Space/Enter)">Stop Looping</button>
            </div>
            <div id="currentSectionDisplay">Current Section: --</div>
            <div id="songIterationDisplay">Song Iteration: 0</div> <!-- New element for iteration count -->
            <div id="messageBox" class="message-box"></div>

            <!-- Audio Visualization Canvas -->
            <canvas id="audioVisualizer" width="400" height="100"></canvas>

            <!-- Visualization Mode Controls -->
            <div class="visualization-controls">
                <button id="visModeSpectrum" class="active" title="Show frequency spectrum visualization">Spectrum</button>
                <button id="visModeWaveform" title="Show waveform visualization">Waveform</button>
                <button id="visModeBoth" title="Show both spectrum and waveform visualization">Both</button>
                <button id="visModeBands" title="Show bass, mid, and treble frequency bands">Bands</button>
            </div>

            <!-- Master Volume Meter -->
            <div class="volume-meter-container">
                <span class="volume-meter-label">Master Volume:</span>
                <div id="volumeMeter">
                    <div id="volumeMeterFill"></div>
                    <div id="volumePeak"></div>
                </div>
            </div>

            <!-- Preset Controls -->
            <div class="preset-controls">
                <h3>Presets</h3>
                <input type="text" id="presetNameInput" placeholder="Enter preset name" title="Enter a name for your preset">
                <button id="savePresetButton" title="Save current settings as a preset">Save Preset</button>
                <button id="loadPresetButton" title="Load a saved preset">Load Preset</button>
                <button id="exportPresetsButton" title="Export all saved presets to a JSON file">Export All Presets</button>
                <input type="file" id="importPresetsInput" accept=".json" style="display: none;" title="Select a JSON file to import presets">
                <button id="importPresetsButton" title="Import Presets">Import Presets</button> <!-- Added text here -->
                <p>Quick Load: Press 1-9 to load "Preset 1" to "Preset 9"</p>
            </div>

            <!-- Recording Controls -->
            <div class="controls recording-controls">
                <button id="recordButton" title="Start/Stop recording audio (Hotkey: Ctrl+R)">Start Recording</button>
                <div class="recording-format-control">
                    <label for="recordingFormat">Format:</label>
                    <select id="recordingFormat" title="Select recording output format">
                        <option value="wav">WAV (Supported)</option>
                        <option value="mp3">MP3 (Not Supported Natively)</option>
                    </select>
                </div>
                <div class="recording-meter"></div> <!-- Added for the recording meter -->
            </div>
        </div>
    </div>

    <script>
        // Global variables for the Web Audio API context and nodes
        let audioContext;
        let masterGainNode;
        let isPlaying = false; // Flag to track if audio is currently playing
        let nextNoteTime = 0; // The time when the next note should be scheduled
        let loopTimeoutId; // ID for the setTimeout that schedules the next audio event

        // Musical parameters controlled by knobs - initialized to default values
        let masterVolume = 0.55;
        let bassVolume = 0.03; // Changed bass volume to 0.03
        let synthVolume = 0.08;
        let kickVolume = 0.89;
        let snareVolume = 0.21;
        let hihatVolume = 0.21;

        let currentTempo = 420;
        let targetTempo = 420; // New: For dynamic tempo changes
        let tempoDriftDirection = 1; // New: For tempo drift

        let currentDetune = 0;
        let currentFilterFrequency = 1000;
        let currentFilterQ = 1;
        let baseNoteDuration = 0.5;

        // Global variables for filter and detune drift (still apply subtle background changes)
        let filterDriftDirection = 1;
        let detuneDriftDirection = 1;
        let delayTimeDriftDirection = 1;
        let delayFeedbackDriftDirection = 1;

        // Fibonacci-influenced drift scale factors for dynamic parameters
        const fibonacciDriftScales = [0.1, 0.2, 0.3, 0.5, 0.8, 1.3, 2.1];
        let currentFibonacciDriftScaleIndex = 0;

        // Humanization intensity factor, also influenced by Fibonacci drift
        let humanizationFactor = 0.5;

        // Instrument timbre settings - Updated defaults
        let bassOscillatorType = 'sine'; // Default to Sine
        let synthOscillatorType = 'square'; // Default to Square
        let isSynthArpeggiatorActive = false; // New: Arpeggiator control

        // Delay effect nodes and parameters
        let delayNode;
        let delayFeedbackGain;
        let delaySendGain;
        let delayTimeValue = 0.3;
        let delayFeedbackValue = 0.4;
        let delaySendLevel = 0.5;

        // Chorus effect nodes and parameters
        let chorusNode;
        let chorusLFO;
        let chorusLfoGain;
        let chorusDepth = 0.002; // Default chorus depth (delay time modulation amount)
        let isChorusBypassed = true; // Default to bypassed

        // Compressor nodes and parameters
        let compressorNode;
        let compThreshold = -24;
        let compRatio = 12;

        // Reverb nodes and parameters
        let convolverNode;
        let reverbGainNode;
        let dryGainNode; // For the dry signal path in reverb mix
        let preCompressorGain; // New node for signal before compressor
        let reverbMix = 0.5;
        let isReverbBypassed = true;

        // New: Distortion effect nodes and parameters
        let distortionNode;
        let distortionAmount = 0; // Amount of distortion (0-1000 for curve intensity)
        let isDistortionBypassed = true;
        let postDistortionGain; // Intermediate gain node for distortion bypass

        // New: Phaser effect nodes and parameters
        let phaserLFO;
        let phaserLfoGain;
        let phaserFilterNodes = []; // Array of BiquadFilterNodes for the phaser stages
        const PHASER_STAGES = 6; // Number of all-pass filter stages for the phaser
        let phaserRate = 1; // LFO rate in Hz
        let phaserDepth = 0.5; // Modulation depth (0-1)
        let isPhaserBypassed = true;
        let phaserInputGain; // Input gain for phaser
        let postPhaserGain; // Output gain for phaser

        // Recording
        let looperRecorder;

        // Visualizer and Volume Meter elements
        let analyserNode;
        let audioVisualizerCanvas;
        let audioVisualizerCtx;
        let volumeMeterElement;
        let volumeMeterFillElement;
        let volumePeakElement; // For peak indicator
        let dataArray; // For analyser time domain data
        let frequencyDataArray; // For analyser frequency data
        let peakValue = 0; // Stores the highest volume peak (0-1 normalized)
        let visualizationMode = 'spectrum'; // 'spectrum', 'waveform', 'both', or 'bands'

        // For cycling through verse patterns (normal and Raga)
        const normalVerseOptions = {
            verse1: ['verse1_A', 'verse1_B', 'verse1_C', 'verse1_D'],
            verse2: ['verse2_A', 'verse2_B', 'verse2_C', 'verse2_D'],
            verse3: ['verse3_A', 'verse3_B', 'verse3_C']
        };
        // Updated: Added more Raga scales
        const ragaVerseOptions = ['ragaYamanPhrase', 'ragaBhairaviPhrase', 'ragaBhoopaliPhrase', 'ragaKhamajPhrase', 'ragaBhimpalasiPhrase', 'ragaKedarPhrase', 'ragaBageshriPhrase', 'ragaMalkaunsPhrase', 'ragaDarbariPhrase', 'ragaBhairavPhrase'];
        let availableRagas = [...ragaVerseOptions]; // Copy for shuffling
        let normalVerseIndex = 0;
        let verseIterationCount = 0;

        // Predefined frequencies for a simple musical scale
        const notes = {
            'A1': 55.00, 'A#1': 58.27, 'B1': 61.74,
            'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 97.99, 'G#2': 103.83,
            'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65,
            'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30,
            'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25
        };

        // Chromatic scale for transposition calculations
        const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const noteToSemitone = {};
        chromaticScale.forEach((note, index) => {
            noteToSemitone[note] = index;
        });

        // Circle of Fifths for key modulation
        const majorKeysCircleOfFifths = [
            'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'Db', 'Ab', 'Eb', 'Bb', 'F'
        ];
        const keyToSemitoneOffsetFromC = {
            'C': 0, 'G': 7, 'D': 2, 'A': 9, 'E': 4, 'B': 11, 'F#': 6,
            'Db': 1, 'Ab': 8, 'Eb': 3, 'Bb': 10, 'F': 5
        }; // Maps key name to semitone offset from C

        let currentKey = 'C'; // Initial key for the loop
        let sectionsSinceLastKeyChange = 0;
        let sectionsPerKeyChange = 2; // Base value, will be randomized

        let songIterationCount = 0; // New: Counter for full song iterations

        /**
         * Transposes an array of note strings by a given number of semitones.
         * @param {Array<string>} notesArray - An array of note strings (e.g., ['C4', 'G3']).
         * @param {number} semitones - The number of semitones to transpose by.
         * @returns {Array<string>} A new array with transposed note strings.
         */
        function transposeNotes(notesArray, semitones) {
            // Filter out any non-string or invalid notes first
            const validNotes = notesArray.filter(noteString => typeof noteString === 'string' && noteString.length >= 2);

            return validNotes.map(noteString => {
                const baseNote = noteString.slice(0, -1);
                const octave = parseInt(noteString.slice(-1));
                
                if (!noteToSemitone.hasOwnProperty(baseNote)) {
                    console.warn(`Unknown base note for transposition: ${baseNote}. Returning original.`);
                    return noteString; // Return original if unknown base note
                }

                let semitoneValue = noteToSemitone[baseNote] + semitones;
                let newOctave = octave + Math.floor(semitoneValue / 12);
                let newSemitoneIndex = (semitoneValue % 12 + 12) % 12; // Ensure positive modulo

                return chromaticScale[newSemitoneIndex] + newOctave;
            });
        }

        // Raga scale definitions (using C as tonic for simplicity)
        const ragaScales = {
            yaman: ['C4', 'D4', 'E4', 'F#4', 'G4', 'A4', 'B4', 'C5'],
            bhairavi: ['C4', 'C#4', 'D#4', 'F4', 'G4', 'G#4', 'A#4', 'C5'],
            bhoopali: ['C4', 'D4', 'E4', 'G4', 'A4', 'C5'], // Pentatonic scale
            khamaj: ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'A#4', 'C5'], // Natural minor with major 7th
            bhimpalasi: ['C4', 'Eb4', 'F4', 'G4', 'Bb4', 'C5'], // Sa Komal Ga Ma Pa Komal Ni (simplified for 6 notes)
            kedar: ['C4', 'D4', 'E4', 'F#4', 'G4', 'A4', 'B4', 'C5'], // Sa Re Ga Tivra Ma Pa Dha Ni (similar to Yaman, but different characteristic phrases)
            bageshri: ['C4', 'Eb4', 'F4', 'Ab4', 'Bb4', 'C5'], // Sa Komal Dha Ma Komal Dha Komal Ni (simplified for 6 notes)
            malkauns: ['C4', 'Eb4', 'F4', 'Ab4', 'Bb4', 'C5'], // Sa Komal Ga Ma Komal Dha Komal Ni (pentatonic, no Re, Pa)
            darbari: ['C4', 'D4', 'Eb4', 'F4', 'G4', 'Ab4', 'Bb4', 'C5'], // Sa Re Komal Ga Ma Pa Komal Dha Komal Ni
            bhairav: ['C4', 'C#4', 'E4', 'F4', 'G4', 'G#4', 'B4', 'C5'] // Sa Komal Re Ga Ma Pa Komal Dha Ni
        };

        // Raga Characteristics System - UPDATED to include new ragas
        const ragaCharacteristics = {
            time: {
                morning: ['yaman', 'bhairavi', 'bhoopali', 'bhairav'],
                afternoon: ['bhimpalasi', 'khamaj', 'kedar'],
                evening: ['yaman', 'kedar', 'bageshri'],
                night: ['bageshri', 'malkauns', 'darbari']
            },
            moods: {
                peaceful: ['bhoopali', 'yaman', 'bhairav'],
                energetic: ['bhairavi', 'khamaj', 'kedar'],
                melancholic: ['bhimpalasi', 'bageshri', 'malkauns', 'darbari'],
                romantic: ['khamaj', 'yaman', 'bageshri']
            }
        };

        /**
         * Selects a Raga appropriate for the current time of day.
         * @returns {string} The name of a time-appropriate Raga (e.g., 'yaman').
         */
        function selectTimeAppropriateRaga() {
            const hour = new Date().getHours();
            const timeOfDay = 
                hour >= 4 && hour < 8 ? 'morning' :
                hour >= 8 && hour < 16 ? 'afternoon' :
                hour >= 16 && hour < 20 ? 'evening' : 'night';
            
            const appropriateRagas = ragaCharacteristics.time[timeOfDay];
            // Filter to ensure we only pick ragas that are actually defined in ragaScales
            const availableAndDefinedRagas = appropriateRagas.filter(raga => ragaScales[raga]);

            if (availableAndDefinedRagas.length > 0) {
                return availableAndDefinedRagas[Math.floor(Math.random() * availableAndDefinedRagas.length)];
            } else {
                console.warn(`No defined Raga scales found for time of day: ${timeOfDay}. Falling back to 'yaman'.`);
                return 'yaman'; // Fallback to a default Raga if none are defined for the time
            }
        }


        /**
         * Generates a melodic phrase within a given Raga scale, with expressive variations.
         * @param {Array<string>} scale - Array of note names in the Raga scale (e.g., ['C4', 'D4', 'E4']).
         * @param {number} phraseLength - Number of steps in the phrase (e.g., 8).
         * @param {number} humanizationFactor - A factor influencing how "busy" or sparse the melody is (0-1).
         * @returns {Array<Object>} An array of phrase steps.
         */
        function generateRagaMelody(scale, phraseLength, humanizationFactor) {
            // Ensure scale is a non-empty array of strings
            if (!Array.isArray(scale) || scale.length === 0) {
                console.error("generateRagaMelody received an empty or invalid scale array:", scale);
                return []; // Return an empty phrase to prevent errors
            }

            const generatedPhrase = [];
            let currentSynthNoteIndex = Math.floor(Math.random() * scale.length); // Start randomly
            let lastSynthDirection = Math.random() < 0.5 ? 1 : -1;

            // Safely get vadiNote and samvadiNote, ensuring they are valid and default to first note if issues
            const getSafeNote = (arr, index) => arr[index] || arr[0];

            // Ensure scale has enough elements for Vadi/Samvadi
            const vadiNote = getSafeNote(scale, 0); // Tonic is often Vadi
            const samvadiNote = getSafeNote(scale, scale.length > 4 ? 4 : scale.length - 1); // Fifth or last note as Samvadi

            for (let i = 0; i < phraseLength; i++) {
                const step = {
                    bass: [],
                    synth: [],
                    percussion: {},
                    delaySend: 0.3 + (Math.random() * 0.3) // Vary delay send per step
                };

                // --- Bass Line Generation ---
                if (i % 4 === 0) { // On beat 1 and 5 (for 8-step phrase)
                    step.bass.push(vadiNote.replace('4', '2')); // Root
                } else if (i % 2 === 0) { // On other even beats
                    if (Math.random() < 0.7) { // 70% chance to play a bass note
                        const bassOptions = [
                            vadiNote.replace('4', '2'), // Root
                            samvadiNote.replace('4', '2') // Fifth
                        ];
                        if (scale.length > 2) { // Third
                            bassOptions.push(getSafeNote(scale, 2).replace('4', '2'));
                        }
                        const selectedBassNote = bassOptions[Math.floor(Math.random() * bassOptions.length)];
                        if (selectedBassNote) {
                            step.bass.push(selectedBassNote);
                        }
                    }
                }
                if (step.bass.length === 0) { // Ensure at least one bass note per main beat
                    step.bass.push(vadiNote.replace('4', '2'));
                }

                // --- Synth Melody Generation ---
                const numSynthNotes = 1 + Math.floor(Math.random() * (humanizationFactor * 2));
                let synthNotesForStep = [];

                for (let j = 0; j < numSynthNotes; j++) {
                    let nextSynthNoteIndex = currentSynthNoteIndex;

                    // Tendency towards stepwise motion
                    if (Math.random() < 0.7) { // 70% chance of stepwise motion
                        nextSynthNoteIndex = (currentSynthNoteIndex + lastSynthDirection + scale.length * 2) % scale.length;
                    } else if (Math.random() < 0.9) { // 20% chance of small leap (3rd or 4th)
                        const leapAmount = Math.random() < 0.5 ? 2 : 3; // 2 or 3 steps in scale
                        nextSynthNoteIndex = (currentSynthNoteIndex + lastSynthDirection * leapAmount + scale.length * 2) % scale.length;
                    } else { // 10% chance of larger leap or change direction
                        lastSynthDirection *= -1; // Change direction
                        const leapAmount = Math.floor(Math.random() * (scale.length / 2)) + 1; // Random leap
                        nextSynthNoteIndex = (currentSynthNoteIndex + lastSynthDirection * leapAmount + scale.length * 2) % scale.length;
                    }

                    // Emphasize Vadi/Samvadi
                    if (vadiNote && Math.random() < 0.3) { // 30% chance to gravitate towards Vadi
                        const targetVadiBaseNote = vadiNote.slice(0, -1);
                        let vadiIndex = scale.findIndex(note => note.startsWith(targetVadiBaseNote)); // Find note by base name
                        if (vadiIndex !== -1) {
                            nextSynthNoteIndex = vadiIndex;
                        } else {
                            nextSynthNoteIndex = Math.floor(Math.random() * scale.length);
                            console.warn(`Vadi note base ${targetVadiBaseNote} not found in current scale. Picking random note.`);
                        }
                    } else if (samvadiNote && Math.random() < 0.15) { // 15% chance for Samvadi
                        const targetSamvadiBaseNote = samvadiNote.slice(0, -1);
                        let samvadiIndex = scale.findIndex(note => note.startsWith(targetSamvadiBaseNote));
                        if (samvadiIndex !== -1) {
                            nextSynthNoteIndex = samvadiIndex;
                        } else {
                            nextSynthNoteIndex = Math.floor(Math.random() * scale.length);
                            console.warn(`Samvadi note base ${targetSamvadiBaseNote} not found in current scale. Picking random note.`);
                        }
                    }

                    currentSynthNoteIndex = nextSynthNoteIndex;

                    // Ensure currentSynthNoteIndex is valid and points to a defined note
                    if (currentSynthNoteIndex < 0 || currentSynthNoteIndex >= scale.length || !scale[currentSynthNoteIndex]) {
                        console.warn(`Invalid currentSynthNoteIndex (${currentSynthNoteIndex}) or undefined note in scale. Re-selecting random note.`);
                        currentSynthNoteIndex = Math.floor(Math.random() * scale.length);
                    }

                    let synthNote = scale[currentSynthNoteIndex];
                    const currentOctave = parseInt(synthNote.slice(-1));
                    
                    // Octave variation for synth notes
                    if (Math.random() < 0.3 * humanizationFactor) {
                        if (Math.random() < 0.5 && currentOctave < 5) {
                            synthNote = synthNote.slice(0, -1) + (currentOctave + 1);
                        } else if (currentOctave > 3) {
                            synthNote = synthNote.slice(0, -1) + (currentOctave - 1);
                        }
                    }
                    synthNotesForStep.push(synthNote);
                }
                
                // Add an arpeggiated chord if humanizationFactor is high and random chance
                if (humanizationFactor > 0.7 && Math.random() < 0.2) {
                    const rootIndex = currentSynthNoteIndex;
                    // Ensure indices are valid before accessing scale elements
                    const thirdNote = getSafeNote(scale, (rootIndex + 2) % scale.length);
                    const fifthNote = getSafeNote(scale, (rootIndex + 4) % scale.length);
                    
                    if (thirdNote) synthNotesForStep.push(thirdNote);
                    if (fifthNote) synthNotesForStep.push(fifthNote);
                }

                step.synth = synthNotesForStep.length > 0 ? synthNotesForStep : [getSafeNote(scale, currentSynthNoteIndex)]; // Ensure at least one note

                // --- Percussion Generation (more varied) ---
                if (i === 0) { // Kick on beat 1
                    step.percussion.kick = { active: true, probability: 0.95, velocity: 1.0 };
                    step.percussion.hihat = { active: true, probability: 1.0, type: 'closed', velocity: 0.8 };
                } else if (i === 4) { // Kick on beat 5
                    step.percussion.kick = { active: true, probability: 0.8, velocity: 0.9 };
                    step.percussion.hihat = { active: true, probability: 1.0, type: 'closed', velocity: 0.8 };
                } else if (i === 2 || i === 6) { // Snare on beats 3 and 7
                    step.percussion.snare = { active: true, probability: 0.85, velocity: 1.0 };
                    step.percussion.hihat = { active: true, probability: 1.0, type: 'closed', velocity: 0.8 };
                } else if (i % 2 !== 0) { // Off-beats, mostly hi-hats
                    if (Math.random() < 0.9) {
                        step.percussion.hihat = { active: true, probability: 1.0, type: 'closed', velocity: 0.7 };
                    }
                    if (Math.random() < 0.2) { // Occasional ghost kick/snare
                        if (Math.random() < 0.5) {
                            step.percussion.kick = { active: true, probability: 0.5, velocity: 0.3 };
                        } else {
                            step.percussion.snare = { active: true, probability: 0.5, velocity: 0.3 };
                        }
                    }
                }
                
                generatedPhrase.push(step);
            }
            return generatedPhrase;
        }


        // Define musical phrases for each section of the song.
        // All phrases are defined in the key of C Major. They will be transposed dynamically.
        // Percussion now includes 'active', 'probability', and 'velocity' for dynamic sequencing
        const musicalPhrases = {
            intro: [
                { bass: ['C2'], synth: ['C4'], percussion: {}, delaySend: 0.8 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.7 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.6 },
                { bass: ['F2'], synth: ['F3'], percussion: {}, delaySend: 0.5 },
                { bass: ['C2'], synth: ['C4', 'E4'], percussion: {}, delaySend: 0.4 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: {}, delaySend: 0.3 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: {}, delaySend: 0.2 },
                { bass: ['F2'], synth: ['F3', 'A3'], percussion: {}, delaySend: 0.1 },
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: {}, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: {}, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: {}, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: {}, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: {}, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: {}, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: {}, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: {}, delaySend: 0.0 }
            ],
            verse1_A: [ // C-G-Am-F progression
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3', 'C4', 'F4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_B: [ // C-G-Am-F progression with slightly different synth
                { bass: ['C2'], synth: ['E4', 'G4', 'C5'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3', 'D4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4', 'E4', 'A4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3', 'C4', 'F4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_C: [ // C-G-Am-F progression, more sparse synth
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse1_D: [ // C-G-Am-F progression, more active synth
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } } },
                { bass: ['G2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_A: [ // F-C-G-Am progression
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_B: [ // F-C-G-Am progression with slightly different synth
                { bass: ['F2'], synth: ['C4', 'F4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['G3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['D4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['E4', 'A4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_C: [ // F-C-G-Am progression, more sparse synth
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse2_D: [ // F-C-G-Am progression, more active synth
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['G3', 'E4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4', 'G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse3_A: [ // G-D-Em-C progression
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['D3', 'F#3', 'A3'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['F#3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['E2'], synth: ['E3', 'G3', 'B3'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['E2'], synth: ['G3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C3'], synth: ['C4', 'E4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C3'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse3_B: [ // G-D-Em-C progression with slightly different synth
                { bass: ['G2'], synth: ['D4', 'G4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['A3', 'D4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['F#3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['E2'], synth: ['B3', 'E4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['E2'], synth: ['G3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C3'], synth: ['G4', 'C5'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['C3'], synth: ['E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            verse3_C: [ // G-D-Em-C progression, more sparse synth
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['D3', 'A3'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['D2'], synth: ['F#3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['E2'], synth: ['E3', 'B3'], percussion: { kick: { active: true, probability: 0.9, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.3 },
                { bass: ['E2'], synth: ['G3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 },
                { bass: ['C3'], synth: ['C4', 'G4'], percussion: { snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.0 }
            ],
            // Raga phrases - these will be dynamically generated and thus are empty here
            ragaYamanPhrase: [],
            ragaBhairaviPhrase: [],
            ragaBhoopaliPhrase: [],
            ragaKhamajPhrase: [],
            ragaBhimpalasiPhrase: [], 
            ragaKedarPhrase: [],      
            ragaBageshriPhrase: [],   
            ragaMalkaunsPhrase: [],   
            ragaDarbariPhrase: [],    
            ragaBhairavPhrase: [],    
            
            chorus: [ // More full and impactful chorus
                { bass: ['C2'], synth: ['C4', 'E4', 'G4', 'C5'], percussion: { kick: { active: true, probability: 0.95, velocity: 1.0 }, snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['C2'], synth: ['G4', 'C5'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4', 'G4'], percussion: { kick: { active: true, probability: 0.95, velocity: 1.0 }, snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['G2'], synth: ['D4', 'G4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4', 'A4'], percussion: { kick: { active: true, probability: 0.95, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.8 } }, delaySend: 0.6 },
                { bass: ['A2'], synth: ['C4', 'E4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4', 'F4'], percussion: { kick: { active: true, probability: 0.95, velocity: 1.0 }, snare: { active: true, probability: 0.8, velocity: 1.0 }, hihat: { active: true, probability: 1.0, type: 'open', velocity: 0.9 } }, delaySend: 0.6 },
                { bass: ['F2'], synth: ['A3', 'C4'], percussion: { hihat: { active: true, probability: 1.0, type: 'closed', velocity: 0.7 } }, delaySend: 0.6 }
            ],
            bridge: [ // More atmospheric and building
                { bass: ['D2'], synth: ['D4', 'F4', 'A4'], percussion: { hihat: { active: true, probability: 0.5, type: 'closed', velocity: 0.6 } }, delaySend: 0.5 },
                { bass: ['E2'], synth: ['E4', 'G4', 'B4'], percussion: { hihat: { active: true, probability: 0.5, type: 'closed', velocity: 0.6 } }, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3', 'D4', 'G4'], percussion: { hihat: { active: true, probability: 0.5, type: 'closed', velocity: 0.6 } }, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4', 'F4', 'A4'], percussion: { hihat: { active: true, probability: 0.5, type: 'closed', velocity: 0.6 } }, delaySend: 0.5 },
                { bass: ['D2'], synth: ['D4', 'F4', 'A4', 'C5'], percussion: { kick: { active: true, probability: 0.6, velocity: 0.8 } }, delaySend: 0.6 },
                { bass: ['E2'], synth: ['E4', 'G4', 'B4', 'D5'], percussion: { snare: { active: true, probability: 0.6, velocity: 0.8 } }, delaySend: 0.6 },
                { bass: ['A2'], synth: ['A3', 'D4', 'G4', 'C5'], percussion: { kick: { active: true, probability: 0.6, velocity: 0.8 } }, delaySend: 0.6 },
                { bass: ['C3'], synth: ['C4', 'F4', 'A4', 'D5'], percussion: { snare: { active: true, probability: 0.6, velocity: 0.8 } }, delaySend: 0.6 }
            ],
            outro: [
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: {}, delaySend: 0.8 },
                { bass: ['G2'], synth: ['E4'], percussion: {}, delaySend: 0.7 },
                { bass: ['A2'], synth: ['C4'], percussion: {}, delaySend: 0.6 },
                { bass: ['F2'], synth: ['A3'], percussion: {}, delaySend: 0.5 },
                { bass: ['C2'], synth: ['C4'], percussion: {}, delaySend: 0.4 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.3 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.2 },
                { bass: ['F2'], synth: ['F3'], percussion: {}, delaySend: 0.0 }
            ]
        };

        const songStructure = [
            { type: 'intro', durationMultiplier: 2, initialKey: 'C' }, // Base key for intro
            { type: 'verse', baseName: 'verse1', durationMultiplier: 3, initialKey: 'C' }, // Base key for verse1
            { type: 'chorus', durationMultiplier: 2, initialKey: 'C' },
            { type: 'verse', baseName: 'verse2', durationMultiplier: 3, initialKey: 'C' }, // Base key for verse2
            { type: 'verse', baseName: 'verse3', durationMultiplier: 5, initialKey: 'C' }, // Base key for verse3
            { type: 'bridge', durationMultiplier: 2, initialKey: 'C' },
            { type: 'chorus', durationMultiplier: 3, initialKey: 'C' },
            { type: 'verse', baseName: 'verse1', durationMultiplier: 2, initialKey: 'C' },
            { type: 'outro', durationMultiplier: 2, initialKey: 'C' }
        ];

        let currentSongSectionIndex = 0;
        let currentSectionType = '';
        let currentSectionName = '';
        let currentSectionPhrase = []; // This will hold the *transposed* phrase for the current section
        let currentPhraseIndex = 0;
        let stepsPlayedInCurrentSection = 0;
        let currentSectionTotalSteps = 0;

        /**
         * Shuffles an array in place (Fisher-Yates algorithm).
         * @param {Array} array - The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * Gets the next Raga phrase from the available pool, ensuring non-repetition until all are played.
         * @returns {string} The name of the next Raga phrase.
         */
        function getNextRagaPhrase() {
            if (availableRagas.length === 0) {
                availableRagas = [...ragaVerseOptions];
                shuffleArray(availableRagas);
                console.log("Raga pool reset and shuffled:", availableRagas);
            }
            const nextRaga = availableRagas.shift();
            console.log("Next Raga:", nextRaga, "Remaining Ragas:", availableRagas);
            return nextRaga;
        }

        /**
         * Selects a random variation for a given normal verse base name.
         * @param {string} baseName - The base name of the verse (e.g., 'verse1').
         * @returns {string} The name of the selected verse variation (e.g., 'verse1_A').
         */
        function getRandomNormalVerseVariation(baseName) {
            const variations = normalVerseOptions[baseName];
            if (!variations || variations.length === 0) {
                console.warn(`No variations found for normal verse: ${baseName}`);
                return baseName;
            }
            const randomIndex = Math.floor(Math.random() * variations.length);
            return variations[randomIndex];
        }

        /**
         * Updates the display with the current song section and applies a highlight.
         */
        function updateSectionDisplay() {
            const displayElement = document.getElementById('currentSectionDisplay');
            if (displayElement) {
                const newText = `Current Section: ${currentSectionName.toUpperCase()} in ${currentKey} Major`;
                if (displayElement.textContent !== newText) {
                     displayElement.classList.remove('highlight');
                }
                displayElement.textContent = newText;
                requestAnimationFrame(() => {
                    displayElement.classList.add('highlight');
                });
            }
        }

        /**
         * Updates the display with the current song iteration count.
         */
        function updateSongIterationDisplay() {
            const displayElement = document.getElementById('songIterationDisplay');
            if (displayElement) {
                displayElement.textContent = `Song Iteration: ${songIterationCount}`;
            }
        }

        /**
         * Displays a temporary message to the user in a dedicated message box.
         * @param {string} message - The text message to display.
         * @param {number} duration - How long the message should be visible in milliseconds.
         */
        function showMessage(message, duration = 3000) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }

        /**
         * Generates a distortion curve for the WaveShaperNode.
         * @param {number} amount - The amount of distortion. Higher values mean more distortion.
         * @returns {Float32Array} A Float32Array representing the distortion curve.
         */
        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 0;
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            const deg = Math.PI / 180;
            for (let i = 0; i < n_samples; ++i) {
                const x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        /**
         * Updates the audio graph connection for distortion bypass.
         */
        function updateDistortionBypassConnection() {
            if (!audioContext || !masterGainNode || !distortionNode || !postDistortionGain || !phaserInputGain) return;

            // Disconnect masterGainNode from wherever it was connected
            try {
                masterGainNode.disconnect();
            } catch (e) { /* ignore */ }

            if (isDistortionBypassed) {
                // Bypass: masterGainNode -> postDistortionGain
                masterGainNode.connect(postDistortionGain);
            } else {
                // Engage: masterGainNode -> distortionNode -> postDistortionGain
                masterGainNode.connect(distortionNode);
                distortionNode.connect(postDistortionGain);
            }
            // Reconnect the next stage (phaser input)
            updatePhaserBypassConnection();
        }

        /**
         * Updates the audio graph connection for phaser bypass.
         */
        function updatePhaserBypassConnection() {
            if (!audioContext || !postDistortionGain || !phaserInputGain || phaserFilterNodes.length === 0 || !postPhaserGain || !chorusNode || !preCompressorGain) return;

            // Disconnect postDistortionGain from wherever it was connected
            try {
                postDistortionGain.disconnect();
            } catch (e) { /* ignore */ }
            
            // Disconnect phaser chain from wherever it was connected
            try {
                phaserFilterNodes[PHASER_STAGES - 1].disconnect();
            } catch (e) { /* ignore */ }

            if (isPhaserBypassed) {
                // Bypass: postDistortionGain -> postPhaserGain
                postDistortionGain.connect(postPhaserGain);
            } else {
                // Engage: postDistortionGain -> phaserInputGain -> phaserFilterNodes[0] -> ... -> phaserFilterNodes[last] -> postPhaserGain
                postDistortionGain.connect(phaserInputGain);
                phaserInputGain.connect(phaserFilterNodes[0]);
                phaserFilterNodes[PHASER_STAGES - 1].connect(postPhaserGain);
            }
            // Reconnect the next stage (chorus/preCompressorGain)
            updateChorusBypassConnection();
        }

        /**
         * Updates the audio graph connection for chorus bypass.
         */
        function updateChorusBypassConnection() {
            if (!audioContext || !postPhaserGain || !preCompressorGain || !chorusNode) return;

            // Disconnect postPhaserGain from wherever it was connected
            try {
                postPhaserGain.disconnect();
            } catch (e) { /* ignore */ }
            
            if (isChorusBypassed) {
                // Bypass: postPhaserGain -> preCompressorGain
                postPhaserGain.connect(preCompressorGain);
            } else {
                // Engage: postPhaserGain -> chorusNode -> preCompressorGain
                postPhaserGain.connect(chorusNode);
                chorusNode.connect(preCompressorGain);
            }
        }

        /**
         * Updates the audio graph connection for reverb bypass and wet/dry mix.
         */
        function updateReverbBypassConnection() {
            if (!audioContext || !preCompressorGain || !convolverNode || !reverbGainNode || !dryGainNode) return;

            // Disconnect existing connections from preCompressorGain to reverb/dry
            try {
                preCompressorGain.disconnect(dryGainNode);
                preCompressorGain.disconnect(reverbGainNode);
            } catch (e) { /* ignore */ }

            // Disconnect reverb output from preCompressorGain
            try {
                convolverNode.disconnect(preCompressorGain);
            } catch (e) { /* ignore */ }

            if (isReverbBypassed) {
                // Bypass: All signal directly to preCompressorGain (already connected through main chain)
                // No need to connect dryGainNode or reverbGainNode if bypassed, as preCompressorGain is already the main path.
                // The main chain is already connected like: masterGainNode -> ... -> preCompressorGain -> compressor -> analyser -> destination
                // So, if bypassed, the signal simply continues through the main path.
            } else {
                // Engage: Split signal to dry and wet paths, then sum them back to preCompressorGain
                dryGainNode.gain.setValueAtTime(1 - reverbMix, audioContext.currentTime);
                reverbGainNode.gain.setValueAtTime(reverbMix, audioContext.currentTime);

                preCompressorGain.connect(dryGainNode); // Send dry signal
                dryGainNode.connect(compressorNode); // Dry signal rejoins before compressor

                preCompressorGain.connect(reverbGainNode); // Send wet signal
                reverbGainNode.connect(convolverNode);
                convolverNode.connect(compressorNode); // Wet signal rejoins before compressor
            }
        }

        /**
         * Updates a specific audio parameter based on the UI element ID and its new value.
         * This function is crucial for linking UI knobs/sliders to audio graph parameters.
         * @param {string} id - The ID of the HTML input element (e.g., 'masterVolume', 'tempo').
         * @param {number|string} value - The new value from the input element.
         */
        function updateAudioParameter(id, value) {
            const valueDisplay = document.getElementById(id + 'Value');
            if (valueDisplay) {
                // Format display values for specific parameters
                if (id === 'compThreshold') {
                    valueDisplay.textContent = `${value} dB`;
                } else if (id === 'compRatio') {
                    valueDisplay.textContent = `${value}:1`;
                } else if (id === 'reverbMix') {
                    valueDisplay.textContent = `${(value * 100).toFixed(0)}%`;
                } else if (id === 'delayTime' || id === 'delayFeedback' || id === 'delaySendLevel' || id === 'chorusDepth' || id === 'phaserRate' || id === 'phaserDepth') {
                    valueDisplay.textContent = parseFloat(value).toFixed(2);
                } else {
                    valueDisplay.textContent = parseFloat(value).toFixed(2);
                }
            }

            // Update global variables and audio nodes
            if (audioContext) {
                const currentTime = audioContext.currentTime;
                switch (id) {
                    case 'masterVolume':
                        masterVolume = value;
                        if (masterGainNode) masterGainNode.gain.setValueAtTime(masterVolume, currentTime);
                        break;
                    case 'tempo':
                        targetTempo = value; // Update targetTempo
                        break;
                    case 'bassVolume':
                        bassVolume = value;
                        break;
                    case 'synthVolume':
                        synthVolume = value;
                        break;
                    case 'kickVolume':
                        kickVolume = value;
                        break;
                    case 'snareVolume':
                        snareVolume = value;
                        break;
                    case 'hihatVolume':
                        hihatVolume = value;
                        break;
                    case 'bassOscillatorType': // New
                        bassOscillatorType = value;
                        break;
                    case 'synthOscillatorType': // New
                        synthOscillatorType = value;
                        break;
                    case 'delayTime':
                        delayTimeValue = value;
                        if (delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, currentTime);
                        break;
                    case 'delayFeedback':
                        delayFeedbackValue = value;
                        if (delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, currentTime);
                        break;
                    case 'delaySendLevel':
                        delaySendLevel = value;
                        // This will be applied per step in the scheduler, but update the global variable
                        break;
                    case 'chorusDepth':
                        chorusDepth = value;
                        if (chorusLfoGain) chorusLfoGain.gain.setValueAtTime(chorusDepth, currentTime);
                        break;
                    case 'compThreshold':
                        compThreshold = value;
                        if (compressorNode) compressorNode.threshold.setValueAtTime(compThreshold, currentTime);
                        break;
                    case 'compRatio':
                        compRatio = value;
                        if (compressorNode) compressorNode.ratio.setValueAtTime(compRatio, currentTime);
                        break;
                    case 'reverbMix':
                        reverbMix = value;
                        if (reverbGainNode) reverbGainNode.gain.setValueAtTime(reverbMix, currentTime);
                        if (dryGainNode) dryGainNode.gain.setValueAtTime(1 - reverbMix, currentTime);
                        break;
                    case 'distortionAmount': // New
                        distortionAmount = value;
                        if (distortionNode) distortionNode.curve = makeDistortionCurve(distortionAmount);
                        break;
                    case 'phaserRate': // New
                        phaserRate = value;
                        if (phaserLFO) phaserLFO.frequency.setValueAtTime(phaserRate, currentTime);
                        break;
                    case 'phaserDepth': // New
                        phaserDepth = value;
                        if (phaserLfoGain) phaserLfoGain.gain.setValueAtTime(phaserDepth * 1000, currentTime); // Scale for frequency modulation
                        break;
                }
            }
        }

        /**
         * Selects the next key based on weighted probabilities for musical coherence.
         * Favors tonic, dominant, subdominant, and nearby keys on the Circle of Fifths.
         * @param {string} currentKey - The current key (e.g., 'C').
         * @returns {string} The newly selected key.
         */
        function selectNextKey(currentKey) {
            const currentKeyIndex = majorKeysCircleOfFifths.indexOf(currentKey);
            let nextKey = currentKey; // Default to staying in the same key
            let transitionMessage = `Staying in ${currentKey} Major.`;

            // Probabilities (sum to 1.0)
            const probabilities = {
                tonic: 0.40, // Stay in current key
                dominant: 0.30, // Move to dominant (e.g., C -> G)
                subdominant: 0.20, // Move to subdominant (e.g., C -> F)
                nearbyRandom: 0.10 // Move to a nearby key (e.g., +/- 2 or 3 steps on CoF)
            };

            const rand = Math.random();
            let cumulativeProbability = 0;

            // Tonic
            cumulativeProbability += probabilities.tonic;
            if (rand < cumulativeProbability) {
                nextKey = currentKey;
                transitionMessage = `Staying in ${currentKey} Major.`;
            } else {
                // Dominant
                cumulativeProbability += probabilities.dominant;
                if (rand < cumulativeProbability) {
                    nextKey = majorKeysCircleOfFifths[(currentKeyIndex + 1) % majorKeysCircleOfFifths.length];
                    transitionMessage = `Modulating to Dominant: ${nextKey} Major!`;
                } else {
                    // Subdominant
                    cumulativeProbability += probabilities.subdominant;
                    if (rand < cumulativeProbability) {
                        nextKey = majorKeysCircleOfFifths[(currentKeyIndex - 1 + majorKeysCircleOfFifths.length) % majorKeysCircleOfFifths.length];
                        transitionMessage = `Modulating to Subdominant: ${nextKey} Major!`;
                    } else {
                        // Nearby Random (e.g., +/- 2 or 3 steps on CoF)
                        let offset;
                        do {
                            offset = Math.floor(Math.random() * 6) - 3; // -3, -2, -1, 1, 2, 3 (avoid 0)
                            if (offset >= 0) offset += 1; // Ensure no 0
                        } while (offset === 0);
                        
                        const newIndex = (currentKeyIndex + offset + majorKeysCircleOfFifths.length * 2) % majorKeysCircleOfFifths.length;
                        nextKey = majorKeysCircleOfFifths[newIndex];
                        transitionMessage = `Modulating to a nearby key: ${nextKey} Major!`;
                    }
                }
            }
            showMessage(transitionMessage, 2500);
            return nextKey;
        }


        /**
         * Initializes the Web Audio API context and the main audio graph nodes.
         * This function needs to be called after a user gesture (e.g., button click)
         * to comply with browser autoplay policies.
         * @returns {boolean} True if audio context was successfully initialized or already exists, false otherwise.
         */
        function initAudio() {
            console.log("Attempting to initialize audio context...");
            if (!audioContext) {
                try {
                    showMessage("Loading Audio System...", 5000); // Show loading message
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Main Gain Node - first in the chain
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = masterVolume;

                    // Distortion Effect
                    distortionNode = audioContext.createWaveShaper();
                    distortionNode.curve = makeDistortionCurve(distortionAmount);
                    distortionNode.oversample = '4x'; // High quality oversampling
                    postDistortionGain = audioContext.createGain(); // For bypass

                    // Phaser Effect
                    phaserInputGain = audioContext.createGain(); // Input gain for phaser bypass
                    postPhaserGain = audioContext.createGain(); // Output gain for phaser bypass

                    // Create phaser filter stages (all-pass filters)
                    for (let i = 0; i < PHASER_STAGES; i++) {
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'allpass';
                        filter.frequency.value = 1000; // Base frequency, will be modulated
                        filter.Q.value = 1; // Resonance
                        phaserFilterNodes.push(filter);
                    }

                    // Connect phaser stages in series
                    for (let i = 0; i < PHASER_STAGES - 1; i++) {
                        phaserFilterNodes[i].connect(phaserFilterNodes[i + 1]);
                    }

                    // Create Phaser LFO for modulation
                    phaserLFO = audioContext.createOscillator();
                    phaserLFO.type = 'sine';
                    phaserLFO.frequency.value = phaserRate;
                    phaserLFO.start(0);

                    phaserLfoGain = audioContext.createGain();
                    phaserLfoGain.gain.value = phaserDepth * 1000; // Modulate frequency range
                    phaserLFO.connect(phaserLfoGain);

                    // Connect LFO to each filter's frequency parameter
                    phaserFilterNodes.forEach(filter => {
                        phaserLfoGain.connect(filter.frequency);
                    });

                    // Chorus Effect
                    chorusNode = audioContext.createDelay(0.01); // Max delay for chorus, typically very small
                    chorusLFO = audioContext.createOscillator();
                    chorusLfoGain = audioContext.createGain();

                    chorusLFO.type = 'sine';
                    chorusLFO.frequency.value = 1.5; // LFO frequency (rate of modulation)
                    chorusLfoGain.gain.value = chorusDepth; // Depth of modulation
                    
                    chorusLFO.connect(chorusLfoGain);
                    chorusLfoGain.connect(chorusNode.delayTime);
                    chorusLFO.start(audioContext.currentTime); // Start LFO immediately

                    // Node where all instrument outputs connect before effects
                    // This is the source for the main audio path
                    preCompressorGain = audioContext.createGain(); // Renamed for clarity: this is where dry and wet signals meet before compressor

                    // Delay Effect (Feedback Delay)
                    delayNode = audioContext.createDelay(2.0); // Max delay time of 2 seconds
                    delayFeedbackGain = audioContext.createGain();
                    delaySendGain = audioContext.createGain(); // Controls how much signal goes TO the delay

                    delayNode.delayTime.value = delayTimeValue;
                    delayFeedbackGain.gain.value = delayFeedbackValue;
                    delaySendGain.gain.value = delaySendLevel;

                    // Connect delay: preCompressorGain -> delaySendGain -> delay -> feedback -> delay -> preCompressorGain (wet return)
                    delaySendGain.connect(delayNode);
                    delayNode.connect(delayFeedbackGain);
                    delayFeedbackGain.connect(delayNode); // Feedback loop
                    delayNode.connect(preCompressorGain); // Wet delay signal returns to preCompressorGain

                    // Compressor Node
                    compressorNode = audioContext.createDynamicsCompressor();
                    compressorNode.threshold.value = compThreshold;
                    compressorNode.knee.value = 30; // Default value, not exposed to UI
                    compressorNode.ratio.value = compRatio;
                    compressorNode.attack.value = 0.003; // Default value
                    compressorNode.release.value = 0.25; // Default value

                    // Reverb Effect (Convolver)
                    convolverNode = audioContext.createConvolver();
                    reverbGainNode = audioContext.createGain(); // Wet signal gain for reverb
                    dryGainNode = audioContext.createGain(); // Dry signal gain for reverb mix

                    // Create a simple synthetic impulse response for reverb
                    const impulseLength = 2; // seconds
                    const sampleRate = audioContext.sampleRate;
                    const impulseBuffer = audioContext.createBuffer(2, sampleRate * impulseLength, sampleRate);
                    const leftChannel = impulseBuffer.getChannelData(0);
                    const rightChannel = impulseBuffer.getChannelData(1);

                    for (let i = 0; i < sampleRate * impulseLength; i++) {
                        // Simple decaying noise burst
                        leftChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / (sampleRate * impulseLength), 2);
                        rightChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / (sampleRate * impulseLength), 2);
                    }
                    convolverNode.buffer = impulseBuffer;
                    reverbGainNode.gain.value = reverbMix;
                    dryGainNode.gain.value = 1 - reverbMix; // Initial dry mix

                    // Analyser Node for Visualization and Volume Meter
                    analyserNode = audioContext.createAnalyser();
                    analyserNode.fftSize = 256; // For time domain data
                    analyserNode.smoothingTimeConstant = 0.8; // Smoother visualization
                    analyserNode.minDecibels = -90;
                    analyserNode.maxDecibels = -10;
                    
                    // Initialize data arrays with correct sizes
                    dataArray = new Uint8Array(analyserNode.frequencyBinCount); // For time domain visualization
                    frequencyDataArray = new Uint8Array(analyserNode.frequencyBinCount); // For frequency visualization and volume meter

                    // Connect the main audio graph:
                    // masterGainNode -> Distortion -> Phaser -> Chorus -> preCompressorGain -> Compressor -> Analyser -> Destination
                    // Send effects (Delay, Reverb) from preCompressorGain

                    // 1. Master Gain -> Distortion (if active) OR postDistortionGain
                    updateDistortionBypassConnection(); // Handles masterGainNode -> distortion/postDistortionGain

                    // 2. postDistortionGain -> Phaser (if active) OR postPhaserGain
                    updatePhaserBypassConnection(); // Handles postDistortionGain -> phaser/postPhaserGain

                    // 3. postPhaserGain -> Chorus (if active) OR preCompressorGain
                    updateChorusBypassConnection(); // Handles postPhaserGain -> chorus/preCompressorGain

                    // 4. preCompressorGain -> Compressor
                    preCompressorGain.connect(compressorNode);

                    // 5. Compressor -> Analyser
                    compressorNode.connect(analyserNode);

                    // 6. Analyser always connects to destination
                    analyserNode.connect(audioContext.destination);

                    // Connect send effects (Delay, Reverb) from preCompressorGain
                    preCompressorGain.connect(delaySendGain); // Send signal to delay
                    // Reverb is now connected from preCompressorGain to dry/wet paths
                    updateReverbBypassConnection();

                    // Initialize UI elements for visualization and volume meter
                    audioVisualizerCanvas = document.getElementById('audioVisualizer');
                    audioVisualizerCtx = audioVisualizerCanvas.getContext('2d');
                    volumeMeterElement = document.getElementById('volumeMeter');
                    volumeMeterFillElement = document.getElementById('volumeMeterFill');
                    volumePeakElement = document.getElementById('volumePeak');

                    // Set initial values for delay
                    delayNode.delayTime.value = delayTimeValue;
                    delayFeedbackGain.gain.value = delayFeedbackValue;
                    delaySendGain.gain.value = delaySendLevel;

                    // Initialize recorder
                    looperRecorder = new EnhancedLooperRecorder(audioContext);

                    showMessage(`Audio context initialized. Master Gain: ${masterVolume.toFixed(2)}`);
                    console.log("AudioContext initialized successfully. State:", audioContext.state);
                } catch (e) {
                    showMessage("Web Audio API is not supported in this browser or could not be initialized. Please try a different browser.", 5000);
                    console.error("Web Audio API error:", e);
                    return false;
                }
            } else {
                console.log("AudioContext already exists. State:", audioContext.state);
            }
            return true;
        }

        /**
         * Plays a single musical note using an oscillator and applies a simple ADSR envelope,
         * detune, and a low-pass filter.
         * @param {number} frequency - The frequency of the note in Hz.
         * @param {number} startTime - The AudioContext.currentTime when the note should start.
         * @param {number} duration - The duration of the note in seconds.
         * @param {number} detuneValue - The detune value in cents.
         * @param {number} filterFreq - The cutoff frequency for the low-pass filter.
         * @param {number} filterQ - The Q factor for the low-pass filter.
         * @param {string} instrumentType - 'bass' or 'synth' to determine timbre.
         * @param {number} velocity - The velocity (0-1) of the note.
         */
        function playNote(frequency, startTime, duration, detuneValue = currentDetune, filterFreq = currentFilterFrequency, filterQ = currentFilterQ, instrumentType = 'synth', velocity = 1.0) {
            if (!audioContext || !masterGainNode || !preCompressorGain) { // Ensure preCompressorGain is available
                console.warn("Cannot play note: AudioContext or main gain nodes not available.");
                return;
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();

            const timingOffset = (Math.random() - 0.5) * 0.08 * humanizationFactor;
            const dynamicFactor = 1 + (Math.random() - 0.5) * 0.6 * humanizationFactor;
            const durationFactor = 1 + (Math.random() - 0.5) * 0.3 * humanizationFactor;

            const actualStartTime = Math.max(0, startTime + timingOffset);
            const actualDuration = duration * durationFactor;

            let attackTime = 0.05;
            let decayTime = 0.2;
            let sustainLevel = 0.5;
            let releaseTime = 0.2;
            let initialGain;
            let oscType; // Determined by UI selection

            switch (instrumentType) {
                case 'bass':
                    oscType = bassOscillatorType; // Use selected type
                    attackTime = 0.02;
                    decayTime = 0.3;
                    sustainLevel = 0.5;
                    releaseTime = 0.2;
                    initialGain = bassVolume * velocity; // Apply velocity
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(400, actualStartTime);
                    filterNode.Q.setValueAtTime(0.8, actualStartTime);
                    break;
                case 'synth':
                default:
                    oscType = synthOscillatorType; // Use selected type
                    attackTime = 0.1;
                    decayTime = 0.5;
                    sustainLevel = 0.6;
                    releaseTime = 0.8;
                    initialGain = synthVolume * velocity; // Apply velocity
                    filterNode.type = 'lowpass';
                    
                    const initialFilterFreq = filterFreq * (1 + (Math.random() - 0.5) * 0.2 * humanizationFactor);
                    const finalFilterFreq = filterFreq;
                    filterNode.frequency.setValueAtTime(initialFilterFreq, actualStartTime);
                    filterNode.frequency.linearRampToValueAtTime(finalFilterFreq, actualStartTime + 0.5);
                    
                    filterNode.Q.setValueAtTime(filterQ, actualStartTime);
                    break;
            }

            oscillator.type = oscType;
            oscillator.frequency.setValueAtTime(frequency, actualStartTime);
            oscillator.detune.setValueAtTime(detuneValue, actualStartTime);

            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(masterGainNode); // Connect to masterGainNode
            
            gainNode.gain.setValueAtTime(0, actualStartTime);
            gainNode.gain.linearRampToValueAtTime(initialGain * dynamicFactor, actualStartTime + attackTime);
            gainNode.gain.linearRampToValueAtTime(initialGain * dynamicFactor * sustainLevel, actualStartTime + attackTime + decayTime);

            const releaseStartTime = Math.max(actualStartTime, actualStartTime + actualDuration - releaseTime);
            const finalReleaseTime = Math.max(actualStartTime + attackTime + decayTime, releaseStartTime);

            gainNode.gain.exponentialRampToValueAtTime(0.0001, finalReleaseTime);
            gainNode.gain.linearRampToValueAtTime(0, Math.max(actualStartTime, actualStartTime + actualDuration));

            oscillator.start(actualStartTime);
            oscillator.stop(Math.max(actualStartTime, actualStartTime + actualDuration));

            oscillator.onended = () => {
                oscillator.disconnect();
                gainNode.disconnect();
                filterNode.disconnect();
            };
        }

        /**
         * Plays a simple drum sound using a short, decaying sine wave.
         * @param {number} startTime - The AudioContext.currentTime when the drum sound should start.
         * @param {number} velocity - The velocity (0-1) of the drum hit.
         */
        function playDrum(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play drum: AudioContext or masterGainNode not available.");
                return;
            }

            const drumOscillator = audioContext.createOscillator();
            const drumGain = audioContext.createGain();
            const drumFilter = audioContext.createBiquadFilter();

            const actualStartTime = Math.max(0, startTime);

            drumOscillator.type = 'sine';
            drumOscillator.frequency.setValueAtTime(120, actualStartTime); // Start frequency
            drumOscillator.frequency.exponentialRampToValueAtTime(30, actualStartTime + 0.1); // Decay to 30Hz

            drumFilter.type = 'lowpass';
            drumFilter.frequency.setValueAtTime(500, actualStartTime); // Initial filter frequency
            drumFilter.frequency.exponentialRampToValueAtTime(100, actualStartTime + 0.15); // Decay filter
            drumFilter.Q.setValueAtTime(0.8, actualStartTime);

            drumOscillator.connect(drumFilter);
            drumFilter.connect(drumGain);
            drumGain.connect(masterGainNode); // Connect to masterGainNode

            drumGain.gain.setValueAtTime(kickVolume * velocity, actualStartTime); // Apply velocity
            drumGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.2); // Quick decay

            drumOscillator.start(actualStartTime);
            drumOscillator.stop(actualStartTime + 0.2);

            drumOscillator.onended = () => {
                drumOscillator.disconnect();
                drumGain.disconnect();
                drumFilter.disconnect();
            };
        }

        /**
         * Plays a snare drum sound using white noise and an oscillator.
         * @param {number} startTime - The AudioContext.currentTime when the snare sound should start.
         * @param {number} velocity - The velocity (0-1) of the snare hit.
         */
        function playSnare(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play snare: AudioContext or masterGainNode not available.");
                return;
            }

            const actualStartTime = Math.max(0, startTime);

            // Noise component
            const noise = audioContext.createBufferSource();
            const bufferSize = audioContext.sampleRate * 0.2;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(snareVolume * 0.7 * velocity, actualStartTime); // Apply velocity
            noiseGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.15);
            noise.connect(noiseGain);

            // Tone component
            const osc = audioContext.createOscillator();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, actualStartTime);
            osc.frequency.exponentialRampToValueAtTime(100, actualStartTime + 0.1);

            const oscGain = audioContext.createGain();
            oscGain.gain.setValueAtTime(snareVolume * 1.0 * velocity, actualStartTime); // Apply velocity
            oscGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.1);
            osc.connect(oscGain);

            // Mixer for noise and tone
            const mixer = audioContext.createGain();
            noiseGain.connect(mixer);
            oscGain.connect(mixer);
            mixer.connect(masterGainNode); // Connect to masterGainNode

            noise.start(actualStartTime);
            osc.start(actualStartTime);
            noise.stop(actualStartTime + 0.2);
            osc.stop(actualStartTime + 0.2);

            osc.onended = () => {
                noise.disconnect();
                osc.disconnect();
                noiseGain.disconnect();
                oscGain.disconnect();
                mixer.disconnect();
            };
        }

        /**
         * Plays a closed hi-hat sound.
         * @param {number} startTime - The AudioContext.currentTime when the hi-hat sound should start.
         * @param {number} velocity - The velocity (0-1) of the hi-hat hit.
         */
        function playHiHatClosed(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) return;

            const actualStartTime = Math.max(0, startTime);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(10000, actualStartTime); // High frequency for hi-hat
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(7000, actualStartTime); // Filter out lower frequencies
            filter.Q.setValueAtTime(0.5, actualStartTime);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGainNode); // Connect to masterGainNode

            gain.gain.setValueAtTime(hihatVolume * 0.7 * velocity, actualStartTime); // Apply velocity
            gain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.05); // Quick decay for closed hi-hat

            osc.start(actualStartTime);
            osc.stop(actualStartTime + 0.05);

            osc.onended = () => {
                osc.disconnect(); 
                gain.disconnect();
                filter.disconnect();
            };
        }

        /**
         * Plays an open hi-hat sound.
         * @param {number} startTime - The AudioContext.currentTime when the hi-hat sound should start.
         * @param {number} velocity - The velocity (0-1) of the hi-hat hit.
         */
        function playHiHatOpen(startTime, velocity = 1.0) {
            if (!audioContext || !masterGainNode) return;

            const actualStartTime = Math.max(0, startTime);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(8000, actualStartTime); // Slightly lower frequency for open hi-hat
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(5000, actualStartTime);
            filter.Q.setValueAtTime(0.5, actualStartTime);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGainNode); // Connect to masterGainNode

            gain.gain.setValueAtTime(hihatVolume * 1.0 * velocity, actualStartTime); // Apply velocity
            gain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.2); // Longer decay for open hi-hat

            osc.start(actualStartTime);
            osc.stop(actualStartTime + 0.2);

            osc.onended = () => {
                osc.disconnect(); 
                gain.disconnect();
                filter.disconnect();
            };
        }

        /**
         * Plays an arpeggiated sequence of notes for the synth.
         * @param {Array<string>} notesArray - Array of note names (e.g., ['C4', 'E4', 'G4']).
         * @param {number} startTime - The AudioContext.currentTime when the arpeggio should start.
         * @param {number} totalDuration - The total duration the arpeggio should occupy.
         * @param {number} detuneValue - The detune value in cents.
         * @param {number} filterFreq - The cutoff frequency for the low-pass filter.
         * @param {number} filterQ - The Q factor for the low-pass filter.
         * @param {number} velocity - The base velocity for the arpeggio notes.
         */
        function playArpeggio(notesArray, startTime, totalDuration, detuneValue, filterFreq, filterQ, velocity) {
            if (!audioContext || notesArray.length === 0) return;

            const noteDuration = totalDuration / notesArray.length; // Duration for each note in the arpeggio
            let currentArpTime = startTime;

            notesArray.forEach(noteName => {
                const frequency = notes[noteName];
                if (frequency) {
                    // Apply slight velocity variation for humanization within arpeggio
                    const arpVelocity = velocity * (1 + (Math.random() - 0.5) * 0.2);
                    playNote(frequency, currentArpTime, noteDuration * 0.8, detuneValue, filterFreq, filterQ, 'synth', arpVelocity); // Shorten note slightly for separation
                }
                currentArpTime += noteDuration;
            });
        }

        /**
         * Applies subtle, random changes to various musical parameters for the next musical step.
         * These changes are applied on top of the user-controlled knob values.
         */
        function applySubtleChanges() {
            const driftScale = fibonacciDriftScales[currentFibonacciDriftScaleIndex];

            // Tempo drift (more noticeable, but still subtle)
            targetTempo += tempoDriftDirection * (Math.random() * driftScale * 10 + 2); // Larger drift step
            if (targetTempo > 650) { // Limit tempo range for drift
                tempoDriftDirection = -1;
            } else if (targetTempo < 380) {
                tempoDriftDirection = 1;
            }
            targetTempo = Math.max(300, Math.min(900, targetTempo)); // Keep within overall knob limits

            // Smoothly interpolate currentTempo towards targetTempo
            currentTempo += (targetTempo - currentTempo) * 0.08; // Adjust 0.08 for faster interpolation

            currentDetune += detuneDriftDirection * (Math.random() * driftScale * 2 + 0.5);
            if (currentDetune > 20) { // Slightly wider detune range
                detuneDriftDirection = -1;
            } else if (currentDetune < -20) {
                detuneDriftDirection = 1;
            }
            currentDetune = Math.max(-20, Math.min(20, currentDetune));

            currentFilterFrequency += filterDriftDirection * (Math.random() * driftScale * 100 + 20); // Larger filter drift
            if (currentFilterFrequency > 4000) { // Wider filter range
                filterDriftDirection = -1;
            } else if (currentFilterFrequency < 400) {
                filterDriftDirection = 1;
            }
            currentFilterFrequency = Math.max(400, Math.min(4000, currentFilterFrequency));

            currentFilterQ += (Math.random() - 0.5) * driftScale * 0.8; // More Q drift
            currentFilterQ = Math.max(0.3, Math.min(4, currentFilterQ)); // Wider Q range

            baseNoteDuration += (Math.random() - 0.5) * driftScale * 0.08; // More duration drift
            baseNoteDuration = Math.max(0.2, Math.min(0.8, baseNoteDuration)); // Wider duration range

            humanizationFactor += (Math.random() - 0.5) * driftScale * 0.15; // More humanization drift
            humanizationFactor = Math.max(0.1, Math.min(1.0, humanizationFactor));

            delayTimeValue += delayTimeDriftDirection * (Math.random() - 0.5) * driftScale * 0.05; // More delay time drift
            if (delayTimeValue > 1.5) {
                delayTimeDriftDirection = -1;
            } else if (delayTimeValue < 0.05) {
                delayTimeDriftDirection = 1;
            }
            delayTimeValue = Math.max(0.01, Math.min(2.0, delayTimeValue));
            if (audioContext && delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, audioContext.currentTime);

            delayFeedbackValue += delayFeedbackDriftDirection * (Math.random() - 0.5) * driftScale * 0.03; // More feedback drift
            if (delayFeedbackValue > 0.9) {
                delayFeedbackDriftDirection = -1;
            } else if (delayFeedbackValue < 0.05) {
                delayFeedbackDriftDirection = 1;
            }
            delayFeedbackValue = Math.max(0, Math.min(0.95, delayFeedbackValue));
            if (audioContext && delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, audioContext.currentTime);
        }

        /**
         * The main audio scheduling loop. It continuously checks if there are events
         * to be played in the near future and schedules them using AudioContext.currentTime.
         * This method is more precise than setTimeout for timing musical events.
         */
        function scheduler() {
            if (!isPlaying || !audioContext) {
                console.log("Scheduler stopping: isPlaying=", isPlaying, " audioContext=", audioContext);
                return;
            }

            while (nextNoteTime < audioContext.currentTime + 0.1) {
                const currentStep = currentSectionPhrase[currentPhraseIndex];
                
                // Robust check for currentStep and its essential properties
                if (!currentStep || typeof currentStep !== 'object' || !Array.isArray(currentStep.synth) || !Array.isArray(currentStep.bass) || typeof currentStep.percussion !== 'object' || currentStep.percussion === null) {
                    console.error(`Invalid or malformed currentStep at index ${currentPhraseIndex}:`, currentStep);
                    // Attempt to recover by forcing a section transition
                    currentPhraseIndex = 0; // Reset index for the new section
                    stepsPlayedInCurrentSection = currentSectionTotalSteps; // Force transition
                    continue; // Skip to the next iteration of the while loop
                }

                const duration = baseNoteDuration;
                const baseVelocity = 0.7 + (Math.random() * 0.3); // Base velocity for notes

                const effectiveDelaySend = (currentStep.delaySend !== undefined ? currentStep.delaySend : 0.5) * delaySendLevel;
                if (audioContext && delaySendGain) {
                    delaySendGain.gain.linearRampToValueAtTime(effectiveDelaySend, audioContext.currentTime + 0.05);
                }

                if (currentStep.synth && currentStep.synth.length > 0) {
                    if (isSynthArpeggiatorActive) {
                        playArpeggio(currentStep.synth, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, baseVelocity);
                    } else {
                        currentStep.synth.forEach(noteName => {
                            const frequency = notes[noteName];
                            if (frequency) {
                                playNote(frequency, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, 'synth', baseVelocity);
                            } else {
                                console.warn(`Synth note frequency not found for note: ${noteName}`);
                            }
                        });
                    }
                }

                if (currentStep.bass && currentStep.bass.length > 0) {
                    currentStep.bass.forEach(noteName => {
                        const frequency = notes[noteName];
                        if (frequency) {
                            playNote(frequency, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, 'bass', baseVelocity);
                        } else {
                            console.warn(`Bass note frequency not found for note: ${noteName}`);
                        }
                    });
                }

                // Percussion logic updated to use probability and velocity
                if (currentStep.percussion) {
                    if (currentStep.percussion.kick && currentStep.percussion.kick.active && Math.random() < currentStep.percussion.kick.probability) {
                        playDrum(nextNoteTime, currentStep.percussion.kick.velocity);
                    }
                    if (currentStep.percussion.snare && currentStep.percussion.snare.active && Math.random() < currentStep.percussion.snare.probability) {
                        playSnare(nextNoteTime, currentStep.percussion.snare.velocity);
                    }
                    if (currentStep.percussion.hihat && currentStep.percussion.hihat.active && Math.random() < currentStep.percussion.hihat.probability) {
                        if (currentStep.percussion.hihat.type === 'closed') {
                            playHiHatClosed(nextNoteTime, currentStep.percussion.hihat.velocity);
                        } else if (currentStep.percussion.hihat.type === 'open') {
                            playHiHatOpen(nextNoteTime, currentStep.percussion.hihat.velocity);
                        }
                    }
                }

                nextNoteTime += (currentTempo / 1000); // Use the dynamically adjusted currentTempo
                
                stepsPlayedInCurrentSection++;
                currentPhraseIndex++;
                applySubtleChanges();

                if (currentPhraseIndex >= currentSectionPhrase.length) {
                    currentPhraseIndex = 0;
                }

                if (stepsPlayedInCurrentSection >= currentSectionTotalSteps) {
                    console.log(`End of section '${currentSectionName}' reached.`);
                    currentPhraseIndex = 0;
                    stepsPlayedInCurrentSection = 0;
                    currentSongSectionIndex++;

                    currentFibonacciDriftScaleIndex = (currentFibonacciDriftScaleIndex + 1) % fibonacciDriftScales.length;

                    if (currentSongSectionIndex >= songStructure.length) {
                        currentSongSectionIndex = 0;
                        songIterationCount++; // Increment song iteration count
                        updateSongIterationDisplay(); // Update display
                        console.log("End of song structure reached. Looping back to Intro. Song Iteration:", songIterationCount);
                    }

                    const nextSectionDef = songStructure[currentSongSectionIndex];
                    currentSectionType = nextSectionDef.type;
                    let phraseToUse = []; // Temporary variable to hold the phrase before assignment
                    
                    // Key Change Logic
                    let previousKey = currentKey;
                    sectionsSinceLastKeyChange++;

                    if (sectionsSinceLastKeyChange >= sectionsPerKeyChange) {
                        currentKey = selectNextKey(previousKey); // Use the new function for weighted key selection
                        sectionsSinceLastKeyChange = 0; // Reset counter
                        // Introduce variability to the next key change interval
                        sectionsPerKeyChange = Math.floor(Math.random() * 3) + 2; // Randomly 2, 3, or 4 sections
                        console.log(`Next key change will happen in ${sectionsPerKeyChange} sections.`);
                    } else {
                        // If not time for a key change, just keep the current key
                        showMessage(`Staying in ${currentKey} Major.`, 2500); // Re-emphasize current key
                    }

                    const semitonesToTranspose = keyToSemitoneOffsetFromC[currentKey] - keyToSemitoneOffsetFromC['C'];

                    if (currentSectionType === 'verse' && verseIterationCount % 2 === 0) {
                        // This block handles Raga sections
                        const selectedRagaName = selectTimeAppropriateRaga(); // Use the function to select a time-appropriate raga
                        currentSectionName = `raga${selectedRagaName.charAt(0).toUpperCase() + selectedRagaName.slice(1)}Phrase`; // Format for display
                        
                        const selectedRagaScale = ragaScales[selectedRagaName]; // Get the actual scale array

                        // Safeguard: Ensure selectedRagaScale is a valid, non-empty array
                        if (selectedRagaScale && Array.isArray(selectedRagaScale) && selectedRagaScale.length > 0) {
                            // Transpose the Raga scale from its base (C) to the new key
                            const transposedRagaScale = transposeNotes(selectedRagaScale, semitonesToTranspose);
                            phraseToUse = generateRagaMelody(transposedRagaScale, 8, humanizationFactor);
                        } else {
                            console.error(`Invalid or empty Raga scale found for name: ${selectedRagaName}. Falling back to a default verse.`);
                            currentSectionName = getRandomNormalVerseVariation('verse1'); // Fallback to a known good verse
                            // Transpose the fallback phrase to the new key
                            phraseToUse = musicalPhrases[currentSectionName].map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                        }
                    } else { // Normal verse variations or other sections
                        if (currentSectionType === 'verse') {
                            currentSectionName = getRandomNormalVerseVariation(nextSectionDef.baseName);
                        } else {
                            currentSectionName = nextSectionDef.type; // For intro, chorus, bridge, outro
                        }
                        // Transpose the base phrase (which is in C) to the new key
                        const basePhrase = musicalPhrases[currentSectionName];
                        if (basePhrase && Array.isArray(basePhrase)) {
                             phraseToUse = basePhrase.map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                        } else {
                            console.error(`Base phrase for section '${currentSectionName}' is undefined or not an array. Falling back to intro.`);
                            currentSectionName = 'intro';
                            phraseToUse = musicalPhrases.intro.map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                        }
                    }
                    
                    // Assign the determined/generated phrase to currentSectionPhrase
                    currentSectionPhrase = phraseToUse;

                    // Safeguard: Ensure the phrase is not empty after selection/generation.
                    // If it is, fall back to a known good phrase.
                    if (!currentSectionPhrase || currentSectionPhrase.length === 0) {
                        console.warn(`Section '${currentSectionName}' resulted in an empty phrase. Falling back to intro.`);
                        currentSectionName = 'intro';
                        currentSectionPhrase = musicalPhrases.intro.map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                        currentKey = songStructure[0].initialKey || 'C'; // Reset key to intro's key
                        currentSectionTotalSteps = currentSectionPhrase.length * nextSectionDef.durationMultiplier;
                    }

                    // Calculate total steps based on the *final* currentSectionPhrase length
                    currentSectionTotalSteps = currentSectionPhrase.length * nextSectionDef.durationMultiplier;

                    console.log(`Transitioning to section: ${currentSectionName} (type: ${currentSectionType}) in ${currentKey} Major for ${currentSectionTotalSteps} steps. Humanization Factor: ${humanizationFactor.toFixed(2)}`);
                    updateSectionDisplay();
                }
            }

            loopTimeoutId = setTimeout(scheduler, 50);
        }

        /**
         * Starts the music looping. Handles initial audio context setup and resumption.
         */
        function startLoop() {
            console.log("Start button clicked. Attempting to start loop.");
            if (!initAudio()) {
                console.error("Audio initialization failed. Cannot start loop.");
                return;
            }

            if (audioContext.state === 'suspended') {
                console.log("AudioContext is suspended. Attempting to resume...");
                showMessage("Resuming audio context...");
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully!');
                    startLoopInternal();
                }).catch(e => {
                    showMessage("Could not resume audio context. Please try again or check browser settings.", 3000);
                    console.error("AudioContext resume error:", e);
                });
            } else {
                console.log("AudioContext is already running or pending. Starting loop directly.");
                startLoopInternal();
            }
        }

        /**
         * Internal function to start the music loop after audio context is ready.
         */
        function startLoopInternal() {
            if (isPlaying) {
                console.log("Loop is already playing. Skipping start.");
                return;
            }

            isPlaying = true;
            nextNoteTime = audioContext.currentTime;
            
            currentSongSectionIndex = 0;
            songIterationCount = 0; // Reset iteration count on fresh start
            updateSongIterationDisplay(); // Update display

            const initialSectionDef = songStructure[currentSongSectionIndex];
            currentSectionType = initialSectionDef.type;
            currentKey = initialSectionDef.initialKey || 'C'; // Set initial key

            let initialPhraseToUse = [];
            const semitonesToTranspose = keyToSemitoneOffsetFromC[currentKey] - keyToSemitoneOffsetFromC['C'];

            if (currentSectionType === 'verse' && verseIterationCount % 2 === 0) {
                verseIterationCount = 1;
                currentSectionName = initialSectionDef.baseName + '_A'; // Start with verse1_A
                // Transpose the initial verse phrase to the initial key
                const basePhrase = musicalPhrases[currentSectionName];
                initialPhraseToUse = basePhrase.map(step => ({
                    ...step,
                    bass: transposeNotes(step.bass, semitonesToTranspose),
                    synth: transposeNotes(step.synth, semitonesToTranspose)
                }));
                console.log(`Forcing initial verse to start with: ${currentSectionName} in ${currentKey} Major`);
            } else {
                currentSectionName = initialSectionDef.type; // For intro, chorus, bridge, outro
                // Transpose the initial non-verse phrase to its initial key
                const basePhrase = musicalPhrases[currentSectionName];
                initialPhraseToUse = basePhrase.map(step => ({
                    ...step,
                    bass: transposeNotes(step.bass, semitonesToTranspose),
                    synth: transposeNotes(step.synth, semitonesToTranspose)
                }));
            }

            currentSectionPhrase = initialPhraseToUse; // Assign the determined phrase

            shuffleArray(availableRagas);

            currentPhraseIndex = 0;
            stepsPlayedInCurrentSection = 0;
            sectionsSinceLastKeyChange = 0; // Reset key change counter at start
            sectionsPerKeyChange = Math.floor(Math.random() * 3) + 2; // Initialize with random 2-4 sections

            // Calculate total steps based on the assigned currentSectionPhrase length
            currentSectionTotalSteps = currentSectionPhrase.length * initialSectionDef.durationMultiplier;

            // Safeguard for initial phrase if it somehow ends up empty (though unlikely for 'intro')
            if (!currentSectionPhrase || currentSectionPhrase.length === 0) {
                console.warn(`Initial section phrase for '${currentSectionName}' is empty. Falling back to intro.`);
                currentSectionName = 'intro';
                currentSectionPhrase = musicalPhrases.intro.map(step => ({
                                ...step,
                                bass: transposeNotes(step.bass, semitonesToTranspose),
                                synth: transposeNotes(step.synth, semitonesToTranspose)
                            }));
                currentKey = songStructure[0].initialKey || 'C'; // Reset key to intro's key
                currentSectionTotalSteps = currentSectionPhrase.length * initialSectionDef.durationMultiplier;
            }

            updateSectionDisplay();
            console.log(`Starting with section: ${currentSectionName} (type: ${currentSectionType}) in ${currentKey} Major for ${currentSectionTotalSteps} steps. Humanization Factor: ${humanizationFactor.toFixed(2)}`);

            masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
            masterGainNode.gain.linearRampToValueAtTime(masterVolume, audioContext.currentTime + 4);

            scheduler();
            initializeVisualization(); // Call the visualization function after audio context is running
            
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false; /* Corrected: Enable stop button */
            showMessage("Music started. Enjoy the evolving structured loop!");
            console.log("Music loop started.");
        }

        /**
         * Stops the music looping by clearing the scheduler timeout and suspending the audio context.
         */
        function stopLoop() {
            console.log("Stop button clicked. Attempting to stop loop.");
            isPlaying = false;
            clearTimeout(loopTimeoutId);

            if (audioContext && masterGainNode) {
                masterGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                masterGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
                setTimeout(() => {
                    if (audioContext && audioContext.state === 'running') {
                        audioContext.suspend().then(() => {
                            console.log('AudioContext suspended successfully!');
                            showMessage("Music stopped.");
                        }).catch(e => {
                            showMessage("Could not suspend audio context.", 3000);
                            console.error("AudioContext suspend error:", e);
                        });
                    } else {
                        console.log("AudioContext is not running or already suspended.");
                        showMessage("Music stopped.");
                    }
                }, 1000);
            } else {
                console.log("AudioContext or masterGainNode not available for smooth stop.");
                showMessage("Music stopped.");
            }
            
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            console.log("Music loop stopped.");
        }

        /**
         * The main drawing loop for audio visualization.
         * Draws waveform, frequency bars, and updates the volume meter.
         */
        function initializeVisualization() {
            if (!analyserNode || !audioVisualizerCtx) return;
            
            // Start the drawing loop
            drawVisualizationLoop();
        }

        /**
         * The main drawing loop for audio visualization.
         * Draws waveform, frequency bars, and updates the volume meter.
         */
        function drawVisualizationLoop() {
            if (!isPlaying || !analyserNode || !audioVisualizerCtx) {
                // Clear canvas and reset meters when not playing
                if (audioVisualizerCtx) {
                    audioVisualizerCtx.clearRect(0, 0, audioVisualizerCanvas.width, audioVisualizerCanvas.height);
                }
                if (volumeMeterFillElement) {
                    volumeMeterFillElement.style.width = '0%';
                }
                if (volumePeakElement) {
                    volumePeakElement.style.opacity = 0;
                }
                return;
            }

            requestAnimationFrame(drawVisualizationLoop);

            const width = audioVisualizerCanvas.width;
            const height = audioVisualizerCanvas.height;

            // Get both waveform and frequency data
            analyserNode.getByteTimeDomainData(dataArray);
            analyserNode.getByteFrequencyData(frequencyDataArray);
            
            // Clear canvas
            audioVisualizerCtx.fillStyle = '#000';
            audioVisualizerCtx.fillRect(0, 0, width, height);
            
            // Draw based on visualizationMode
            if (visualizationMode === 'spectrum') {
                // Draw frequency spectrum (bars) with gradient
                const gradient = audioVisualizerCtx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#ff0000'); // Red at the top (highest intensity)
                gradient.addColorStop(0.5, '#ffff00'); // Yellow in the middle
                gradient.addColorStop(1, '#00ff00'); // Green at the bottom (lowest intensity)
                audioVisualizerCtx.fillStyle = gradient;
                
                const barWidth = width / analyserNode.frequencyBinCount; // Adjusted for better distribution
                
                for(let i = 0; i < analyserNode.frequencyBinCount; i++) {
                    const barHeight = (frequencyDataArray[i] / 255) * height;
                    audioVisualizerCtx.fillRect(
                        i * barWidth,
                        height - barHeight,
                        barWidth - 1, // Small gap between bars
                        barHeight
                    );
                }
            } else if (visualizationMode === 'waveform') {
                // Draw waveform overlay
                audioVisualizerCtx.beginPath();
                audioVisualizerCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // Semi-transparent white for waveform
                audioVisualizerCtx.lineWidth = 2;
                
                const sliceWidth = width * 1.0 / dataArray.length;
                let x = 0;
                
                for(let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0; // Normalize to 0-2
                    const y = v * height/2;
                    
                    if(i === 0) {
                        audioVisualizerCtx.moveTo(x, y);
                    } else {
                        audioVisualizerCtx.lineTo(x, y);
                    }
                    x += sliceWidth;
                }
                
                audioVisualizerCtx.lineTo(width, height/2);
                audioVisualizerCtx.stroke();
            } else if (visualizationMode === 'both') {
                // Draw frequency spectrum (bars) with gradient
                const gradient = audioVisualizerCtx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#ff0000'); // Red at the top (highest intensity)
                gradient.addColorStop(0.5, '#ffff00'); // Yellow in the middle
                gradient.addColorStop(1, '#00ff00'); // Green at the bottom (lowest intensity)
                audioVisualizerCtx.fillStyle = gradient;
                
                const barWidth = width / analyserNode.frequencyBinCount;
                
                for(let i = 0; i < analyserNode.frequencyBinCount; i++) {
                    const barHeight = (frequencyDataArray[i] / 255) * height;
                    audioVisualizerCtx.fillRect(
                        i * barWidth,
                        height - barHeight,
                        barWidth - 1,
                        barHeight
                    );
                }

                // Draw waveform overlay
                audioVisualizerCtx.beginPath();
                audioVisualizerCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                audioVisualizerCtx.lineWidth = 2;
                
                const sliceWidth = width * 1.0 / dataArray.length;
                let x = 0;
                
                for(let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * height/2;
                    
                    if(i === 0) {
                        audioVisualizerCtx.moveTo(x, y);
                    } else {
                        audioVisualizerCtx.lineTo(x, y);
                    }
                    x += sliceWidth;
                }
                
                audioVisualizerCtx.lineTo(width, height/2);
                audioVisualizerCtx.stroke();
            } else if (visualizationMode === 'bands') {
                // Draw separate bands for bass, mid, treble
                const nyquist = audioContext.sampleRate / 2;
                const binWidth = nyquist / analyserNode.frequencyBinCount;

                // Define frequency ranges for bands (approximate)
                const bassMaxFreq = 250; // Hz
                const midMaxFreq = 2000; // Hz
                // Treble is everything above midMaxFreq

                // Calculate bin indices for each band
                const bassEndBin = Math.floor(bassMaxFreq / binWidth);
                const midEndBin = Math.floor(midMaxFreq / binWidth);

                let bassEnergy = 0;
                let midEnergy = 0;
                let trebleEnergy = 0;

                // Sum energy for each band
                for (let i = 0; i < analyserNode.frequencyBinCount; i++) {
                    const value = frequencyDataArray[i];
                    if (i <= bassEndBin) {
                        bassEnergy += value;
                    } else if (i <= midEndBin) {
                        midEnergy += value;
                    } else {
                        trebleEnergy += value;
                    }
                }

                // Normalize energy (average value per bin in that band)
                const bassAvg = bassEndBin > 0 ? bassEnergy / bassEndBin : 0;
                const midAvg = (midEndBin - bassEndBin) > 0 ? midEnergy / (midEndBin - bassEndBin) : 0;
                const trebleAvg = (analyserNode.frequencyBinCount - midEndBin) > 0 ? trebleEnergy / (analyserNode.frequencyBinCount - midEndBin) : 0;

                const maxEnergy = 255; // Max value for byte data

                const barWidth = (width / 3) - 5; // 3 bars with some spacing
                const spacing = 5;

                // Draw Bass Bar (Reddish)
                audioVisualizerCtx.fillStyle = `hsl(0, 100%, ${50 + (bassAvg / maxEnergy) * 40}%)`; // Adjust lightness based on intensity
                const bassHeight = (bassAvg / maxEnergy) * height;
                audioVisualizerCtx.fillRect(spacing, height - bassHeight, barWidth, bassHeight);
                audioVisualizerCtx.fillText('Bass', spacing + barWidth / 2 - 15, height - bassHeight - 5);


                // Draw Mid Bar (Greenish)
                audioVisualizerCtx.fillStyle = `hsl(120, 100%, ${50 + (midAvg / maxEnergy) * 40}%)`;
                const midHeight = (midAvg / maxEnergy) * height;
                audioVisualizerCtx.fillRect(spacing * 2 + barWidth, height - midHeight, barWidth, midHeight);
                audioVisualizerCtx.fillText('Mid', spacing * 2 + barWidth / 2 + barWidth - 10, height - midHeight - 5);

                // Draw Treble Bar (Blueish)
                audioVisualizerCtx.fillStyle = `hsl(240, 100%, ${50 + (trebleAvg / maxEnergy) * 40}%)`;
                const trebleHeight = (trebleAvg / maxEnergy) * height;
                audioVisualizerCtx.fillRect(spacing * 3 + barWidth * 2, height - trebleHeight, barWidth, trebleHeight);
                audioVisualizerCtx.fillText('Treble', spacing * 3 + barWidth * 2 + barWidth / 2 - 20, height - trebleHeight - 5);
                
                audioVisualizerCtx.fillStyle = '#e0e0e0'; // Reset text color
                audioVisualizerCtx.font = '10px Arial';
                audioVisualizerCtx.textAlign = 'center';
            }
            
            // Update volume meter
            updateVolumeMeter();
        }

        /**
         * Updates the master volume meter and peak indicator.
         */
        function updateVolumeMeter() {
            if (!analyserNode || !volumeMeterFillElement || !volumePeakElement) return;
            
            // frequencyDataArray is already updated in drawVisualizationLoop
            
            // Calculate RMS volume
            let sum = 0;
            for(let i = 0; i < frequencyDataArray.length; i++) {
                sum += frequencyDataArray[i] * frequencyDataArray[i];
            }
            const rms = Math.sqrt(sum / frequencyDataArray.length);
            const volume = rms / 255; // Normalize to 0-1
            
            // Update meter fill
            volumeMeterFillElement.style.width = `${volume * 100}%`;
            
            // Update peak indicator
            if (volume > peakValue) {
                peakValue = volume;
                volumePeakElement.style.right = `${(1 - peakValue) * 100}%`; // Position from right
                volumePeakElement.style.opacity = '1';
                
                // Clear previous fade-out timeout and set a new one
                clearTimeout(volumePeakElement.fadeTimeout);
                volumePeakElement.fadeTimeout = setTimeout(() => {
                    volumePeakElement.style.opacity = '0.5'; // Fade to 0.5 opacity
                    // Start a slower decay of the peak value itself
                    clearTimeout(volumePeakElement.decayTimeout);
                    volumePeakElement.decayTimeout = setTimeout(() => {
                        peakValue *= 0.95; // Decay peak value
                        if (peakValue < 0.01) peakValue = 0; // Reset if too low
                    }, 500); // Start decaying peak value after it fades slightly
                }, 1000); // Peak indicator fades after 1 second
            }
        }


        /**
         * Manages saving and loading presets to/from local storage.
         */
        class PresetManager {
            constructor() {
                this.storageKeyPrefix = 'simple_relax_preset_'; // Renamed prefix
                this.autoSaveKey = 'simple_relax_autosave_settings'; // Renamed key
            }

            /**
             * Saves the current settings as a preset.
             * @param {string} name - The name of the preset.
             * @param {Object} settings - The settings object to save.
             * @returns {boolean} True if saved successfully, false otherwise.
             */
            savePreset(name, settings) {
                try {
                    const preset = {
                        settings: settings,
                        timestamp: Date.now(),
                        metadata: {
                            author: 'User',
                            description: `Saved at ${new Date().toLocaleString()}`,
                            tags: []
                        }
                    };
                    localStorage.setItem(this.storageKeyPrefix + name, JSON.stringify(preset));
                    return true;
                } catch (e) {
                    console.error('Preset save failed:', e);
                    return false;
                }
            }

            /**
             * Loads a preset by name.
             * @param {string} name - The name of the preset to load.
             * @returns {Object|null} The loaded settings object, or null if not found.
             */
            loadPreset(name) {
                try {
                    const presetString = localStorage.getItem(this.storageKeyPrefix + name);
                    if (presetString) {
                        const preset = JSON.parse(presetString);
                        return preset.settings;
                    }
                    return null;
                } catch (e) {
                    console.error('Preset load failed:', e);
                    return null;
                }
            }

            /**
             * Auto-saves the current settings.
             */
            autoSaveSettings() {
                try {
                    const settings = getCurrentSettings();
                    localStorage.setItem(this.autoSaveKey, JSON.stringify(settings));
                    console.log("Settings auto-saved.");
                } catch (e) {
                    console.warn("Auto-save failed:", e);
                }
            }

            /**
             * Loads auto-saved settings.
             * @returns {Object|null} The auto-saved settings, or null if none exist.
             */
            loadAutoSavedSettings() {
                try {
                    const settingsString = localStorage.getItem(this.autoSaveKey);
                    if (settingsString) {
                        return JSON.parse(settingsString);
                    }
                    return null;
                } catch (e) {
                    console.warn("Failed to load auto-saved settings:", e);
                    return null;
                }
            }

            /**
             * Exports all saved presets to a JSON file.
             */
            exportAllPresets() {
                try {
                    const allPresets = {};
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key.startsWith(this.storageKeyPrefix)) {
                            allPresets[key.replace(this.storageKeyPrefix, '')] = JSON.parse(localStorage.getItem(key));
                        }
                    }
                    const dataStr = JSON.stringify(allPresets, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `simple_relax_presets_${new Date().toISOString().replace(/:/g, '-')}.json`; // Renamed filename
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage("All presets exported successfully!");
                } catch (e) {
                    console.error("Failed to export presets:", e);
                    showMessage("Failed to export presets. See console for details.", 3000);
                }
            }

            /**
             * Imports presets from a JSON file.
             * @param {File} file - The JSON file containing presets.
             */
            importPresets(file) {
                if (!file) {
                    showMessage("No file selected for import.", 2000);
                    return;
                }
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedPresets = JSON.parse(event.target.result);
                        let importedCount = 0;
                        for (const name in importedPresets) {
                            if (importedPresets.hasOwnProperty(name) && importedPresets[name].settings) {
                                // Ensure the imported preset has a 'settings' property
                                if (this.savePreset(name, importedPresets[name].settings)) {
                                    importedCount++;
                                }
                            }
                        }
                        showMessage(`Successfully imported ${importedCount} presets!`);
                    } catch (e) {
                        console.error("Failed to parse imported presets file:", e);
                        showMessage("Failed to import presets. Invalid file format.", 3000);
                    }
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e);
                    showMessage("Error reading file. Please try again.", 3000);
                };
                reader.readAsText(file);
            }
        }

        const presetManager = new PresetManager();

        /**
         * Collects all current knob values into an object.
         * @returns {Object} An object containing all current settings.
         */
        function getCurrentSettings() {
            return {
                masterVolume: parseFloat(document.getElementById('masterVolume').value),
                tempo: parseFloat(document.getElementById('tempo').value),
                bassVolume: parseFloat(document.getElementById('bassVolume').value),
                synthVolume: parseFloat(document.getElementById('synthVolume').value),
                kickVolume: parseFloat(document.getElementById('kickVolume').value),
                snareVolume: parseFloat(document.getElementById('snareVolume').value),
                hihatVolume: parseFloat(document.getElementById('hihatVolume').value),
                bassOscillatorType: document.getElementById('bassOscillatorType').value, // New
                synthOscillatorType: document.getElementById('synthOscillatorType').value, // New
                isSynthArpeggiatorActive: document.getElementById('synthArpeggiator').checked, // New
                delayTime: parseFloat(document.getElementById('delayTime').value),
                delayFeedback: parseFloat(document.getElementById('delayFeedback').value),
                delaySendLevel: parseFloat(document.getElementById('delaySendLevel').value),
                chorusDepth: parseFloat(document.getElementById('chorusDepth').value),
                isChorusBypassed: document.getElementById('chorusBypass').checked,
                currentDetune: currentDetune,
                currentFilterFrequency: currentFilterFrequency,
                currentFilterQ: currentFilterQ,
                baseNoteDuration: baseNoteDuration,
                humanizationFactor: humanizationFactor,
                // Compressor settings
                compThreshold: parseFloat(document.getElementById('compThreshold').value),
                compRatio: parseFloat(document.getElementById('compRatio').value),
                // Reverb settings
                reverbMix: parseFloat(document.getElementById('reverbMix').value),
                isReverbBypassed: document.getElementById('reverbBypass').checked,
                // New: Distortion settings
                distortionAmount: parseFloat(document.getElementById('distortionAmount').value),
                isDistortionBypassed: document.getElementById('distortionBypass').checked,
                // New: Phaser settings
                phaserRate: parseFloat(document.getElementById('phaserRate').value),
                phaserDepth: parseFloat(document.getElementById('phaserDepth').value),
                isPhaserBypassed: document.getElementById('phaserBypass').checked
            };
        }

        /**
         * Applies saved settings to the knobs and global variables.
         * @param {Object} settings - An object containing settings to apply.
         */
        function applySettings(settings) {
            // Apply settings to UI elements and trigger their input events to update audio parameters
            document.getElementById('masterVolume').value = settings.masterVolume;
            document.getElementById('masterVolume').dispatchEvent(new Event('input'));

            document.getElementById('tempo').value = settings.tempo;
            document.getElementById('tempo').dispatchEvent(new Event('input'));

            document.getElementById('bassVolume').value = settings.bassVolume;
            document.getElementById('bassVolume').dispatchEvent(new Event('input'));

            document.getElementById('synthVolume').value = settings.synthVolume;
            document.getElementById('synthVolume').dispatchEvent(new Event('input'));

            document.getElementById('kickVolume').value = settings.kickVolume;
            document.getElementById('kickVolume').dispatchEvent(new Event('input'));

            document.getElementById('snareVolume').value = settings.snareVolume;
            document.getElementById('snareVolume').dispatchEvent(new Event('input'));

            document.getElementById('hihatVolume').value = settings.hihatVolume;
            document.getElementById('hihatVolume').dispatchEvent(new Event('input'));

            // New: Instrument oscillator types
            document.getElementById('bassOscillatorType').value = settings.bassOscillatorType;
            bassOscillatorType = settings.bassOscillatorType; // Update global variable
            document.getElementById('synthOscillatorType').value = settings.synthOscillatorType;
            synthOscillatorType = settings.synthOscillatorType; // Update global variable
            
            document.getElementById('synthArpeggiator').checked = settings.isSynthArpeggiatorActive; // New
            isSynthArpeggiatorActive = settings.isSynthArpeggiatorActive; // Update global variable

            document.getElementById('delayTime').value = settings.delayTime;
            document.getElementById('delayTime').dispatchEvent(new Event('input'));

            document.getElementById('delayFeedback').value = settings.delayFeedback;
            document.getElementById('delayFeedback').dispatchEvent(new Event('input'));

            document.getElementById('delaySendLevel').value = settings.delaySendLevel;
            document.getElementById('delaySendLevel').dispatchEvent(new Event('input'));

            document.getElementById('chorusDepth').value = settings.chorusDepth;
            document.getElementById('chorusDepth').dispatchEvent(new Event('input'));
            
            document.getElementById('chorusBypass').checked = settings.isChorusBypassed;
            document.getElementById('chorusBypass').dispatchEvent(new Event('change')); // Trigger change event

            document.getElementById('compThreshold').value = settings.compThreshold;
            document.getElementById('compThreshold').dispatchEvent(new Event('input'));

            document.getElementById('compRatio').value = settings.compRatio;
            document.getElementById('compRatio').dispatchEvent(new Event('input'));
            
            document.getElementById('reverbMix').value = settings.reverbMix;
            document.getElementById('reverbMix').dispatchEvent(new Event('input'));

            document.getElementById('reverbBypass').checked = settings.isReverbBypassed;
            document.getElementById('reverbBypass').dispatchEvent(new Event('change')); // Trigger change event

            // New: Distortion settings
            document.getElementById('distortionAmount').value = settings.distortionAmount;
            document.getElementById('distortionAmount').dispatchEvent(new Event('input'));
            document.getElementById('distortionBypass').checked = settings.isDistortionBypassed;
            document.getElementById('distortionBypass').dispatchEvent(new Event('change'));

            // New: Phaser settings
            document.getElementById('phaserRate').value = settings.phaserRate;
            document.getElementById('phaserRate').dispatchEvent(new Event('input'));
            document.getElementById('phaserDepth').value = settings.phaserDepth;
            document.getElementById('phaserDepth').dispatchEvent(new Event('input'));
            document.getElementById('phaserBypass').checked = settings.isPhaserBypassed;
            document.getElementById('phaserBypass').dispatchEvent(new Event('change'));

            // Update global variables that are not directly tied to a knob
            currentDetune = settings.currentDetune;
            currentFilterFrequency = settings.currentFilterFrequency;
            currentFilterQ = settings.currentFilterQ;
            baseNoteDuration = settings.baseNoteDuration;
            humanizationFactor = settings.humanizationFactor;

            showMessage("Preset loaded successfully!");
            console.log("Settings applied:", settings);
        }

        /**
         * Saves the current knob settings to local storage using PresetManager.
         */
        function savePreset() {
            const presetNameInput = document.getElementById('presetNameInput');
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                showMessage("Please enter a name for your preset.", 2000);
                return;
            }

            // Check if preset already exists
            if (localStorage.getItem(presetManager.storageKeyPrefix + presetName)) {
                // Modified to use custom message box instead of confirm
                const confirmOverwrite = () => {
                    const confirmBox = document.createElement('div');
                    confirmBox.style.cssText = `
                        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        background-color: #3a3a3a; padding: 20px; border-radius: 10px;
                        box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 1000;
                        color: #e0e0e0; text-align: center;
                    `;
                    confirmBox.innerHTML = `
                        <p>Preset "${presetName}" already exists. Do you want to overwrite it?</p>
                        <button id="confirmOverwriteYes" style="margin-right: 10px;">Yes</button>
                        <button id="confirmOverwriteNo">No</button>
                    `;
                    document.body.appendChild(confirmBox);

                    document.getElementById('confirmOverwriteYes').onclick = () => {
                        document.body.removeChild(confirmBox);
                        const settings = getCurrentSettings();
                        if (presetManager.savePreset(presetName, settings)) {
                            showMessage(`Preset "${presetName}" saved!`);
                            console.log(`Preset "${presetName}" saved:`, settings);
                        } else {
                            showMessage("Failed to save preset. Local storage might be full or unavailable.", 3000);
                        }
                    };
                    document.getElementById('confirmOverwriteNo').onclick = () => {
                        document.body.removeChild(confirmBox);
                        showMessage("Preset save cancelled.", 2000);
                    };
                };
                confirmOverwrite();
                return;
            }

            const settings = getCurrentSettings();
            if (presetManager.savePreset(presetName, settings)) {
                showMessage(`Preset "${presetName}" saved!`);
                console.log(`Preset "${presetName}" saved:`, settings);
            } else {
                showMessage("Failed to save preset. Local storage might be full or unavailable.", 3000);
            }
        }

        /**
         * Loads a preset from local storage and applies its settings using PresetManager.
         */
        function loadPreset() {
            const presetNameInput = document.getElementById('presetNameInput');
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                showMessage("Please enter the name of the preset to load.", 2000);
                return;
            }
            const settings = presetManager.loadPreset(presetName);
            if (settings) {
                applySettings(settings);
            } else {
                showMessage(`Preset "${presetName}" not found.`, 2000);
                console.warn(`Preset "${presetName}" not found.`);
            }
        }
        
        // Enhanced LooperRecorder Class
        class EnhancedLooperRecorder {
            constructor(audioContext) {
                this.audioContext = audioContext;
                this.mediaRecorder = null;
                this.chunks = [];
                this.isRecording = false;
                this.recordingStartTime = 0;
                // Ensure this selector matches the HTML element
                this.recordingMeter = document.querySelector('.recording-meter');
                this.recordingFormatSelect = document.getElementById('recordingFormat');
                this.selectedFormat = this.recordingFormatSelect ? this.recordingFormatSelect.value : 'wav';
                
                // Initialize if we have access to MediaRecorder
                if (typeof MediaRecorder !== 'undefined') {
                    this.initializeRecorder();
                } else {
                    showMessage('MediaRecorder is not supported in this browser. Recording feature unavailable.', 5000);
                    console.warn('MediaRecorder is not supported.');
                }

                if (this.recordingFormatSelect) {
                    this.recordingFormatSelect.addEventListener('change', (e) => {
                        this.selectedFormat = e.target.value;
                        if (this.selectedFormat === 'mp3') {
                            showMessage('MP3 recording is not natively supported by browsers. Recording will be saved as WebM.', 5000);
                        }
                    });
                }
            }
            
            async initializeRecorder() {
                // Check if analyserNode exists before connecting
                if (!analyserNode) {
                    console.error("AnalyserNode not available for recording initialization.");
                    showMessage("Audio system not ready for recording. Please start music first.", 3000);
                    return;
                }

                const dest = this.audioContext.createMediaStreamDestination();
                // Connect the analyserNode to the recording destination
                // Important: Ensure analyserNode is connected to the audio graph before this,
                // and that its output is also going to the main audio destination.
                analyserNode.connect(dest);
                
                try {
                    this.mediaRecorder = new MediaRecorder(dest.stream);
                    this.mediaRecorder.ondataavailable = e => this.chunks.push(e.data);
                    this.mediaRecorder.onstop = () => this.processRecording();
                } catch (err) {
                    console.error('Failed to initialize MediaRecorder:', err);
                    showMessage('Recording initialization failed. Please try a different browser or check permissions.');
                }
            }
            
            startRecording() {
                if (!this.mediaRecorder) {
                    showMessage("Recording system not ready. Please try again.", 3000);
                    return;
                }
                if (this.isRecording) {
                    showMessage("Already recording!", 2000);
                    return;
                }
                if (this.selectedFormat === 'mp3') {
                    showMessage('MP3 recording is not natively supported. Recording in WAV format.', 4000);
                    // Fallback to WAV if MP3 is selected
                    this.selectedFormat = 'wav'; 
                }

                this.chunks = [];
                this.recordingStartTime = Date.now();
                this.isRecording = true;
                
                if (this.recordingMeter) {
                    this.recordingMeter.classList.add('active');
                }

                let countdown = 3;
                const countdownInterval = setInterval(() => {
                    if (this.recordingMeter) {
                        this.recordingMeter.textContent = `Recording starts in: ${countdown}s`;
                    }
                    countdown--;
                    if (countdown < 0) {
                        clearInterval(countdownInterval);
                        this.mediaRecorder.start();
                        this.updateRecordingTime();
                        showMessage('Recording started!');
                        console.log("Recording started.");
                    }
                }, 1000);
            }
            
            stopRecording() {
                if (!this.isRecording) {
                    showMessage("Not currently recording.", 2000);
                    return;
                }
                
                this.mediaRecorder.stop();
                this.isRecording = false;
                if (this.recordingMeter) {
                    this.recordingMeter.classList.remove('active');
                    this.recordingMeter.textContent = ''; // Clear text
                }
                
                showMessage('Recording stopped. Preparing download...');
                console.log("Recording stopped.");
            }
            
            updateRecordingTime() {
                if (!this.isRecording || !this.recordingMeter) return;
                
                const duration = (Date.now() - this.recordingStartTime) / 1000;
                this.recordingMeter.textContent = `Recording: ${duration.toFixed(1)}s`;
                requestAnimationFrame(() => this.updateRecordingTime());
            }
            
            async processRecording() {
                const mimeType = this.selectedFormat === 'wav' ? 'audio/wav' : 'audio/webm'; // Default to webm if not wav, though we only support wav for now
                const blob = new Blob(this.chunks, { type: mimeType }); 
                const url = URL.createObjectURL(blob);
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `simple_relax_loop_${new Date().toISOString().replace(/:/g, '-')}.${this.selectedFormat === 'wav' ? 'wav' : 'webm'}`; // Use webm for mp3 attempts
                document.body.appendChild(a); // Append to body to make it clickable
                a.click();
                document.body.removeChild(a); // Clean up
                
                URL.revokeObjectURL(url); // Release object URL
                showMessage("Recording downloaded!", 3000);
                console.log("Recording download initiated.");
            }
        }

        // Add Recording Controls to UI
        function addRecordingControls() {
            const recordButton = document.getElementById('recordButton');
            const stopButton = document.getElementById('stopButton'); // Get stop button reference
            const startButton = document.getElementById('startButton'); // Get start button reference

            if (recordButton) {
                recordButton.addEventListener('click', () => {
                    // Ensure audioContext is initialized before interacting with recorder
                    if (!audioContext) {
                        showMessage("Please start the music loop first to initialize audio.", 3000);
                        return;
                    }
                    
                    // The looperRecorder is initialized in initAudio, so it should exist here.
                    // If it somehow doesn't, initialize it now.
                    if (!looperRecorder) {
                        looperRecorder = new EnhancedLooperRecorder(audioContext);
                    }

                    if (looperRecorder.isRecording) {
                        looperRecorder.stopRecording();
                        recordButton.textContent = 'Start Recording';
                        // Re-enable start/stop if needed, or handle based on main loop state
                        if (!isPlaying) {
                            startButton.disabled = false;
                            stopButton.disabled = true;
                        }
                    } else {
                        looperRecorder.startRecording();
                        recordButton.textContent = 'Stop Recording';
                    }
                });
            }
        }

        // Keyboard Controls Initialization
        function initializeKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                // Only handle shortcuts if not typing in an input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                
                const startButton = document.getElementById('startButton');
                const stopButton = document.getElementById('stopButton');
                const recordButton = document.getElementById('recordButton'); // Get record button
                const chorusBypassCheckbox = document.getElementById('chorusBypass');
                const reverbBypassCheckbox = document.getElementById('reverbBypass');
                const distortionBypassCheckbox = document.getElementById('distortionBypass'); // New
                const phaserBypassCheckbox = document.getElementById('phaserBypass'); // New
                const synthArpeggiatorCheckbox = document.getElementById('synthArpeggiator'); // New


                switch(e.code) {
                    case 'Space':
                    case 'Enter': // Add Enter as transport control
                        e.preventDefault(); // Prevent default spacebar/enter action (e.g., scrolling, submitting forms)
                        if (isPlaying) {
                            stopButton.click();
                        } else {
                            startButton.click();
                        }
                        break;
                    case 'KeyR':
                        if (e.ctrlKey) { // Ctrl+R for recording
                            e.preventDefault();
                            recordButton.click();
                        } else { // R key alone for Reverb bypass
                             e.preventDefault();
                             reverbBypassCheckbox.checked = !reverbBypassCheckbox.checked;
                             reverbBypassCheckbox.dispatchEvent(new Event('change'));
                        }
                        break;
                    case 'KeyC': // C key for Chorus bypass
                        e.preventDefault();
                        chorusBypassCheckbox.checked = !chorusBypassCheckbox.checked;
                        chorusBypassCheckbox.dispatchEvent(new Event('change'));
                        break;
                    case 'KeyD': // D key for Distortion bypass (New)
                        e.preventDefault();
                        distortionBypassCheckbox.checked = !distortionBypassCheckbox.checked;
                        distortionBypassCheckbox.dispatchEvent(new Event('change'));
                        break;
                    case 'KeyP': // P key for Phaser bypass (New)
                        e.preventDefault();
                        phaserBypassCheckbox.checked = !phaserBypassCheckbox.checked;
                        phaserBypassCheckbox.dispatchEvent(new Event('change'));
                        break;
                    case 'KeyA': // A key for Synth Arpeggiator (New)
                        e.preventDefault();
                        synthArpeggiatorCheckbox.checked = !synthArpeggiatorCheckbox.checked;
                        synthArpeggiatorCheckbox.dispatchEvent(new Event('change'));
                        break;
                    case 'KeyM':
                        // Master volume mute/unmute
                        const volKnob = document.getElementById('masterVolume');
                        if (volKnob) {
                            if (parseFloat(volKnob.value) > 0) {
                                volKnob.dataset.lastValue = volKnob.value; // Store current value
                                volKnob.value = 0;
                            } else {
                                volKnob.value = volKnob.dataset.lastValue || 0.55; // Restore or default
                            }
                            volKnob.dispatchEvent(new Event('input')); // Trigger input event to update UI and audio
                            showMessage(`Master Volume: ${parseFloat(volKnob.value) === 0 ? 'Muted' : 'Unmuted'}`, 1500);
                        }
                        break;
                    case 'ArrowUp':
                    case 'ArrowDown':
                        // Parameter fine-tuning for all range inputs
                        if (e.target.tagName === 'INPUT' && e.target.type === 'range') {
                            e.preventDefault(); // Prevent default scrolling
                            const knob = e.target;
                            const step = e.shiftKey ? parseFloat(knob.step) : (knob.id === 'tempo' ? 10 : 0.01); // Smaller step for fine-tuning
                            const direction = e.code === 'ArrowUp' ? 1 : -1;
                            let newValue = parseFloat(knob.value) + (direction * step);

                            // Clamp value to min/max
                            newValue = Math.min(parseFloat(knob.max), Math.max(parseFloat(knob.min), newValue));
                            knob.value = newValue;
                            knob.dispatchEvent(new Event('input')); // Trigger input event to update UI and audio
                            showMessage(`${knob.labels[0].textContent}: ${knob.nextElementSibling.textContent}`, 1000);
                        } else {
                            // Default behavior for tempo if no specific knob is focused
                            const tempoKnob = document.getElementById('tempo');
                            if (tempoKnob) {
                                e.preventDefault(); // Prevent default scrolling
                                const step = e.shiftKey ? 1 : 10;
                                const direction = e.code === 'ArrowUp' ? 1 : -1;
                                tempoKnob.value = Math.min(parseFloat(tempoKnob.max), Math.max(parseFloat(tempoKnob.min), parseInt(tempoKnob.value) + (direction * step)));
                                tempoKnob.dispatchEvent(new Event('input')); // Trigger input event to update UI and audio
                                showMessage(`Tempo: ${tempoKnob.value} ms`, 1000);
                            }
                        }
                        break;
                    // Quick preset loading (1-9)
                    case 'Digit1':
                    case 'Digit2':
                    case 'Digit3':
                    case 'Digit4':
                    case 'Digit5':
                    case 'Digit6':
                    case 'Digit7':
                    case 'Digit8':
                    case 'Digit9':
                        e.preventDefault();
                        const presetNumber = parseInt(e.key);
                        const presetName = `Preset ${presetNumber}`;
                        document.getElementById('presetNameInput').value = presetName;
                        loadPreset(); // Call the existing loadPreset function
                        break;
                }
            });
        }

        // Add event listeners once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Attaching event listeners.");
            document.getElementById('startButton').addEventListener('click', startLoop);
            document.getElementById('stopButton').addEventListener('click', stopLoop);
            document.getElementById('savePresetButton').addEventListener('click', savePreset);
            document.getElementById('loadPresetButton').addEventListener('click', loadPreset);
            document.getElementById('exportPresetsButton').addEventListener('click', () => presetManager.exportAllPresets());
            document.getElementById('importPresetsInput').addEventListener('change', (event) => {
                if (event.target.files.length > 0) {
                    presetManager.importPresets(event.target.files[0]);
                }
            });
            
            // Add event listeners for all range input knobs
            document.querySelectorAll('input[type="range"]').forEach(knob => {
                knob.addEventListener('input', (e) => {
                    updateAudioParameter(e.target.id, parseFloat(e.target.value));
                });
            });

            // Add select box event listeners for oscillator types
            document.getElementById('bassOscillatorType').addEventListener('change', (e) => {
                updateAudioParameter(e.target.id, e.target.value);
                showMessage(`Bass Wave: ${e.target.value}`);
            });
            document.getElementById('synthOscillatorType').addEventListener('change', (e) => {
                updateAudioParameter(e.target.id, e.target.value);
                showMessage(`Synth Wave: ${e.target.value}`);
            });

            // Add checkbox event listeners
            document.getElementById('chorusBypass').addEventListener('change', (event) => {
                isChorusBypassed = event.target.checked;
                updateChorusBypassConnection();
                showMessage(`Chorus is now ${isChorusBypassed ? 'bypassed' : 'active'}.`);
            });

            document.getElementById('reverbBypass').addEventListener('change', (event) => {
                isReverbBypassed = event.target.checked;
                updateReverbBypassConnection();
                showMessage(`Reverb is now ${isReverbBypassed ? 'bypassed' : 'active'}.`);
            });

            // New: Distortion bypass checkbox
            document.getElementById('distortionBypass').addEventListener('change', (event) => {
                isDistortionBypassed = event.target.checked;
                updateDistortionBypassConnection();
                showMessage(`Distortion is now ${isDistortionBypassed ? 'bypassed' : 'active'}.`);
            });

            // New: Phaser bypass checkbox
            document.getElementById('phaserBypass').addEventListener('change', (event) => {
                isPhaserBypassed = event.target.checked;
                updatePhaserBypassConnection();
                showMessage(`Phaser is now ${isPhaserBypassed ? 'bypassed' : 'active'}.`);
            });

            // New: Synth Arpeggiator checkbox
            document.getElementById('synthArpeggiator').addEventListener('change', (event) => {
                isSynthArpeggiatorActive = event.target.checked;
                showMessage(`Synth Arpeggiator is now ${isSynthArpeggiatorActive ? 'active' : 'inactive'}.`);
            });

            // Visualization mode buttons
            document.getElementById('visModeSpectrum').addEventListener('click', () => {
                visualizationMode = 'spectrum';
                document.querySelectorAll('.visualization-controls button').forEach(btn => btn.classList.remove('active'));
                document.getElementById('visModeSpectrum').classList.add('active');
                showMessage('Visualization: Spectrum');
            });
            document.getElementById('visModeWaveform').addEventListener('click', () => {
                visualizationMode = 'waveform';
                document.querySelectorAll('.visualization-controls button').forEach(btn => btn.classList.remove('active'));
                document.getElementById('visModeWaveform').classList.add('active');
                showMessage('Visualization: Waveform');
            });
            document.getElementById('visModeBoth').addEventListener('click', () => {
                visualizationMode = 'both';
                document.querySelectorAll('.visualization-controls button').forEach(btn => btn.classList.remove('active'));
                document.getElementById('visModeBoth').classList.add('active');
                showMessage('Visualization: Both');
            });
            document.getElementById('visModeBands').addEventListener('click', () => {
                visualizationMode = 'bands';
                document.querySelectorAll('.visualization-controls button').forEach(btn => btn.classList.remove('active'));
                document.getElementById('visModeBands').classList.add('active');
                showMessage('Visualization: Frequency Bands');
            });


            // Initial display update for all knobs and selects
            document.querySelectorAll('input[type="range"]').forEach(knob => {
                updateAudioParameter(knob.id, parseFloat(knob.value));
            });
            document.querySelectorAll('select').forEach(select => {
                updateAudioParameter(select.id, select.value);
            });
            // Trigger initial bypass connections to set up the graph correctly
            updateDistortionBypassConnection();
            updatePhaserBypassConnection();
            updateChorusBypassConnection();
            updateReverbBypassConnection();


            updateSectionDisplay();
            updateSongIterationDisplay(); // Initialize iteration display

            // Initialize keyboard controls
            initializeKeyboardControls();
            
            // Add recording controls (looperRecorder is initialized in initAudio)
            addRecordingControls();

            // Auto-load settings on page load
            const autoSavedSettings = presetManager.loadAutoSavedSettings();
            if (autoSavedSettings) {
                applySettings(autoSavedSettings);
                showMessage("Auto-saved settings loaded.", 2000);
            }

            // Auto-save settings before page unload
            window.addEventListener('beforeunload', () => {
                presetManager.autoSaveSettings();
            });
        });
    </script>
</body>
</html>
