<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Relax Looper</title> <!-- Renamed Title -->
    <style>
        /* Apply Inter font and basic styling to the body */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter as per instructions */
            display: flex;
            justify-content: center; /* Center content horizontally */
            align-items: flex-start; /* Align items to the top */
            min-height: 100vh; /* Ensure it takes full viewport height */
            background-color: #1a1a1a; /* Dark background for ambient feel */
            color: #e0e0e0; /* Light text color */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px; /* Space between the left panel and main content */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Main layout container for left panel and central content */
        .main-layout-container {
            display: flex;
            flex-direction: row; /* Controls on left, main content on right */
            gap: 20px;
            width: 100%;
            max-width: 1200px; /* Max width for the entire layout */
            justify-content: center; /* Center the layout within the body */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Left panel for knobs */
        .left-panel {
            flex: 0 0 250px; /* Fixed width for the left panel, no shrinking */
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Central content container (formerly 'container') */
        .central-content {
            flex: 1; /* Take remaining space */
            min-width: 300px; /* Minimum width for central content */
            background-color: #2a2a2a;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Styling for the main heading */
        h1 {
            color: #90ee90; /* Light green for "Weed" theme */
            margin-bottom: 10px; /* Reduced margin */
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(144, 238, 144, 0.6); /* Glow effect */
        }
        /* Styling for buttons */
        button {
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px; /* Rounded corners for buttons */
            cursor: pointer;
            font-size: 1.2em;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; /* Smooth transitions */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Button shadow */
            outline: none; /* Remove outline on focus */
        }
        /* Hover effects for buttons */
        button:hover {
            background-color: #45a049;
            transform: translateY(-2px); /* Slight lift effect */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        /* Active (click) effects for buttons */
        button:active {
            background-color: #3e8e41;
            transform: translateY(0); /* Return to original position */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        /* Styling for disabled buttons */
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        /* Styling for the custom message box */
        .message-box {
            background-color: #3a3a3a;
            color: #fff;
            padding: 15px;
            border-radius: 8px; /* Rounded corners */
            margin-top: 20px;
            font-size: 0.9em;
            display: none; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.3s ease; /* Fade in/out effect */
        }
        /* Class to show the message box */
        .message-box.show {
            display: block;
            opacity: 1;
        }
        /* Styling for paragraph text */
        p {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        /* Styling for current section display */
        #currentSectionDisplay {
            margin-top: 10px;
            font-size: 1.3em;
            color: #a0ffa0;
            font-weight: bold;
            transition: color 0.3s ease; /* Smooth color transition for highlight */
        }
        /* Highlight for current section */
        #currentSectionDisplay.highlight {
            color: #ffcc00; /* Yellowish highlight */
            text-shadow: 0 0 8px rgba(255, 204, 0, 0.6); /* Subtle glow */
        }
        /* Flex container for control buttons */
        .controls {
            display: flex;
            gap: 15px; /* Space between buttons */
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Styling for knob sections */
        .knob-section {
            background-color: #3a3a3a;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Responsive grid for knobs */
            gap: 15px;
        }
        .knob-section h3 {
            color: #90ee90;
            margin-top: 0;
            margin-bottom: 10px;
            grid-column: 1 / -1; /* Span across all columns */
        }
        .knob-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .knob-group label {
            font-size: 0.9em;
            color: #ccc;
        }
        .knob-group input[type="range"] {
            width: 100px; /* Fixed width for sliders */
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #555;
            outline: none;
            border-radius: 5px;
            transition: background 0.2s;
        }
        .knob-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #90ee90;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(144, 238, 144, 0.5);
        }
        .knob-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #90ee90;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(144, 238, 144, 0.5);
        }
        .knob-value {
            font-size: 0.8em;
            color: #a0ffa0;
        }

        /* Audio Visualizer */
        #audioVisualizer {
            background-color: #000;
            border: 1px solid #4CAF50;
            border-radius: 8px;
            margin-top: 20px;
            width: 100%; /* Make it responsive */
            max-width: 400px; /* Max width for desktop */
            height: 100px; /* Fixed height */
        }

        /* Volume Meter */
        .volume-meter-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            gap: 10px;
        }
        .volume-meter-label {
            font-size: 0.9em;
            color: #ccc;
        }
        #volumeMeter {
            width: 150px;
            height: 15px;
            background-color: #555;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #4CAF50;
        }
        #volumeMeterFill {
            height: 100%;
            width: 0%; /* Starts empty */
            background-color: #90ee90;
            transition: width 0.05s ease-out; /* Smooth transition for volume changes */
        }

        /* Preset controls */
        .preset-controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        .preset-controls input[type="text"] {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            width: 80%;
            max-width: 200px;
        }
        .preset-controls button {
            padding: 10px 20px;
            font-size: 1em;
            width: 100%;
            max-width: 200px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-layout-container {
                flex-direction: column; /* Stack panels vertically on small screens */
                align-items: center;
            }
            .left-panel, .central-content {
                width: 95%; /* Make panels take more width */
                flex: none; /* Remove flex grow/shrink */
            }
            #audioVisualizer {
                width: 95%; /* Make visualizer wider on small screens */
            }
        }
    </style>
</head>
<body>
    <div class="main-layout-container">
        <div class="left-panel">
            <div class="knob-section">
                <h3>Master Controls</h3>
                <div class="knob-group">
                    <label for="masterVolume">Master Volume</label>
                    <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.55">
                    <span class="knob-value" id="masterVolumeValue">0.55</span>
                </div>
                <div class="knob-group">
                    <label for="tempo">Tempo (ms)</label>
                    <input type="range" id="tempo" min="300" max="900" step="10" value="420">
                    <span class="knob-value" id="tempoValue">420</span>
                </div>
            </div>

            <div class="knob-section">
                <h3>Instrument Gains</h3>
                <div class="knob-group">
                    <label for="bassVolume">Bass Volume</label>
                    <input type="range" id="bassVolume" min="0" max="0.5" step="0.01" value="0.13">
                    <span class="knob-value" id="bassVolumeValue">0.13</span>
                </div>
                <div class="knob-group">
                    <label for="synthVolume">Synth Volume</label>
                    <input type="range" id="synthVolume" min="0" max="0.5" step="0.01" value="0.08"> <!-- Changed default to 0.08 -->
                    <span class="knob-value" id="synthVolumeValue">0.08</span>
                </div>
                <div class="knob-group">
                    <label for="kickVolume">Kick Volume</label>
                    <input type="range" id="kickVolume" min="0" max="1" step="0.01" value="0.89">
                    <span class="knob-value" id="kickVolumeValue">0.89</span>
                </div>
                <div class="knob-group">
                    <label for="snareVolume">Snare Volume</label>
                    <input type="range" id="snareVolume" min="0" max="0.3" step="0.01" value="0.21">
                    <span class="knob-value" id="snareVolumeValue">0.21</span>
                </div>
                <div class="knob-group">
                    <label for="hihatVolume">Hi-Hat Volume</label>
                    <input type="range" id="hihatVolume" min="0" max="0.3" step="0.01" value="0.21">
                    <span class="knob-value" id="hihatVolumeValue">0.21</span>
                </div>
            </div>

            <div class="knob-section">
                <h3>Effects</h3>
                <div class="knob-group">
                    <label for="delayTime">Delay Time (s)</label>
                    <input type="range" id="delayTime" min="0.01" max="2.0" step="0.01" value="0.3">
                    <span class="knob-value" id="delayTimeValue">0.30</span>
                </div>
                <div class="knob-group">
                    <label for="delayFeedback">Delay Feedback</label>
                    <input type="range" id="delayFeedback" min="0" max="0.95" step="0.01" value="0.4">
                    <span class="knob-value" id="delayFeedbackValue">0.40</span>
                </div>
                <div class="knob-group">
                    <label for="delaySendLevel">Delay Send</label>
                    <input type="range" id="delaySendLevel" min="0" max="1.0" step="0.01" value="0.5">
                    <span class="knob-value" id="delaySendLevelValue">0.50</span>
                </div>
            </div>
        </div>

        <div class="central-content">
            <h1>Simple Relax Looper</h1> <!-- Renamed Heading -->
            <p>Experience a subtly evolving ambient track designed for relaxation.</p>
            <div class="controls">
                <button id="startButton">Start Looping</button>
                <button id="stopButton" disabled>Stop Looping</button>
            </div>
            <div id="currentSectionDisplay">Current Section: --</div>
            <div id="messageBox" class="message-box"></div>

            <!-- Audio Visualization Canvas -->
            <canvas id="audioVisualizer" width="400" height="100"></canvas>

            <!-- Master Volume Meter -->
            <div class="volume-meter-container">
                <span class="volume-meter-label">Master Volume:</span>
                <div id="volumeMeter">
                    <div id="volumeMeterFill"></div>
                </div>
            </div>

            <!-- Preset Controls -->
            <div class="preset-controls knob-section">
                <h3>Presets</h3>
                <input type="text" id="presetNameInput" placeholder="Enter preset name">
                <button id="savePresetButton">Save Preset</button>
                <button id="loadPresetButton">Load Preset</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables for the Web Audio API context and nodes
        let audioContext;
        let masterGainNode;
        let isPlaying = false; // Flag to track if audio is currently playing
        let nextNoteTime = 0; // The time when the next note should be scheduled
        let loopTimeoutId; // ID for the setTimeout that schedules the next audio event

        // Musical parameters controlled by knobs - initialized to default values
        let masterVolume = 0.55;
        let bassVolume = 0.13; // Updated
        let synthVolume = 0.08; // Changed default to 0.08
        let kickVolume = 0.89; // Updated
        let snareVolume = 0.21; // Updated
        let hihatVolume = 0.21; // Updated

        let currentTempo = 420; // This will now remain fixed at the knob value
        let currentDetune = 0; // Current detune value for oscillators in cents
        let currentFilterFrequency = 1000; // Current low-pass filter cutoff frequency in Hz
        let currentFilterQ = 1; // Current low-pass filter Q value
        let baseNoteDuration = 0.5; // Base duration of each individual note in seconds

        // Global variables for filter and detune drift (still apply subtle background changes)
        let filterDriftDirection = 1; // 1 for increasing, -1 for decreasing
        let detuneDriftDirection = 1;
        let delayTimeDriftDirection = 1; // For delay time variation
        let delayFeedbackDriftDirection = 1; // For delay feedback variation

        // Fibonacci-influenced drift scale factors for dynamic parameters
        // These values will influence the *magnitude* of the random drift
        const fibonacciDriftScales = [0.1, 0.2, 0.3, 0.5, 0.8, 1.3, 2.1]; // Scaled Fibonacci sequence (extended)
        let currentFibonacciDriftScaleIndex = 0;

        // Humanization intensity factor, also influenced by Fibonacci drift
        let humanizationFactor = 0.5; // Initial humanization intensity

        // Delay effect nodes and parameters
        let delayNode;
        let delayFeedbackGain;
        let delaySendGain;
        let delayTimeValue = 0.3;
        let delayFeedbackValue = 0.4;
        let delaySendLevel = 0.5;

        // Visualizer and Volume Meter elements
        let analyserNode;
        let audioVisualizerCanvas;
        let audioVisualizerCtx;
        let volumeMeterElement;
        let volumeMeterFillElement;
        let dataArray; // For analyser data

        // For cycling through verse patterns (normal and Raga)
        const normalVerseOptions = {
            verse1: ['verse1_A', 'verse1_B', 'verse1_C', 'verse1_D'], // Added D for odd time signature feel
            verse2: ['verse2_A', 'verse2_B', 'verse2_C', 'verse2_D'], // Added D for odd time signature feel
            verse3: ['verse3_A', 'verse3_B', 'verse3_C']
        };
        const ragaVerseOptions = ['ragaYamanPhrase', 'ragaBhairaviPhrase']; // All available Raga phrases
        let availableRagas = [...ragaVerseOptions]; // Copy of original raga list for cycling
        let normalVerseIndex = 0;
        let verseIterationCount = 0; // To track every 2 verses for Raga

        // Predefined frequencies for a simple musical scale
        const notes = {
            'A1': 55.00, 'A#1': 58.27, 'B1': 61.74,
            'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 97.99, 'G#2': 103.83,
            'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65,
            'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30,
            'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25
        };

        // New Raga scale definitions (using C as tonic for simplicity)
        const ragaScales = {
            yaman: ['C4', 'D4', 'E4', 'F#4', 'G4', 'A4', 'B4', 'C5'], // Including octave for range
            bhairavi: ['C4', 'C#4', 'D#4', 'F4', 'G4', 'G#4', 'A#4', 'C5'] // C#, D#, G#, A# for Db, Eb, Ab, Bb
        };

        /**
         * Generates a melodic phrase within a given Raga scale, with expressive variations.
         * @param {Array<string>} scale - Array of note names in the Raga scale (e.g., ['C4', 'D4', 'E4']).
         * @param {number} phraseLength - Number of steps in the phrase (e.g., 8).
         * @param {number} humanizationFactor - A factor influencing how "busy" or sparse the melody is (0-1).
         * @returns {Array<Object>} An array of phrase steps.
         */
        function generateRagaMelody(scale, phraseLength, humanizationFactor) {
            const generatedPhrase = [];
            let currentNoteIndex = Math.floor(Math.random() * scale.length); // Start at a random note in the scale
            let lastDirection = Math.random() < 0.5 ? 1 : -1; // Initial melodic direction

            // Identify Vadi (tonic) and Samvadi (dominant/consonant) notes for Raga gravity
            const vadiNote = scale[0]; // Tonic
            const samvadiNote = scale[4]; // Fifth (G for C-based scales)

            for (let i = 0; i < phraseLength; i++) {
                const step = {
                    bass: [],
                    synth: [],
                    percussion: {},
                    delaySend: 0.3 + (Math.random() * 0.3) // Vary delay send slightly
                };

                // --- Bass Line Generation (Complementary Harmony) ---
                // Bass provides a stable, evolving harmonic foundation.
                // It will primarily play the root, but occasionally the fifth or a note from the Raga.
                if (i % 4 === 0) { // On beat 1 of every measure (assuming 4 beats per measure)
                    step.bass.push(scale[0].replace('4', '2')); // Root of the Raga in a lower octave
                } else if (i % 2 === 0 && Math.random() < 0.6) { // On other strong beats, sometimes play fifth or other scale note
                    const bassOptions = [scale[0].replace('4', '2'), scale[4].replace('4', '2')]; // Root and fifth
                    if (scale.length > 5 && Math.random() < 0.3) { // Occasionally add a third or other scale degree
                        bassOptions.push(scale[2].replace('4', '2'));
                    }
                    step.bass.push(bassOptions[Math.floor(Math.random() * bassOptions.length)]);
                }
                // Ensure bass is always present, even if just a drone
                if (step.bass.length === 0) {
                    step.bass.push(scale[0].replace('4', '2')); // Default to tonic if no bass note
                }


                // --- Synth Melody Generation (Expressive and Varied) ---
                // Complexity influences how many notes are played and how big the melodic jumps are.
                const numSynthNotes = 1 + Math.floor(Math.random() * (humanizationFactor * 2)); // 1 to 3 notes based on humanization
                
                for (let j = 0; j < numSynthNotes; j++) {
                    let nextNoteIndex = currentNoteIndex;

                    // Tendency to change direction based on humanization/randomness
                    if (Math.random() < 0.3 + (humanizationFactor * 0.2)) { // Higher humanization = more directional changes
                        lastDirection *= -1; // Flip direction
                    }

                    // Melodic movement: biased towards steps, then skips, then leaps
                    const moveType = Math.random();
                    let moveAmount = 0;

                    if (moveType < 0.7) { // 70% chance for stepwise motion (major/minor 2nd)
                        moveAmount = 1;
                    } else if (moveType < 0.9) { // 20% chance for skips (3rd, 4th)
                        moveAmount = Math.random() < 0.5 ? 2 : 3;
                    } else { // 10% chance for leaps (5th+)
                        moveAmount = Math.random() < 0.5 ? 4 : 5;
                    }

                    nextNoteIndex = (currentNoteIndex + lastDirection * moveAmount + scale.length * 2) % scale.length;
                    
                    // Raga "Gravity": pull towards Vadi/Samvadi
                    // If current note is far from Vadi/Samvadi, increase chance to move towards them
                    const currentNoteFreq = notes[scale[currentNoteIndex]];
                    const vadiFreq = notes[vadiNote];
                    const samvadiFreq = notes[samvadiNote];

                    if (Math.abs(currentNoteFreq - vadiFreq) > 50 && Math.random() < 0.4) { // If far from Vadi
                        lastDirection = (currentNoteFreq < vadiFreq) ? 1 : -1;
                        nextNoteIndex = scale.indexOf(vadiNote); // Force move to vadi
                    } else if (Math.abs(currentNoteFreq - samvadiFreq) > 50 && Math.random() < 0.2) { // If far from Samvadi
                        lastDirection = (currentNoteFreq < samvadiFreq) ? 1 : -1;
                        nextNoteIndex = scale.indexOf(samvadiNote); // Force move to samvadi
                    }

                    currentNoteIndex = nextNoteIndex; // Update current note index

                    // Add octave variation for synth
                    let synthNote = scale[currentNoteIndex];
                    const currentOctave = parseInt(synthNote.slice(-1));
                    if (Math.random() < 0.3 * humanizationFactor) { // Chance to shift octave based on humanization
                        if (Math.random() < 0.5 && currentOctave < 5) { // Shift up if not already highest octave
                            synthNote = synthNote.slice(0, -1) + (currentOctave + 1);
                        } else if (currentOctave > 3) { // Shift down if not already lowest octave
                            synthNote = synthNote.slice(0, -1) + (currentOctave - 1);
                        }
                    }
                    step.synth.push(synthNote);
                }
                // Ensure synth is always present, even if just a sustained note
                if (step.synth.length === 0) {
                    step.synth.push(scale[currentNoteIndex]); // Default to current melodic note if no synth note
                }


                // --- Percussion: Keep it simple for Raga sections, maybe just hi-hats ---
                if (i % 2 === 0) { // On every other beat
                    step.percussion.hihat = 'closed';
                }
                if (i === 0 || i === 4) { // Kick on 1 and 5
                    step.percussion.kick = true;
                }
                if (i === 2 || i === 6) { // Snare on 3 and 7
                    step.percussion.snare = true;
                }

                generatedPhrase.push(step);
            }
            return generatedPhrase;
        }


        // Define musical phrases for each section of the song
        // Each object represents a "beat" or "step" and can contain notes, drums, and snares.
        // Chords (notes array) are limited to 3 notes.
        const musicalPhrases = {
            intro: [
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.8 }, // Very sparse start, high delay
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.7 },
                { bass: ['E2'], synth: ['E4'], percussion: {}, delaySend: 0.6 },
                { bass: ['E2'], synth: ['E4'], percussion: {}, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4'], percussion: {}, delaySend: 0.4 },
                { bass: ['C3'], synth: ['C4'], percussion: {}, delaySend: 0.3 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.2 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.1 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: {}, delaySend: 0.0 }, // Bass enters, delay fades
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: {}, delaySend: 0.0 },
                { bass: ['E2'], synth: ['E4', 'G4'], percussion: {}, delaySend: 0.0 },
                { bass: ['E2'], synth: ['E4', 'G4'], percussion: {}, delaySend: 0.0 },
                { bass: ['C3'], synth: ['C4', 'E4'], percussion: {}, delaySend: 0.0 },
                { bass: ['C3'], synth: ['C4', 'E4'], percussion: {}, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: {}, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: {}, delaySend: 0.0 }
            ],
            // Verse 1 variations: C - G - Am - F progression (I-V-vi-IV in C Major)
            verse1_A: [
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.2 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: 'closed' }, delaySend: 0.0 }
            ],
            verse1_B: [
                { bass: ['C2'], synth: ['E4', 'G4', 'C5'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.2 }, // Different voicing
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['B3', 'D4', 'G4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4', 'E4', 'A4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3', 'C4', 'F4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['C4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }
            ],
            verse1_C: [
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.2 }, // Fewer notes, more sparse
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.2 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.2 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.2 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: 'closed' }, delaySend: 0.0 }
            ],
            verse1_D: [ // 7 steps, C-G-Am-F feel, simulating 7/4 or 7/8
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.2 }, // Beat 1
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }, // Beat 2
                { bass: ['G2'], synth: ['B3', 'D4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.2 }, // Beat 3
                { bass: ['G2'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }, // Beat 4
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.2 }, // Beat 5
                { bass: ['A2'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }, // Beat 6
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.2 } // Beat 7, ends phrase
            ],
            // Verse 2 variations: F - C - G - Am progression (IV-I-V-vi in C Major)
            verse2_A: [
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }
            ],
            verse2_B: [
                { bass: ['F2'], synth: ['C4', 'F4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['G3', 'C4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['D4', 'G4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['E4', 'A4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }
            ],
            verse2_C: [
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.3 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }
            ],
            verse2_D: [ // 7 steps, F-C-G-Am feel, simulating 7/4 or 7/8
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.0 }, // Beat 1
                { bass: ['F2'], synth: ['C4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }, // Beat 2
                { bass: ['C2'], synth: ['E4', 'G4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 }, // Beat 3
                { bass: ['C2'], synth: ['G4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }, // Beat 4
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.3 }, // Beat 5
                { bass: ['G2'], synth: ['D4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }, // Beat 6
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 } // Beat 7, ends phrase
            ],
            // Verse 3 variations: G - Am - F - C progression (V-vi-IV-I in C Major)
            verse3_A: [
                { bass: ['G2'], synth: ['G3', 'B3', 'D4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.4 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['A3', 'C4', 'E4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3', 'C4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.4 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4', 'G4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }
            ],
            verse3_B: [
                { bass: ['G2'], synth: ['D4', 'G4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.4 },
                { bass: ['G2'], synth: ['B3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['E4', 'A4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['A2'], synth: ['C4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['C4', 'F4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.4 },
                { bass: ['F2'], synth: ['A3'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['G4', 'C5'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }
            ],
            verse3_C: [
                { bass: ['G2'], synth: ['G3', 'D4'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.4 },
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'C4'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'G4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['G2'], synth: ['G3', 'B3'], percussion: { kick: true, hihat: 'closed' }, delaySend: 0.4 },
                { bass: ['A2'], synth: ['A3', 'C4'], percussion: { hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['F2'], synth: ['F3', 'A3'], percussion: { snare: true, hihat: 'closed' }, delaySend: 0.0 },
                { bass: ['C2'], synth: ['C4', 'E4'], percussion: { hihat: 'closed' }, delaySend: 0.0 }
            ],
            // Raga Yaman Phrase and Bhairavi Phrase will be dynamically generated.
            // These entries are just placeholders for length if needed, but not used directly for content.
            ragaYamanPhrase: new Array(8).fill({}), // Placeholder for length
            ragaBhairaviPhrase: new Array(8).fill({}), // Placeholder for length
            
            chorus: [
                // Consistent delay for a full sound
                { bass: ['A2'], synth: ['A4', 'C5', 'E4'], percussion: { kick: true, hihat: 'open' }, delaySend: 0.6 },
                { bass: ['A2'], synth: ['C5'], percussion: { hihat: 'closed' }, delaySend: 0.6 },
                { bass: ['G2'], synth: ['G4', 'B4', 'D4'], percussion: { kick: true, snare: true, hihat: 'open' }, delaySend: 0.6 },
                { bass: ['G2'], synth: ['B4'], percussion: { hihat: 'closed' }, delaySend: 0.6 },
                { bass: ['C3'], synth: ['C4', 'E4', 'G4'], percussion: { kick: true, hihat: 'open' }, delaySend: 0.6 },
                { bass: ['C3'], synth: ['E4'], percussion: { hihat: 'closed' }, delaySend: 0.6 },
                { bass: ['F2'], synth: ['F4', 'A4', 'C5'], percussion: { kick: true, snare: true, hihat: 'open' }, delaySend: 0.6 },
                { bass: ['F2'], synth: ['A4'], percussion: { hihat: 'closed' }, delaySend: 0.6 }
            ],
            bridge: [
                // More atmospheric, less percussive, with moderate delay
                { bass: ['D2'], synth: ['D4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 },
                { bass: ['E2'], synth: ['E4', 'G4', 'B4'], percussion: {}, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3', 'D4', 'G4'], percussion: {}, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 },
                { bass: ['D2'], synth: ['D4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 },
                { bass: ['E2'], synth: ['E4', 'G4', 'B4'], percussion: {}, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3', 'D4', 'G4'], percussion: {}, delaySend: 0.5 },
                { bass: ['C3'], synth: ['C4', 'F4', 'A4'], percussion: {}, delaySend: 0.5 }
            ],
            outro: [
                { bass: ['A2'], synth: ['A3', 'E4'], percussion: {}, delaySend: 0.8 },
                { bass: ['A2'], synth: ['E4'], percussion: {}, delaySend: 0.7 },
                { bass: ['C3'], synth: ['C4', 'G3'], percussion: {}, delaySend: 0.6 },
                { bass: ['C3'], synth: ['G3'], percussion: {}, delaySend: 0.5 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.4 },
                { bass: ['A2'], synth: ['A3'], percussion: {}, delaySend: 0.3 },
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.2 }, // Ensure notes until the end
                { bass: ['G2'], synth: ['G3'], percussion: {}, delaySend: 0.0 }
            ]
        };

        // Define the song structure as an ordered list of section names with Fibonacci-based durations
        // Each durationMultiplier indicates how many times the section's musicalPhrase should repeat.
        // Fibonacci sequence used for multipliers (scaled): 1, 1, 2, 3, 5, 8...
        const songStructure = [
            { type: 'intro', durationMultiplier: 2 },
            { type: 'verse', baseName: 'verse1', durationMultiplier: 3 }, // Normal verse, will pick a variation
            { type: 'chorus', durationMultiplier: 2 },
            { type: 'verse', baseName: 'verse2', durationMultiplier: 3 }, // Raga verse (next in sequence)
            { type: 'verse', baseName: 'verse3', durationMultiplier: 5 }, // Normal verse, will pick a variation
            { type: 'bridge', durationMultiplier: 2 },
            { type: 'chorus', durationMultiplier: 3 },
            { type: 'verse', baseName: 'verse1', durationMultiplier: 2 }, // Raga verse (next in sequence)
            { type: 'outro', durationMultiplier: 2 }
        ];


        // State variables for song progression
        let currentSongSectionIndex = 0;
        let currentSectionType = ''; // 'intro', 'verse', 'chorus', etc.
        let currentSectionName = ''; // 'verse1_A', 'ragaYamanPhrase', etc. (actual phrase name)
        let currentSectionPhrase = [];
        let currentPhraseIndex = 0; // Index within the current section's phrase
        let stepsPlayedInCurrentSection = 0; // Tracks total steps played in current section
        let currentSectionTotalSteps = 0; // Total steps for the current section based on multiplier

        /**
         * Shuffles an array in place (Fisher-Yates algorithm).
         * @param {Array} array - The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * Gets the next Raga phrase from the available pool, ensuring non-repetition until all are played.
         * @returns {string} The name of the next Raga phrase.
         */
        function getNextRagaPhrase() {
            if (availableRagas.length === 0) {
                availableRagas = [...ragaVerseOptions]; // Reset the pool
                shuffleArray(availableRagas); // Shuffle for new random order
                console.log("Raga pool reset and shuffled:", availableRagas);
            }
            const nextRaga = availableRagas.shift(); // Get the next Raga and remove it from the pool
            console.log("Next Raga:", nextRaga, "Remaining Ragas:", availableRagas);
            return nextRaga;
        }

        /**
         * Selects a random variation for a given normal verse base name.
         * @param {string} baseName - The base name of the verse (e.g., 'verse1').
         * @returns {string} The name of the selected verse variation (e.g., 'verse1_A').
         */
        function getRandomNormalVerseVariation(baseName) {
            const variations = normalVerseOptions[baseName];
            if (!variations || variations.length === 0) {
                console.warn(`No variations found for normal verse: ${baseName}`);
                return baseName; // Fallback to base name if no variations
            }
            const randomIndex = Math.floor(Math.random() * variations.length);
            return variations[randomIndex];
        }

        /**
         * Updates the display with the current song section and applies a highlight.
         */
        function updateSectionDisplay() {
            const displayElement = document.getElementById('currentSectionDisplay');
            if (displayElement) {
                // Remove highlight from previous section
                if (displayElement.textContent !== `Current Section: ${currentSectionName.toUpperCase()}`) {
                     displayElement.classList.remove('highlight');
                }
                displayElement.textContent = `Current Section: ${currentSectionName.toUpperCase()}`;
                // Add highlight for the current section
                requestAnimationFrame(() => { // Use rAF to ensure class is added after potential text update
                    displayElement.classList.add('highlight');
                });
            }
        }

        /**
         * Displays a temporary message to the user in a dedicated message box.
         * @param {string} message - The text message to display.
         * @param {number} duration - How long the message should be visible in milliseconds.
         */
        function showMessage(message, duration = 3000) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            messageBox.classList.add('show'); // Add 'show' class to make it visible
            setTimeout(() => {
                messageBox.classList.remove('show'); // Remove 'show' class to hide it after duration
            }, duration);
        }

        /**
         * Initializes the Web Audio API context and the master gain node.
         * This function needs to be called after a user gesture (e.g., button click)
         * to comply with browser autoplay policies.
         * @returns {boolean} True if audio context was successfully initialized or already exists, false otherwise.
         */
        function initAudio() {
            console.log("Attempting to initialize audio context...");
            if (!audioContext) {
                try {
                    // Create a new AudioContext (or use webkitAudioContext for older browsers)
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Create a master gain node to control overall volume
                    masterGainNode = audioContext.createGain();
                    // Set the master gain value based on the knob
                    masterGainNode.gain.value = masterVolume;
                    // Connect the master gain node to the audio output (speakers)
                    masterGainNode.connect(audioContext.destination);

                    // Delay setup for psychedelic effect
                    delayNode = audioContext.createDelay(2.0); // Max delay time, e.g., 2 seconds
                    delayFeedbackGain = audioContext.createGain();
                    delaySendGain = audioContext.createGain(); // For controlling the wet signal amount

                    // Connect master output to delay send
                    masterGainNode.connect(delaySendGain);
                    delaySendGain.connect(delayNode);

                    // Create feedback loop for delay
                    delayNode.connect(delayFeedbackGain);
                    delayFeedbackGain.connect(delayNode);

                    // Connect delay output (wet signal) to destination
                    delayNode.connect(audioContext.destination);

                    // Analyser Node for Visualization
                    analyserNode = audioContext.createAnalyser();
                    analyserNode.fftSize = 256; // Smaller FFT size for quicker visualization response
                    const bufferLength = analyserNode.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength); // For time domain data

                    // Connect masterGainNode to analyserNode, then analyserNode to destination
                    masterGainNode.disconnect(audioContext.destination); // Disconnect direct connection
                    masterGainNode.connect(analyserNode);
                    analyserNode.connect(audioContext.destination);

                    // Get canvas and volume meter elements
                    audioVisualizerCanvas = document.getElementById('audioVisualizer');
                    audioVisualizerCtx = audioVisualizerCanvas.getContext('2d');
                    volumeMeterElement = document.getElementById('volumeMeter');
                    volumeMeterFillElement = document.getElementById('volumeMeterFill');


                    // Set initial delay parameters
                    delayNode.delayTime.value = delayTimeValue;
                    delayFeedbackGain.gain.value = delayFeedbackValue;
                    delaySendGain.gain.value = delaySendLevel; // Initial send level

                    showMessage(`Audio context initialized. Master Gain: ${masterVolume.toFixed(2)}`);
                    console.log("AudioContext initialized successfully. State:", audioContext.state);
                } catch (e) {
                    // Handle cases where Web Audio API is not supported or initialization fails
                    showMessage("Web Audio API is not supported in this browser or could not be initialized. Please try a different browser.", 5000);
                    console.error("Web Audio API error:", e);
                    return false;
                }
            } else {
                console.log("AudioContext already exists. State:", audioContext.state);
            }
            return true;
        }

        /**
         * Plays a single musical note using an oscillator and applies a simple ADSR envelope,
         * detune, and a low-pass filter.
         * @param {number} frequency - The frequency of the note in Hz.
         * @param {number} startTime - The AudioContext.currentTime when the note should start.
         * @param {number} duration - The duration of the note in seconds.
         * @param {number} detuneValue - The detune value in cents.
         * @param {number} filterFreq - The cutoff frequency for the low-pass filter.
         * @param {number} filterQ - The Q factor for the low-pass filter.
         * @param {string} instrumentType - 'bass' or 'synth' to determine timbre.
         */
        function playNote(frequency, startTime, duration, detuneValue = currentDetune, filterFreq = currentFilterFrequency, filterQ = currentFilterQ, instrumentType = 'synth') {
            // Ensure audio context and master gain node are available
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play note: AudioContext or masterGainNode not available.");
                return;
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();

            // Apply humanization to timing, dynamics, and note length
            // Increased range for more noticeable humanization
            const timingOffset = (Math.random() - 0.5) * 0.08 * humanizationFactor; // +/- 40ms max at full humanization
            const dynamicFactor = 1 + (Math.random() - 0.5) * 0.6 * humanizationFactor; // +/- 30% gain at full humanization
            const durationFactor = 1 + (Math.random() - 0.5) * 0.3 * humanizationFactor; // +/- 15% duration at full humanization

            // Ensure actualStartTime is non-negative
            const actualStartTime = Math.max(0, startTime + timingOffset);
            const actualDuration = duration * durationFactor;


            // Default ADSR values and initial gain
            let attackTime = 0.05;
            let decayTime = 0.2;
            let sustainLevel = 0.5;
            let releaseTime = 0.2;
            let initialGain = synthVolume; // Use global synthVolume by default
            let oscType = 'sine'; // Default for synth

            // Instrument-specific settings
            switch (instrumentType) {
                case 'bass':
                    oscType = 'triangle'; // Richer low end
                    attackTime = 0.02; // Quicker attack for bass punch
                    decayTime = 0.3;
                    sustainLevel = 0.5; // Reduced bass sustain (from 0.8 to 0.5)
                    releaseTime = 0.2; // Reduced bass release (from 0.4 to 0.2)
                    initialGain = bassVolume; // Use global bassVolume
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(400, actualStartTime); // Deeper bass filter
                    filterNode.Q.setValueAtTime(0.8, actualStartTime);
                    break;
                case 'synth':
                default: // Default to synth/pad
                    oscType = 'sine'; // Smooth pads
                    attackTime = 0.1; // Slower attack for pad
                    decayTime = 0.5;
                    sustainLevel = 0.6;
                    releaseTime = 0.8; // Longer release for pad
                    initialGain = synthVolume; // Use global synthVolume
                    filterNode.type = 'lowpass';
                    
                    // Apply a subtle, randomized filter sweep for synth notes
                    const initialFilterFreq = filterFreq * (1 + (Math.random() - 0.5) * 0.2 * humanizationFactor); // Randomize start freq
                    const finalFilterFreq = filterFreq; // Target frequency
                    filterNode.frequency.setValueAtTime(initialFilterFreq, actualStartTime);
                    filterNode.frequency.linearRampToValueAtTime(finalFilterFreq, actualStartTime + 0.5); // Sweep over 0.5s
                    
                    filterNode.Q.setValueAtTime(filterQ, actualStartTime);
                    break;
            }

            oscillator.type = oscType; // Set oscillator type based on instrument
            oscillator.frequency.setValueAtTime(frequency, actualStartTime); // Set note frequency
            oscillator.detune.setValueAtTime(detuneValue, actualStartTime); // Apply subtle detune

            // Connect the audio nodes in a chain: Oscillator -> Filter -> Gain -> Master Gain
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(masterGainNode);

            // Apply the ADSR envelope to the gain node's gain parameter
            gainNode.gain.setValueAtTime(0, actualStartTime); // Start at zero volume
            gainNode.gain.linearRampToValueAtTime(initialGain * dynamicFactor, actualStartTime + attackTime); // Attack: ramp up to peak, with dynamic variation
            gainNode.gain.linearRampToValueAtTime(initialGain * dynamicFactor * sustainLevel, actualStartTime + attackTime + decayTime); // Decay: ramp down to sustain level

            // Calculate the time for the start of the release phase
            // Ensure releaseStartTime is non-negative
            const releaseStartTime = Math.max(actualStartTime, actualStartTime + actualDuration - releaseTime);
            // Ensure finalReleaseTime is not before the attack/decay phases and is non-negative
            const finalReleaseTime = Math.max(actualStartTime + attackTime + decayTime, releaseStartTime);

            // Release: ramp down to zero volume before the note fully stops
            gainNode.gain.exponentialRampToValueAtTime(0.0001, finalReleaseTime);
            gainNode.gain.linearRampToValueAtTime(0, Math.max(actualStartTime, actualStartTime + actualDuration)); // Ensure it reaches absolute zero and time is non-negative

            // Start and stop the oscillator at the scheduled times
            oscillator.start(actualStartTime);
            oscillator.stop(Math.max(actualStartTime, actualStartTime + actualDuration)); // Ensure stop time is non-negative

            // console.log(`Playing note: ${frequency.toFixed(2)} Hz at time ${actualStartTime.toFixed(3)}s for ${actualDuration.toFixed(3)}s. Detune: ${detuneValue}, Filter Freq: ${filterFreq}, Filter Q: ${filterQ}, Humanization: ${humanizationFactor.toFixed(2)}`);

            // Clean up audio nodes once the sound has finished playing to prevent memory leaks
            oscillator.onended = () => {
                oscillator.disconnect();
                gainNode.disconnect();
                filterNode.disconnect();
                // console.log(`Note ended and disconnected: ${frequency.toFixed(2)} Hz`);
            };
        }

        /**
         * Plays a simple drum sound using a short, decaying sine wave.
         * @param {number} startTime - The AudioContext.currentTime when the drum sound should start.
         */
        function playDrum(startTime) {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play drum: AudioContext or masterGainNode not available.");
                return;
            }

            const drumOscillator = audioContext.createOscillator();
            const drumGain = audioContext.createGain();
            const drumFilter = audioContext.createBiquadFilter();

            // Ensure startTime is non-negative
            const actualStartTime = Math.max(0, startTime);

            drumOscillator.type = 'sine'; // Sine wave for a clean thump
            drumOscillator.frequency.setValueAtTime(80, actualStartTime); // Start at 80Hz for a kick-like sound
            drumOscillator.frequency.exponentialRampToValueAtTime(30, actualStartTime + 0.1); // Rapidly decay frequency for pitch drop

            drumFilter.type = 'lowpass';
            drumFilter.frequency.setValueAtTime(500, actualStartTime);
            drumFilter.frequency.exponentialRampToValueAtTime(100, actualStartTime + 0.15); // Filter sweep
            drumFilter.Q.setValueAtTime(1, actualStartTime);

            drumOscillator.connect(drumFilter);
            drumFilter.connect(drumGain);
            drumGain.connect(masterGainNode);

            // Envelope for the drum sound
            drumGain.gain.setValueAtTime(kickVolume, actualStartTime); // Use global kickVolume
            drumGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.2); // Quick decay

            drumOscillator.start(actualStartTime);
            drumOscillator.stop(actualStartTime + 0.2); // Short duration

            drumOscillator.onended = () => {
                drumOscillator.disconnect();
                drumGain.disconnect();
                drumFilter.disconnect();
            };
            // console.log(`Playing drum at time ${actualStartTime.toFixed(3)}s.`);
        }

        /**
         * Plays a snare drum sound using white noise and an oscillator.
         * @param {number} startTime - The AudioContext.currentTime when the snare sound should start.
         */
        function playSnare(startTime) {
            if (!audioContext || !masterGainNode) {
                console.warn("Cannot play snare: AudioContext or masterGainNode not available.");
                return;
            }

            // Ensure startTime is non-negative
            const actualStartTime = Math.max(0, startTime);

            // Snare "snap" (noise)
            const noise = audioContext.createBufferSource();
            const bufferSize = audioContext.sampleRate * 0.2; // 0.2 seconds of noise
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1; // White noise
            }
            noise.buffer = buffer;

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(snareVolume * 0.7, actualStartTime); // Use global snareVolume, scaled
            noiseGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.15); // Quick decay
            noise.connect(noiseGain);

            // Snare "thwack" (oscillator) - high-pitched, short burst
            const osc = audioContext.createOscillator();
            osc.type = 'triangle'; // Triangle wave for a slightly softer thwack than square
            osc.frequency.setValueAtTime(200, actualStartTime);
            osc.frequency.exponentialRampToValueAtTime(100, actualStartTime + 0.1); // Pitch drop for transient

            const oscGain = audioContext.createGain();
            oscGain.gain.setValueAtTime(snareVolume * 1.0, actualStartTime); // Use global snareVolume
            oscGain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.1); // Quick decay
            osc.connect(oscGain);

            // Mix noise and oscillator, then connect to master
            const mixer = audioContext.createGain();
            noiseGain.connect(mixer);
            oscGain.connect(mixer);
            mixer.connect(masterGainNode);

            noise.start(actualStartTime);
            osc.start(actualStartTime);
            noise.stop(actualStartTime + 0.2);
            osc.stop(actualStartTime + 0.2);

            noise.onended = () => {
                noise.disconnect();
                osc.disconnect();
                noiseGain.disconnect();
                oscGain.disconnect();
                mixer.disconnect();
            };
            // console.log(`Playing snare at time ${actualStartTime.toFixed(3)}s.`);
        }

        /**
         * Plays a closed hi-hat sound.
         * @param {number} startTime - The AudioContext.currentTime when the hi-hat sound should start.
         */
        function playHiHatClosed(startTime) {
            if (!audioContext || !masterGainNode) return;

            // Ensure startTime is non-negative
            const actualStartTime = Math.max(0, startTime);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(10000, actualStartTime); // High frequency for hi-hat
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(7000, actualStartTime); // Filter out low frequencies
            filter.Q.setValueAtTime(0.5, actualStartTime);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGainNode);

            gain.gain.setValueAtTime(hihatVolume * 0.7, actualStartTime); // Use global hihatVolume, scaled
            gain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.05); // Very quick decay

            osc.start(actualStartTime);
            osc.stop(actualStartTime + 0.05);

            osc.onended = () => {
                osc.disconnect(); // Corrected: use 'osc'
                gain.disconnect();
                filter.disconnect();
            };
        }

        /**
         * Plays an open hi-hat sound.
         * @param {number} startTime - The AudioContext.currentTime when the hi-hat sound should start.
         */
        function playHiHatOpen(startTime) {
            if (!audioContext || !masterGainNode) return;

            // Ensure startTime is non-negative
            const actualStartTime = Math.max(0, startTime);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'square';
            osc.frequency.setValueAtTime(8000, actualStartTime); // Slightly lower frequency than closed for open feel
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(5000, actualStartTime); // Less aggressive filter for open sound
            filter.Q.setValueAtTime(0.5, actualStartTime);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGainNode);

            gain.gain.setValueAtTime(hihatVolume * 1.0, actualStartTime); // Use global hihatVolume
            gain.gain.exponentialRampToValueAtTime(0.001, actualStartTime + 0.2); // Longer decay for open sound

            osc.start(actualStartTime);
            osc.stop(actualStartTime + 0.2);

            osc.onended = () => {
                osc.disconnect(); // Corrected: use 'osc'
                gain.disconnect();
                filter.disconnect();
            };
        }

        /**
         * Applies subtle, random changes to various musical parameters for the next musical step.
         * These changes are applied on top of the user-controlled knob values.
         */
        function applySubtleChanges() {
            const driftScale = fibonacciDriftScales[currentFibonacciDriftScaleIndex];

            // Detune variation: Introduce a slow "wobble" to the pitch
            currentDetune += detuneDriftDirection * (Math.random() * driftScale * 1.5 + (driftScale / 2)); // More prominent drift
            if (currentDetune > 12) { // Upper bound for detune
                detuneDriftDirection = -1;
            } else if (currentDetune < -12) { // Lower bound for detune
                detuneDriftDirection = 1;
            }
            currentDetune = Math.max(-12, Math.min(12, currentDetune)); // Clamp detune

            // Filter frequency variation: Change the low-pass filter's cutoff with slow drift
            currentFilterFrequency += filterDriftDirection * (Math.random() * driftScale * 50 + 10); // More prominent drift
            if (currentFilterFrequency > 3000) { // Upper bound for filter freq
                filterDriftDirection = -1;
            } else if (currentFilterFrequency < 500) { // Lower bound for filter freq
                filterDriftDirection = 1;
            }
            currentFilterFrequency = Math.max(500, Math.min(3000, currentFilterFrequency)); // Clamp filter freq

            // Filter Q variation: Change the filter's resonance
            currentFilterQ += (Math.random() - 0.5) * driftScale * 0.5; // Influenced by drift scale
            currentFilterQ = Math.max(0.5, Math.min(3, currentFilterQ)); // Keep Q within bounds

            // Note duration variation: Slightly change the base duration of notes
            baseNoteDuration += (Math.random() - 0.5) * driftScale * 0.05; // Influenced by drift scale
            baseNoteDuration = Math.max(0.3, Math.min(0.7, baseNoteDuration)); // Keep duration within bounds

            // Humanization factor variation:
            humanizationFactor += (Math.random() - 0.5) * driftScale * 0.1; // Influenced by drift scale
            humanizationFactor = Math.max(0.1, Math.min(1.0, humanizationFactor)); // Clamp between 0.1 and 1.0

            // Tempo variation removed: Tempo is now fixed by the knob value for perfect sync.

            // Delay Time variation:
            delayTimeValue += delayTimeDriftDirection * (Math.random() - 0.5) * driftScale * 0.02; // Subtle delay time drift
            if (delayTimeValue > 1.0) { // Keep within a reasonable range for audible delay
                delayTimeDriftDirection = -1;
            } else if (delayTimeValue < 0.1) {
                delayTimeDriftDirection = 1;
            }
            delayTimeValue = Math.max(0.01, Math.min(2.0, delayTimeValue)); // Clamp to knob range
            if (delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, audioContext.currentTime);

            // Delay Feedback variation:
            delayFeedbackValue += delayFeedbackDriftDirection * (Math.random() - 0.5) * driftScale * 0.01; // Subtle feedback drift
            if (delayFeedbackValue > 0.8) { // Prevent runaway feedback
                delayFeedbackDriftDirection = -1;
            } else if (delayFeedbackValue < 0.1) {
                delayFeedbackDriftDirection = 1;
            }
            delayFeedbackValue = Math.max(0, Math.min(0.95, delayFeedbackValue)); // Clamp to knob range
            if (delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, audioContext.currentTime);
        }

        /**
         * The main audio scheduling loop. It continuously checks if there are events
         * to be played in the near future and schedules them using AudioContext.currentTime.
         * This method is more precise than setTimeout for timing musical events.
         */
        function scheduler() {
            // Stop if playing is false or audio context is not ready
            if (!isPlaying || !audioContext) {
                console.log("Scheduler stopping: isPlaying=", isPlaying, " audioContext=", audioContext);
                return;
            }

            // Schedule events in advance (e.g., 100ms ahead of current time)
            while (nextNoteTime < audioContext.currentTime + 0.1) {
                const currentStep = currentSectionPhrase[currentPhraseIndex]; // Use currentSectionPhrase directly
                // Use baseNoteDuration (which is dynamically changing) for melodic elements
                const duration = baseNoteDuration;

                // Apply delay send level for this step with a smooth ramp
                const effectiveDelaySend = (currentStep.delaySend !== undefined ? currentStep.delaySend : 0.5) * delaySendLevel;
                if (delaySendGain) {
                    // Smooth transition for delay send level over a short period
                    delaySendGain.gain.linearRampToValueAtTime(effectiveDelaySend, audioContext.currentTime + 0.05);
                }

                // Play synth notes/chords if defined for this step
                if (currentStep.synth && currentStep.synth.length > 0) {
                    currentStep.synth.forEach(noteName => {
                        const frequency = notes[noteName];
                        if (frequency) {
                            playNote(frequency, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, 'synth');
                        } else {
                            console.warn(`Synth note frequency not found for note: ${noteName}`);
                        }
                    });
                }

                // Play bass notes if defined for this step
                if (currentStep.bass && currentStep.bass.length > 0) {
                    currentStep.bass.forEach(noteName => {
                        const frequency = notes[noteName];
                        if (frequency) {
                            playNote(frequency, nextNoteTime, duration, currentDetune, currentFilterFrequency, currentFilterQ, 'bass');
                        } else {
                            console.warn(`Bass note frequency not found for note: ${noteName}`);
                        }
                    });
                }

                // Play percussion elements if defined for this step
                if (currentStep.percussion) {
                    if (currentStep.percussion.kick) {
                        playDrum(nextNoteTime);
                    }
                    if (currentStep.percussion.snare) {
                        playSnare(nextNoteTime);
                    }
                    if (currentStep.percussion.hihat === 'closed') {
                        playHiHatClosed(nextNoteTime);
                    } else if (currentStep.percussion.hihat === 'open') {
                        playHiHatOpen(nextNoteTime);
                    }
                }

                // Advance the 'nextNoteTime' by the current tempo (converted to seconds)
                // This ensures all elements for the current step play simultaneously
                nextNoteTime += (currentTempo / 1000);
                
                // Increment steps played in current section
                stepsPlayedInCurrentSection++;

                // Move to the next step in the current phrase
                currentPhraseIndex++;

                // Apply subtle changes for the next step's parameters
                applySubtleChanges();

                // If the end of the current section's phrase is reached, loop it or transition
                if (currentPhraseIndex >= currentSectionPhrase.length) { // Use currentSectionPhrase.length
                    currentPhraseIndex = 0; // Loop the phrase
                }

                // Check if the total steps for the current section have been played
                if (stepsPlayedInCurrentSection >= currentSectionTotalSteps) {
                    console.log(`End of section '${currentSectionName}' reached.`);
                    currentPhraseIndex = 0; // Reset phrase index for the new section
                    stepsPlayedInCurrentSection = 0; // Reset steps played for the new section
                    currentSongSectionIndex++; // Move to the next section in the song structure

                    // Advance Fibonacci drift scale index with each section change
                    currentFibonacciDriftScaleIndex = (currentFibonacciDriftScaleIndex + 1) % fibonacciDriftScales.length;

                    // If the end of the song structure is reached, loop back to the beginning (intro)
                    if (currentSongSectionIndex >= songStructure.length) {
                        currentSongSectionIndex = 0; // Loop back to intro
                        console.log("End of song structure reached. Looping back to Intro.");
                    }

                    const nextSectionDef = songStructure[currentSongSectionIndex];
                    currentSectionType = nextSectionDef.type; // Update section type

                    // Handle unique verse cycling, including Raga verses and normal verse variations
                    if (currentSectionType === 'verse') {
                        verseIterationCount++;
                        // Force the first verse (which is at index 1 in songStructure) to be the _C variation
                        if (currentSongSectionIndex === 1) { 
                            currentSectionName = nextSectionDef.baseName + '_C'; // Force _C variation
                            currentSectionPhrase = musicalPhrases[currentSectionName];
                            console.log(`Forcing first verse to start with: ${currentSectionName}`);
                        } else if (verseIterationCount % 2 === 0) { // Every 2nd verse (after the initial forced one) is a Raga verse
                            currentSectionName = getNextRagaPhrase(); // Get non-repeating Raga
                            // Dynamically generate Raga melody. Use a fixed length (e.g., 8 steps) for Raga phrases.
                            const ragaScaleName = currentSectionName === 'ragaYamanPhrase' ? 'yaman' : 'bhairavi';
                            currentSectionPhrase = generateRagaMelody(ragaScales[ragaScaleName], 8, humanizationFactor);
                        } else { // Normal verse, pick a random variation (including A, B, C, D)
                            currentSectionName = getRandomNormalVerseVariation(nextSectionDef.baseName);
                            currentSectionPhrase = musicalPhrases[currentSectionName]; // Use pre-defined variation
                        }
                    } else {
                        currentSectionName = nextSectionDef.name || nextSectionDef.type; // For non-verse sections, name is type
                        currentSectionPhrase = musicalPhrases[currentSectionName]; // Use pre-defined phrase
                    }
                    
                    // Recalculate total steps for the new section based on its (potentially new) phrase length
                    currentSectionTotalSteps = currentSectionPhrase.length * nextSectionDef.durationMultiplier;
                    console.log(`Transitioning to section: ${currentSectionName} (type: ${currentSectionType}) for ${currentSectionTotalSteps} steps. Humanization Factor: ${humanizationFactor.toFixed(2)}`);
                    updateSectionDisplay(); // Update UI
                }
            }

            // Schedule the next call to the scheduler function after a short delay (e.g., 50ms)
            loopTimeoutId = setTimeout(scheduler, 50);
        }

        /**
         * Starts the music looping. Handles initial audio context setup and resumption.
         */
        function startLoop() {
            console.log("Start button clicked. Attempting to start loop.");
            // Initialize audio context; if it fails, stop execution
            if (!initAudio()) {
                console.error("Audio initialization failed. Cannot start loop.");
                return;
            }

            // Check if audio context is suspended (common due to browser autoplay policies)
            if (audioContext.state === 'suspended') {
                console.log("AudioContext is suspended. Attempting to resume...");
                // Attempt to resume the audio context
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully!');
                    startLoopInternal(); // Proceed to start the loop
                }).catch(e => {
                    // Display error if resumption fails
                    showMessage("Could not resume audio context. Please try again or check browser settings.", 3000);
                    console.error("AudioContext resume error:", e);
                });
            } else {
                console.log("AudioContext is already running or pending. Starting loop directly.");
                startLoopInternal(); // If not suspended, start directly
            }
        }

        /**
         * Internal function to start the music loop after audio context is ready.
         */
        function startLoopInternal() {
            if (isPlaying) {
                console.log("Loop is already playing. Skipping start.");
                return; // Prevent starting if already playing
            }

            isPlaying = true; // Set playing flag to true
            nextNoteTime = audioContext.currentTime; // Set the starting time for scheduling
            
            // Initialize song structure variables for the first section
            currentSongSectionIndex = 0;
            const initialSectionDef = songStructure[currentSongSectionIndex];
            currentSectionType = initialSectionDef.type;
            
            // Special handling for first verse to pick a variation or Raga
            if (currentSectionType === 'verse') {
                verseIterationCount = 1; // First verse is a normal one
                // Force the very first verse to be the _C variation
                currentSectionName = initialSectionDef.baseName + '_C';
                currentSectionPhrase = musicalPhrases[currentSectionName];
                console.log(`Forcing initial verse to start with: ${currentSectionName}`);
            } else {
                currentSectionName = initialSectionDef.name || initialSectionDef.type;
                currentSectionPhrase = musicalPhrases[currentSectionName]; // Use pre-defined phrase
            }

            // Shuffle Raga pool at the very beginning to ensure random start
            shuffleArray(availableRagas);

            currentPhraseIndex = 0;
            stepsPlayedInCurrentSection = 0;
            currentSectionTotalSteps = currentSectionPhrase.length * initialSectionDef.durationMultiplier;
            updateSectionDisplay();
            console.log(`Starting with section: ${currentSectionName} (type: ${currentSectionType}) for ${currentSectionTotalSteps} steps. Humanization Factor: ${humanizationFactor.toFixed(2)}`);


            // Fade in master gain for a smooth start (especially for the intro)
            masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
            masterGainNode.gain.linearRampToValueAtTime(masterVolume, audioContext.currentTime + 4); // Fade in over 4 seconds to masterVolume

            scheduler(); // Start the main scheduling loop
            drawVisualization(); // Start the visualization loop

            // Update button states
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false;
            showMessage("Music started. Enjoy the evolving structured loop!");
            console.log("Music loop started.");
        }

        /**
         * Stops the music looping by clearing the scheduler timeout and suspending the audio context.
         */
        function stopLoop() {
            console.log("Stop button clicked. Attempting to stop loop.");
            isPlaying = false; // Set playing flag to false
            clearTimeout(loopTimeoutId); // Stop the scheduler loop

            // Fade out master gain before suspending for a smooth stop
            if (audioContext && masterGainNode) {
                masterGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                masterGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1); // Fade out over 1 second
                setTimeout(() => {
                    if (audioContext && audioContext.state === 'running') {
                        audioContext.suspend().then(() => {
                            console.log('AudioContext suspended successfully!');
                            showMessage("Music stopped.");
                        }).catch(e => {
                            showMessage("Could not suspend audio context.", 3000);
                            console.error("AudioContext suspend error:", e);
                        });
                    } else {
                        console.log("AudioContext is not running or already suspended.");
                        showMessage("Music stopped.");
                    }
                }, 1000); // Wait for fade out to complete before suspending
            } else {
                console.log("AudioContext or masterGainNode not available for smooth stop.");
                showMessage("Music stopped.");
            }
            
            // Update button states
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            console.log("Music loop stopped.");
        }

        /**
         * Draws the audio visualization on the canvas and updates the volume meter.
         * This function is called repeatedly using requestAnimationFrame.
         */
        function drawVisualization() {
            if (!isPlaying || !analyserNode || !audioVisualizerCtx) {
                // Clear canvas if not playing
                if (audioVisualizerCtx) {
                    audioVisualizerCtx.clearRect(0, 0, audioVisualizerCanvas.width, audioVisualizerCanvas.height);
                }
                // Reset volume meter
                if (volumeMeterFillElement) {
                    volumeMeterFillElement.style.width = '0%';
                }
                return;
            }

            requestAnimationFrame(drawVisualization);

            // Get time domain data for waveform and volume meter
            analyserNode.getByteTimeDomainData(dataArray);

            // Clear the canvas
            audioVisualizerCtx.clearRect(0, 0, audioVisualizerCanvas.width, audioVisualizerCanvas.height);
            audioVisualizerCtx.lineWidth = 2;
            audioVisualizerCtx.strokeStyle = '#90ee90'; // Green waveform
            audioVisualizerCtx.beginPath();

            const sliceWidth = audioVisualizerCanvas.width * 1.0 / dataArray.length;
            let x = 0;

            let sumOfSquares = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const v = dataArray[i] / 128.0; // Normalize to -1 to 1
                const y = v * audioVisualizerCanvas.height / 2; // Scale to canvas height

                if (i === 0) {
                    audioVisualizerCtx.moveTo(x, y);
                } else {
                    audioVisualizerCtx.lineTo(x, y);
                }

                x += sliceWidth;

                // Calculate sum of squares for RMS (Root Mean Square) for volume meter
                const normalizedValue = (dataArray[i] - 128) / 128; // Normalize to -1 to 1
                sumOfSquares += normalizedValue * normalizedValue;
            }

            audioVisualizerCtx.lineTo(audioVisualizerCanvas.width, audioVisualizerCanvas.height / 2);
            audioVisualizerCtx.stroke();

            // Update Volume Meter
            const rms = Math.sqrt(sumOfSquares / dataArray.length);
            // Scale RMS to a 0-100% range for the meter, adjust sensitivity as needed
            const volumePercentage = Math.min(100, rms * 200); // Multiply by 200 for more visual response
            if (volumeMeterFillElement) {
                volumeMeterFillElement.style.width = `${volumePercentage}%`;
            }
        }

        /**
         * Collects all current knob values into an object.
         * @returns {Object} An object containing all current settings.
         */
        function getCurrentSettings() {
            return {
                masterVolume: parseFloat(document.getElementById('masterVolume').value),
                tempo: parseFloat(document.getElementById('tempo').value),
                bassVolume: parseFloat(document.getElementById('bassVolume').value),
                synthVolume: parseFloat(document.getElementById('synthVolume').value),
                kickVolume: parseFloat(document.getElementById('kickVolume').value),
                snareVolume: parseFloat(document.getElementById('snareVolume').value),
                hihatVolume: parseFloat(document.getElementById('hihatVolume').value),
                delayTime: parseFloat(document.getElementById('delayTime').value),
                delayFeedback: parseFloat(document.getElementById('delayFeedback').value),
                delaySendLevel: parseFloat(document.getElementById('delaySendLevel').value),
                // Add other dynamic parameters if you want them saved with presets
                currentDetune: currentDetune,
                currentFilterFrequency: currentFilterFrequency,
                currentFilterQ: currentFilterQ,
                baseNoteDuration: baseNoteDuration,
                humanizationFactor: humanizationFactor
            };
        }

        /**
         * Applies saved settings to the knobs and global variables.
         * @param {Object} settings - An object containing settings to apply.
         */
        function applySettings(settings) {
            // Update knob values and trigger their callbacks
            setupKnob('masterVolume', 'masterVolumeValue', settings.masterVolume, 2, (value) => { masterVolume = value; if (audioContext && masterGainNode) masterGainNode.gain.setValueAtTime(masterVolume, audioContext.currentTime); });
            setupKnob('tempo', 'tempoValue', settings.tempo, 0, (value) => { currentTempo = value; });
            setupKnob('bassVolume', 'bassVolumeValue', settings.bassVolume, 2, (value) => { bassVolume = value; });
            setupKnob('synthVolume', 'synthVolumeValue', settings.synthVolume, 2, (value) => { synthVolume = value; });
            setupKnob('kickVolume', 'kickVolumeValue', settings.kickVolume, 2, (value) => { kickVolume = value; });
            setupKnob('snareVolume', 'snareVolumeValue', settings.snareVolume, 2, (value) => { snareVolume = value; });
            setupKnob('hihatVolume', 'hihatVolumeValue', settings.hihatVolume, 2, (value) => { hihatVolume = value; });
            setupKnob('delayTime', 'delayTimeValue', settings.delayTime, 2, (value) => { delayTimeValue = value; if (audioContext && delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, audioContext.currentTime); });
            setupKnob('delayFeedback', 'delayFeedbackValue', settings.delayFeedback, 2, (value) => { delayFeedbackValue = value; if (audioContext && delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, audioContext.currentTime); });
            setupKnob('delaySendLevel', 'delaySendLevelValue', settings.delaySendLevel, 2, (value) => { delaySendLevel = value; });

            // Update other global dynamic parameters
            currentDetune = settings.currentDetune;
            currentFilterFrequency = settings.currentFilterFrequency;
            currentFilterQ = settings.currentFilterQ;
            baseNoteDuration = settings.baseNoteDuration;
            humanizationFactor = settings.humanizationFactor;

            showMessage("Preset loaded successfully!");
            console.log("Settings applied:", settings);
        }

        /**
         * Saves the current knob settings to local storage.
         */
        function savePreset() {
            const presetNameInput = document.getElementById('presetNameInput');
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                showMessage("Please enter a name for your preset.", 2000);
                return;
            }
            try {
                const settings = getCurrentSettings();
                localStorage.setItem(`looper_preset_${presetName}`, JSON.stringify(settings));
                showMessage(`Preset "${presetName}" saved!`);
                console.log(`Preset "${presetName}" saved:`, settings);
            } catch (e) {
                showMessage("Failed to save preset. Local storage might be full or unavailable.", 3000);
                console.error("Error saving preset:", e);
            }
        }

        /**
         * Loads a preset from local storage and applies its settings.
         */
        function loadPreset() {
            const presetNameInput = document.getElementById('presetNameInput');
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                showMessage("Please enter the name of the preset to load.", 2000);
                return;
            }
            try {
                const savedSettings = localStorage.getItem(`looper_preset_${presetName}`);
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    applySettings(settings);
                } else {
                    showMessage(`Preset "${presetName}" not found.`, 2000);
                    console.warn(`Preset "${presetName}" not found.`);
                }
            } catch (e) {
                showMessage("Failed to load preset. Data might be corrupted.", 3000);
                console.error("Error loading preset:", e);
            }
        }


        // --- Knob Event Listeners and Value Display ---
        // Modified setupKnob function to directly use initial values and a callback for updates
        function setupKnob(knobId, valueSpanId, initialValue, displayPrecision = 2, onInputChangeCallback) {
            const knob = document.getElementById(knobId);
            const valueSpan = document.getElementById(valueSpanId);

            // Set initial values and display
            knob.value = initialValue;
            valueSpan.textContent = initialValue.toFixed(displayPrecision);

            knob.addEventListener('input', (event) => {
                let value = parseFloat(event.target.value);
                valueSpan.textContent = value.toFixed(displayPrecision);
                if (onInputChangeCallback) {
                    onInputChangeCallback(value); // Execute the callback to update the global variable
                }
            });
        }

        // Add event listeners once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Attaching event listeners.");
            document.getElementById('startButton').addEventListener('click', startLoop);
            document.getElementById('stopButton').addEventListener('click', stopLoop);
            document.getElementById('savePresetButton').addEventListener('click', savePreset);
            document.getElementById('loadPresetButton').addEventListener('click', loadPreset);
            updateSectionDisplay(); // Initialize display

            // Setup all knobs with their initial values and specific update logic
            setupKnob('masterVolume', 'masterVolumeValue', masterVolume, 2, (value) => {
                masterVolume = value;
                if (audioContext && masterGainNode) masterGainNode.gain.setValueAtTime(masterVolume, audioContext.currentTime);
            });
            setupKnob('bassVolume', 'bassVolumeValue', bassVolume, 2, (value) => {
                bassVolume = value;
            });
            setupKnob('synthVolume', 'synthVolumeValue', synthVolume, 2, (value) => {
                synthVolume = value;
            });
            setupKnob('kickVolume', 'kickVolumeValue', kickVolume, 2, (value) => {
                kickVolume = value;
            });
            setupKnob('snareVolume', 'snareVolumeValue', snareVolume, 2, (value) => {
                snareVolume = value;
            });
            setupKnob('hihatVolume', 'hihatVolumeValue', hihatVolume, 2, (value) => {
                hihatVolume = value;
            });
            setupKnob('tempo', 'tempoValue', currentTempo, 0, (value) => {
                currentTempo = value;
            });
            setupKnob('delayTime', 'delayTimeValue', delayTimeValue, 2, (value) => {
                delayTimeValue = value;
                if (audioContext && delayNode) delayNode.delayTime.setValueAtTime(delayTimeValue, audioContext.currentTime);
            });
            setupKnob('delayFeedback', 'delayFeedbackValue', delayFeedbackValue, 2, (value) => {
                delayFeedbackValue = value;
                if (audioContext && delayFeedbackGain) delayFeedbackGain.gain.setValueAtTime(delayFeedbackValue, audioContext.currentTime);
            });
            setupKnob('delaySendLevel', 'delaySendLevelValue', delaySendLevel, 2, (value) => {
                delaySendLevel = value;
                // The actual `delaySendGain.gain` will be updated in the scheduler based on per-step `delaySend` and this master value
            });
        });
    </script>
</body>
</html>
